diff --git a/amffmpeg/Android.mk b/amffmpeg/Android.mk
new file mode 100644
index 0000000..5053e7d
--- /dev/null
+++ b/amffmpeg/Android.mk
@@ -0,0 +1 @@
+include $(call all-subdir-makefiles)
diff --git a/amffmpeg/common.mk b/amffmpeg/common.mk
new file mode 100644
index 0000000..d9955cf
--- /dev/null
+++ b/amffmpeg/common.mk
@@ -0,0 +1,34 @@
+include $(LOCAL_PATH)/../config.mak
+
+OBJS :=
+OBJS-yes :=
+MMX-OBJS-yes :=
+FFLIBS :=
+
+include $(LOCAL_PATH)/Makefile
+OBJS += $(OBJS-yes)
+
+# collect objects
+FFNAME := lib$(NAME)
+FFLIBS := $(foreach NAME,$(FFLIBS),lib$(NAME))
+FFCFLAGS = $(CFLAGS)
+FFCFLAGS += -DHAVE_AV_CONFIG_H
+
+ALL_S_FILES := $(wildcard $(LOCAL_PATH)/$(TARGET_ARCH)/*.S)
+ALL_S_FILES := $(addprefix $(TARGET_ARCH)/, $(notdir $(ALL_S_FILES)))
+
+ifneq ($(ALL_S_FILES),)
+ALL_S_OBJS := $(patsubst %.S,%.o,$(ALL_S_FILES))
+C_OBJS := $(filter-out $(ALL_S_OBJS),$(OBJS)) 
+S_OBJS := $(filter $(ALL_S_OBJS),$(OBJS))
+else
+C_OBJS := $(OBJS)
+S_OBJS :=
+endif
+
+C_FILES := $(patsubst %.o,%.c,$(C_OBJS))
+S_FILES := $(patsubst %.o,%.S,$(S_OBJS))
+
+FFFILES := $(sort $(S_FILES)) $(sort $(C_FILES))
+
+LOCAL_ARM_MODE := arm
diff --git a/amffmpeg/config.fate b/amffmpeg/config.fate
new file mode 100644
index 0000000..5e45955
--- /dev/null
+++ b/amffmpeg/config.fate
@@ -0,0 +1 @@
+config:arm::generic:linux:gcc 4.3.2 (Sourcery G++ Lite 2008q3-72):--disable-yasm --disable-ffplay --cross-prefix=arm-none-linux-gnueabi- --enable-cross-compile --target-os=linux --arch=arm
diff --git a/amffmpeg/config.h b/amffmpeg/config.h
new file mode 100644
index 0000000..680edac
--- /dev/null
+++ b/amffmpeg/config.h
@@ -0,0 +1,1041 @@
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_H
+#define FFMPEG_CONFIG_H
+#define FFMPEG_CONFIGURATION "--disable-yasm --disable-ffplay --cross-prefix=arm-none-linux-gnueabi- --enable-cross-compile --target-os=linux --arch=arm"
+#define FFMPEG_LICENSE "LGPL version 2.1 or later"
+#define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
+#define CC_TYPE "gcc"
+#define CC_VERSION __VERSION__
+#define restrict restrict
+#define EXTERN_PREFIX ""
+#define EXTERN_ASM 
+#define SLIBSUF ".so"
+
+
+
+#define ARCH_ALPHA 0
+#undef  ARCH_ARM
+#define ARCH_ARM 1
+#define ARCH_AVR32 0
+#define ARCH_AVR32_AP 0
+#define ARCH_AVR32_UC 0
+#define ARCH_BFIN 0
+#define ARCH_IA64 0
+#define ARCH_M68K 0
+#define ARCH_MIPS 0
+#define ARCH_MIPS64 0
+#define ARCH_PARISC 0
+#define ARCH_PPC 0
+#define ARCH_PPC64 0
+#define ARCH_S390 0
+#define ARCH_SH4 0
+#define ARCH_SPARC 0
+#define ARCH_SPARC64 0
+#define ARCH_TOMI 0
+#define ARCH_X86 0
+#define ARCH_X86_32 0
+#define ARCH_X86_64 0
+#define HAVE_ALTIVEC 0
+#define HAVE_AMD3DNOW 0
+#define HAVE_AMD3DNOWEXT 0
+#define HAVE_ARMV5TE 0
+#define HAVE_ARMV6 0
+#define HAVE_ARMV6T2 0
+#define HAVE_ARMVFP 0
+#define HAVE_AVX 0
+#define HAVE_IWMMXT 0
+#define HAVE_MMI 0
+#define HAVE_MMX 0
+#define HAVE_MMX2 0
+#define HAVE_NEON 0
+#define HAVE_PPC4XX 0
+#define HAVE_SSE 0
+#define HAVE_SSSE3 0
+#define HAVE_VFPV3 0
+#define HAVE_VIS 0
+#define HAVE_BIGENDIAN 0
+#define HAVE_FAST_UNALIGNED 0
+#undef  HAVE_PTHREADS
+#define HAVE_PTHREADS 1
+#define HAVE_W32THREADS 0
+#define HAVE_ALIGNED_STACK 0
+#define HAVE_ALSA_ASOUNDLIB_H 0
+#define HAVE_ALTIVEC_H 0
+#define HAVE_ARPA_INET_H 1
+#define HAVE_ATTRIBUTE_MAY_ALIAS 1
+#define HAVE_ATTRIBUTE_PACKED 1
+#define HAVE_BSWAP 0
+#define HAVE_CLOSESOCKET 0
+#define HAVE_CMOV 0
+#define HAVE_DCBZL 0
+#define HAVE_DEV_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_BKTR_IOCTL_METEOR_H 0
+#define HAVE_DEV_IC_BT8XX_H 0
+#define HAVE_DEV_VIDEO_METEOR_IOCTL_METEOR_H 0
+#define HAVE_DEV_VIDEO_BKTR_IOCTL_BT848_H 0
+#define HAVE_DLFCN_H 1
+#define HAVE_DLOPEN 1
+#define HAVE_DOS_PATHS 0
+#define HAVE_EBP_AVAILABLE 0
+#define HAVE_EBX_AVAILABLE 0
+#define HAVE_EXP2 1
+#define HAVE_EXP2F 1
+#define HAVE_FAST_64BIT 0
+#define HAVE_FAST_CLZ 0
+#define HAVE_FAST_CMOV 0
+#define HAVE_FCNTL 1
+#define HAVE_FORK 1
+#define HAVE_GETADDRINFO 1
+#define HAVE_GETHRTIME 0
+#define HAVE_GETPROCESSMEMORYINFO 0
+#define HAVE_GETPROCESSTIMES 0
+#define HAVE_GETRUSAGE 1
+#define HAVE_GNU_AS 1
+#define HAVE_STRUCT_RUSAGE_RU_MAXRSS 1
+#define HAVE_IBM_ASM 0
+#define HAVE_INET_ATON 1
+#define HAVE_INLINE_ASM 1
+#define HAVE_ISATTY 1
+#define HAVE_KBHIT 0
+#define HAVE_LDBRX 0
+#define HAVE_LLRINT 1
+#define HAVE_LLRINTF 1
+#define HAVE_LOCAL_ALIGNED_16 0
+#define HAVE_LOCAL_ALIGNED_8 0
+#define HAVE_LOCALTIME_R 1
+#define HAVE_LOG2 1
+#define HAVE_LOG2F 1
+#define HAVE_LOONGSON 0
+#define HAVE_LRINT 1
+#define HAVE_LRINTF 1
+#define HAVE_LZO1X_999_COMPRESS 0
+#define HAVE_MACHINE_IOCTL_BT848_H 0
+#define HAVE_MACHINE_IOCTL_METEOR_H 0
+#undef  HAVE_MALLOC_H 
+#define HAVE_MALLOC_H 1
+#define HAVE_MAPVIEWOFFILE 0
+#define HAVE_MEMALIGN 1
+#define HAVE_MKSTEMP 1
+#define HAVE_MMAP 1
+#define HAVE_PLD 0
+#define HAVE_POSIX_MEMALIGN 0
+#define HAVE_ROUND 1
+#define HAVE_ROUNDF 1
+#define HAVE_SDL 0
+#define HAVE_SDL_VIDEO_SIZE 0
+#define HAVE_SETMODE 0
+#define HAVE_SNDIO_H 0
+#define HAVE_SOCKLEN_T 1
+#define HAVE_SOUNDCARD_H 0
+#define HAVE_POLL_H 1
+#define HAVE_SETRLIMIT 1
+#define HAVE_STRERROR_R 1
+#define HAVE_STRTOK_R 1
+#define HAVE_STRUCT_ADDRINFO 1
+#define HAVE_STRUCT_IPV6_MREQ 1
+#define HAVE_STRUCT_SOCKADDR_IN6 1
+#define HAVE_STRUCT_SOCKADDR_SA_LEN 0
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
+#define HAVE_SYMVER 1
+#define HAVE_SYMVER_GNU_ASM 1
+#define HAVE_SYMVER_ASM_LABEL 0
+#define HAVE_SYS_MMAN_H 1
+#define HAVE_SYS_RESOURCE_H 1
+#define HAVE_SYS_SELECT_H 1
+#define HAVE_SYS_SOUNDCARD_H 1
+#define HAVE_SYS_VIDEOIO_H 0
+#define HAVE_TEN_OPERANDS 0
+#define HAVE_TERMIOS_H 1
+#define HAVE_THREADS 1
+#define HAVE_TRUNC 1
+#define HAVE_TRUNCF 1
+#define HAVE_VFP_ARGS 0
+#define HAVE_VIRTUALALLOC 0
+#define HAVE_WINSOCK2_H 0
+#define HAVE_XFORM_ASM 0
+#define HAVE_XMM_CLOBBERS 0
+#define HAVE_YASM 0
+#define CONFIG_BSFS 1
+#define CONFIG_DECODERS 1
+#define CONFIG_DEMUXERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_FILTERS 1
+#define CONFIG_HWACCELS 0
+#define CONFIG_INDEVS 1
+#define CONFIG_MUXERS 1
+#define CONFIG_OUTDEVS 1
+#define CONFIG_PARSERS 1
+#define CONFIG_PROTOCOLS 1
+#define CONFIG_AANDCT 1
+#define CONFIG_AC3DSP 0
+#define CONFIG_AVCODEC 1
+#define CONFIG_AVDEVICE 1
+#define CONFIG_AVFILTER 1
+#define CONFIG_AVFORMAT 1
+#define CONFIG_AVISYNTH 0
+#define CONFIG_BZLIB 0
+#define CONFIG_CRYSTALHD 0
+#define CONFIG_DCT 1
+#define CONFIG_DOC 0
+#define CONFIG_DWT 1
+#define CONFIG_DXVA2 0
+#define CONFIG_FASTDIV 1
+#define CONFIG_FFMPEG 1
+#define CONFIG_FFPLAY 0
+#define CONFIG_FFPROBE 1
+#define CONFIG_FFSERVER 1
+#define CONFIG_FFT 1
+#define CONFIG_FREI0R 0
+#define CONFIG_GOLOMB 1
+#define CONFIG_GPL 0
+#define CONFIG_GRAY 0
+#define CONFIG_H264DSP 1
+#define CONFIG_H264PRED 1
+#define CONFIG_HARDCODED_TABLES 0
+#define CONFIG_HUFFMAN 1
+#define CONFIG_LIBCELT 0
+#define CONFIG_LIBDC1394 0
+#define CONFIG_LIBDIRAC 0
+#define CONFIG_LIBFAAC 0
+#define CONFIG_LIBFREETYPE 0
+#define CONFIG_LIBGSM 0
+#define CONFIG_LIBMP3LAME 0
+#define CONFIG_LIBNUT 0
+#define CONFIG_LIBOPENCORE_AMRNB 0
+#define CONFIG_LIBOPENCORE_AMRWB 0
+#define CONFIG_LIBOPENCV 0
+#define CONFIG_LIBOPENJPEG 0
+#define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSCHROEDINGER 0
+#define CONFIG_LIBSPEEX 0
+#define CONFIG_LIBTHEORA 0
+#define CONFIG_LIBVO_AACENC 0
+#define CONFIG_LIBVO_AMRWBENC 0
+#define CONFIG_LIBVORBIS 0
+#define CONFIG_LIBVPX 0
+#define CONFIG_LIBX264 0
+#define CONFIG_LIBXAVS 0
+#define CONFIG_LIBXVID 0
+#define CONFIG_LPC 1
+#define CONFIG_LSP 1
+#define CONFIG_MDCT 1
+#define CONFIG_MEMALIGN_HACK 0
+#define CONFIG_MLIB 0
+#define CONFIG_MPEGAUDIODSP 1
+#define CONFIG_NETWORK 1
+#define CONFIG_NONFREE 0
+#define CONFIG_PIC 0
+#define CONFIG_POSTPROC 0
+#define CONFIG_RDFT 1
+#define CONFIG_RTPDEC 1
+#define CONFIG_RUNTIME_CPUDETECT 0
+#define CONFIG_SHARED 0
+#define CONFIG_SINEWIN 1
+#define CONFIG_SMALL 0
+#define CONFIG_SRAM 0
+#define CONFIG_STATIC 1
+#define CONFIG_SWSCALE 1
+#define CONFIG_SWSCALE_ALPHA 1
+#define CONFIG_VAAPI 0
+#define CONFIG_VDPAU 0
+#define CONFIG_VERSION3 0
+#define CONFIG_X11GRAB 0
+#define CONFIG_ZLIB 0
+#define CONFIG_AVUTIL 1
+#define CONFIG_GPLV3 0
+#define CONFIG_LGPLV3 0
+#define CONFIG_AASC_DECODER 1
+#define CONFIG_AMV_DECODER 1
+#define CONFIG_ANM_DECODER 1
+#define CONFIG_ANSI_DECODER 1
+#define CONFIG_ASV1_DECODER 1
+#define CONFIG_ASV2_DECODER 1
+#define CONFIG_AURA_DECODER 1
+#define CONFIG_AURA2_DECODER 1
+#define CONFIG_AVS_DECODER 1
+#define CONFIG_BETHSOFTVID_DECODER 1
+#define CONFIG_BFI_DECODER 1
+#define CONFIG_BINK_DECODER 1
+#define CONFIG_BMP_DECODER 1
+#define CONFIG_C93_DECODER 1
+#define CONFIG_CAVS_DECODER 1
+#define CONFIG_CDGRAPHICS_DECODER 1
+#define CONFIG_CINEPAK_DECODER 1
+#define CONFIG_CLJR_DECODER 1
+#define CONFIG_CSCD_DECODER 1
+#define CONFIG_CYUV_DECODER 1
+#define CONFIG_DFA_DECODER 1
+#define CONFIG_DNXHD_DECODER 1
+#define CONFIG_DPX_DECODER 1
+#define CONFIG_DSICINVIDEO_DECODER 1
+#define CONFIG_DVVIDEO_DECODER 1
+#define CONFIG_DXA_DECODER 0
+#define CONFIG_EACMV_DECODER 1
+#define CONFIG_EAMAD_DECODER 1
+#define CONFIG_EATGQ_DECODER 1
+#define CONFIG_EATGV_DECODER 1
+#define CONFIG_EATQI_DECODER 1
+#define CONFIG_EIGHTBPS_DECODER 1
+#define CONFIG_EIGHTSVX_EXP_DECODER 1
+#define CONFIG_EIGHTSVX_FIB_DECODER 1
+#define CONFIG_EIGHTSVX_RAW_DECODER 1
+#define CONFIG_ESCAPE124_DECODER 1
+#define CONFIG_FFV1_DECODER 1
+#define CONFIG_FFVHUFF_DECODER 1
+#define CONFIG_FLASHSV_DECODER 0
+#define CONFIG_FLIC_DECODER 1
+#define CONFIG_FLV_DECODER 1
+#define CONFIG_FOURXM_DECODER 1
+#define CONFIG_FRAPS_DECODER 1
+#define CONFIG_FRWU_DECODER 1
+#define CONFIG_GIF_DECODER 1
+#define CONFIG_H261_DECODER 1
+#define CONFIG_H263_DECODER 1
+#define CONFIG_H263I_DECODER 1
+#define CONFIG_H264_DECODER 1
+#define CONFIG_H264_CRYSTALHD_DECODER 0
+#define CONFIG_H264_VDPAU_DECODER 0
+#define CONFIG_HUFFYUV_DECODER 1
+#define CONFIG_IDCIN_DECODER 1
+#define CONFIG_IFF_BYTERUN1_DECODER 1
+#define CONFIG_IFF_ILBM_DECODER 1
+#define CONFIG_INDEO2_DECODER 1
+#define CONFIG_INDEO3_DECODER 1
+#define CONFIG_INDEO5_DECODER 1
+#define CONFIG_INTERPLAY_VIDEO_DECODER 1
+#define CONFIG_JPEG2000_DECODER 1
+#define CONFIG_JPEGLS_DECODER 1
+#define CONFIG_JV_DECODER 1
+#define CONFIG_KGV1_DECODER 1
+#define CONFIG_KMVC_DECODER 1
+#define CONFIG_LAGARITH_DECODER 1
+#define CONFIG_LOCO_DECODER 1
+#define CONFIG_MDEC_DECODER 1
+#define CONFIG_MIMIC_DECODER 1
+#define CONFIG_MJPEG_DECODER 1
+#define CONFIG_MJPEGB_DECODER 1
+#define CONFIG_MMVIDEO_DECODER 1
+#define CONFIG_MOTIONPIXELS_DECODER 1
+#define CONFIG_MPEG_XVMC_DECODER 0
+#define CONFIG_MPEG1VIDEO_DECODER 1
+#define CONFIG_MPEG2VIDEO_DECODER 1
+#define CONFIG_MPEG4_DECODER 1
+#define CONFIG_MPEG4_CRYSTALHD_DECODER 0
+#define CONFIG_MPEG4_VDPAU_DECODER 0
+#define CONFIG_MPEGVIDEO_DECODER 1
+#define CONFIG_MPEG_VDPAU_DECODER 0
+#define CONFIG_MPEG1_VDPAU_DECODER 0
+#define CONFIG_MPEG2_CRYSTALHD_DECODER 0
+#define CONFIG_MSMPEG4_CRYSTALHD_DECODER 0
+#define CONFIG_MSMPEG4V1_DECODER 1
+#define CONFIG_MSMPEG4V2_DECODER 1
+#define CONFIG_MSMPEG4V3_DECODER 1
+#define CONFIG_MSRLE_DECODER 1
+#define CONFIG_MSVIDEO1_DECODER 1
+#define CONFIG_MSZH_DECODER 1
+#define CONFIG_MXPEG_DECODER 1
+#define CONFIG_NUV_DECODER 1
+#define CONFIG_PAM_DECODER 1
+#define CONFIG_PBM_DECODER 1
+#define CONFIG_PCX_DECODER 1
+#define CONFIG_PGM_DECODER 1
+#define CONFIG_PGMYUV_DECODER 1
+#define CONFIG_PICTOR_DECODER 1
+#define CONFIG_PNG_DECODER 0
+#define CONFIG_PPM_DECODER 1
+#define CONFIG_PTX_DECODER 1
+#define CONFIG_QDRAW_DECODER 1
+#define CONFIG_QPEG_DECODER 1
+#define CONFIG_QTRLE_DECODER 1
+#define CONFIG_R10K_DECODER 1
+#define CONFIG_R210_DECODER 1
+#define CONFIG_RAWVIDEO_DECODER 1
+#define CONFIG_RL2_DECODER 1
+#define CONFIG_ROQ_DECODER 1
+#define CONFIG_RPZA_DECODER 1
+#define CONFIG_RV10_DECODER 1
+#define CONFIG_RV20_DECODER 1
+#define CONFIG_RV30_DECODER 1
+#define CONFIG_RV40_DECODER 1
+#define CONFIG_S302M_DECODER 1
+#define CONFIG_SGI_DECODER 1
+#define CONFIG_SMACKER_DECODER 1
+#define CONFIG_SMC_DECODER 1
+#define CONFIG_SNOW_DECODER 1
+#define CONFIG_SP5X_DECODER 1
+#define CONFIG_SUNRAST_DECODER 1
+#define CONFIG_SVQ1_DECODER 1
+#define CONFIG_SVQ3_DECODER 1
+#define CONFIG_TARGA_DECODER 1
+#define CONFIG_THEORA_DECODER 1
+#define CONFIG_THP_DECODER 1
+#define CONFIG_TIERTEXSEQVIDEO_DECODER 1
+#define CONFIG_TIFF_DECODER 1
+#define CONFIG_TMV_DECODER 1
+#define CONFIG_TRUEMOTION1_DECODER 1
+#define CONFIG_TRUEMOTION2_DECODER 1
+#define CONFIG_TSCC_DECODER 0
+#define CONFIG_TXD_DECODER 1
+#define CONFIG_ULTI_DECODER 1
+#define CONFIG_V210_DECODER 1
+#define CONFIG_V210X_DECODER 1
+#define CONFIG_VB_DECODER 1
+#define CONFIG_VC1_DECODER 1
+#define CONFIG_VC1_CRYSTALHD_DECODER 0
+#define CONFIG_VC1_VDPAU_DECODER 0
+#define CONFIG_VCR1_DECODER 1
+#define CONFIG_VMDVIDEO_DECODER 1
+#define CONFIG_VMNC_DECODER 1
+#define CONFIG_VP3_DECODER 1
+#define CONFIG_VP5_DECODER 1
+#define CONFIG_VP6_DECODER 1
+#define CONFIG_VP6A_DECODER 1
+#define CONFIG_VP6F_DECODER 1
+#define CONFIG_VP8_DECODER 1
+#define CONFIG_VQA_DECODER 1
+#define CONFIG_WMV1_DECODER 1
+#define CONFIG_WMV2_DECODER 1
+#define CONFIG_WMV3_DECODER 1
+#define CONFIG_WMV3_CRYSTALHD_DECODER 0
+#define CONFIG_WMV3_VDPAU_DECODER 0
+#define CONFIG_WNV1_DECODER 1
+#define CONFIG_XAN_WC3_DECODER 1
+#define CONFIG_XAN_WC4_DECODER 1
+#define CONFIG_XL_DECODER 1
+#define CONFIG_YOP_DECODER 1
+#define CONFIG_ZLIB_DECODER 0
+#define CONFIG_ZMBV_DECODER 0
+#define CONFIG_AAC_DECODER 1
+#define CONFIG_AAC_LATM_DECODER 1
+#define CONFIG_AC3_DECODER 0
+#define CONFIG_ALAC_DECODER 1
+#define CONFIG_ALS_DECODER 1
+#define CONFIG_AMRNB_DECODER 1
+#define CONFIG_AMRWB_DECODER 1
+#define CONFIG_APE_DECODER 1
+#define CONFIG_ATRAC1_DECODER 1
+#define CONFIG_ATRAC3_DECODER 1
+#define CONFIG_BINKAUDIO_DCT_DECODER 1
+#define CONFIG_BINKAUDIO_RDFT_DECODER 1
+#define CONFIG_COOK_DECODER 1
+#define CONFIG_DCA_DECODER 1
+#define CONFIG_DSICINAUDIO_DECODER 1
+#define CONFIG_EAC3_DECODER 0
+#define CONFIG_FLAC_DECODER 1
+#define CONFIG_GSM_DECODER 1
+#define CONFIG_GSM_MS_DECODER 1
+#define CONFIG_IMC_DECODER 1
+#define CONFIG_MACE3_DECODER 1
+#define CONFIG_MACE6_DECODER 1
+#define CONFIG_MLP_DECODER 0
+#define CONFIG_MP1_DECODER 1
+#define CONFIG_MP1FLOAT_DECODER 1
+#define CONFIG_MP2_DECODER 1
+#define CONFIG_MP2FLOAT_DECODER 1
+#define CONFIG_MP3_DECODER 1
+#define CONFIG_MP3FLOAT_DECODER 1
+#define CONFIG_MP3ADU_DECODER 1
+#define CONFIG_MP3ADUFLOAT_DECODER 1
+#define CONFIG_MP3ON4_DECODER 1
+#define CONFIG_MP3ON4FLOAT_DECODER 1
+#define CONFIG_MPC7_DECODER 1
+#define CONFIG_MPC8_DECODER 1
+#define CONFIG_NELLYMOSER_DECODER 1
+#define CONFIG_QCELP_DECODER 1
+#define CONFIG_QDM2_DECODER 1
+#define CONFIG_RA_144_DECODER 1
+#define CONFIG_RA_288_DECODER 1
+#define CONFIG_SHORTEN_DECODER 1
+#define CONFIG_SIPR_DECODER 1
+#define CONFIG_SMACKAUD_DECODER 1
+#define CONFIG_SONIC_DECODER 1
+#define CONFIG_TRUEHD_DECODER 1
+#define CONFIG_TRUESPEECH_DECODER 1
+#define CONFIG_TTA_DECODER 1
+#define CONFIG_TWINVQ_DECODER 1
+#define CONFIG_VMDAUDIO_DECODER 1
+#define CONFIG_VORBIS_DECODER 1
+#define CONFIG_WAVPACK_DECODER 1
+#define CONFIG_WMAPRO_DECODER 1
+#define CONFIG_WMAV1_DECODER 1
+#define CONFIG_WMAV2_DECODER 1
+#define CONFIG_WMAVOICE_DECODER 1
+#define CONFIG_WS_SND1_DECODER 1
+#define CONFIG_PCM_ALAW_DECODER 1
+#define CONFIG_PCM_BLURAY_DECODER 1
+#define CONFIG_PCM_DVD_DECODER 1
+#define CONFIG_PCM_F32BE_DECODER 1
+#define CONFIG_PCM_F32LE_DECODER 1
+#define CONFIG_PCM_F64BE_DECODER 1
+#define CONFIG_PCM_F64LE_DECODER 1
+#define CONFIG_PCM_LXF_DECODER 1
+#define CONFIG_PCM_MULAW_DECODER 1
+#define CONFIG_PCM_S8_DECODER 1
+#define CONFIG_PCM_S16BE_DECODER 1
+#define CONFIG_PCM_S16LE_DECODER 1
+#define CONFIG_PCM_S16LE_PLANAR_DECODER 1
+#define CONFIG_PCM_S24BE_DECODER 1
+#define CONFIG_PCM_S24DAUD_DECODER 1
+#define CONFIG_PCM_S24LE_DECODER 1
+#define CONFIG_PCM_S32BE_DECODER 1
+#define CONFIG_PCM_S32LE_DECODER 1
+#define CONFIG_PCM_U8_DECODER 1
+#define CONFIG_PCM_U16BE_DECODER 1
+#define CONFIG_PCM_U16LE_DECODER 1
+#define CONFIG_PCM_U24BE_DECODER 1
+#define CONFIG_PCM_U24LE_DECODER 1
+#define CONFIG_PCM_U32BE_DECODER 1
+#define CONFIG_PCM_U32LE_DECODER 1
+#define CONFIG_PCM_ZORK_DECODER 1
+#define CONFIG_INTERPLAY_DPCM_DECODER 1
+#define CONFIG_ROQ_DPCM_DECODER 1
+#define CONFIG_SOL_DPCM_DECODER 1
+#define CONFIG_XAN_DPCM_DECODER 1
+#define CONFIG_ADPCM_4XM_DECODER 1
+#define CONFIG_ADPCM_ADX_DECODER 1
+#define CONFIG_ADPCM_CT_DECODER 1
+#define CONFIG_ADPCM_EA_DECODER 1
+#define CONFIG_ADPCM_EA_MAXIS_XA_DECODER 1
+#define CONFIG_ADPCM_EA_R1_DECODER 1
+#define CONFIG_ADPCM_EA_R2_DECODER 1
+#define CONFIG_ADPCM_EA_R3_DECODER 1
+#define CONFIG_ADPCM_EA_XAS_DECODER 1
+#define CONFIG_ADPCM_G722_DECODER 1
+#define CONFIG_ADPCM_G726_DECODER 1
+#define CONFIG_ADPCM_IMA_AMV_DECODER 1
+#define CONFIG_ADPCM_IMA_DK3_DECODER 1
+#define CONFIG_ADPCM_IMA_DK4_DECODER 1
+#define CONFIG_ADPCM_IMA_EA_EACS_DECODER 1
+#define CONFIG_ADPCM_IMA_EA_SEAD_DECODER 1
+#define CONFIG_ADPCM_IMA_ISS_DECODER 1
+#define CONFIG_ADPCM_IMA_QT_DECODER 1
+#define CONFIG_ADPCM_IMA_SMJPEG_DECODER 1
+#define CONFIG_ADPCM_IMA_WAV_DECODER 1
+#define CONFIG_ADPCM_IMA_WS_DECODER 1
+#define CONFIG_ADPCM_MS_DECODER 1
+#define CONFIG_ADPCM_SBPRO_2_DECODER 1
+#define CONFIG_ADPCM_SBPRO_3_DECODER 1
+#define CONFIG_ADPCM_SBPRO_4_DECODER 1
+#define CONFIG_ADPCM_SWF_DECODER 1
+#define CONFIG_ADPCM_THP_DECODER 1
+#define CONFIG_ADPCM_XA_DECODER 1
+#define CONFIG_ADPCM_YAMAHA_DECODER 1
+#define CONFIG_ASS_DECODER 1
+#define CONFIG_DVBSUB_DECODER 1
+#define CONFIG_DVDSUB_DECODER 1
+#define CONFIG_PGSSUB_DECODER 1
+#define CONFIG_SRT_DECODER 1
+#define CONFIG_XSUB_DECODER 1
+#define CONFIG_LIBCELT_DECODER 0
+#define CONFIG_LIBDIRAC_DECODER 0
+#define CONFIG_LIBGSM_DECODER 0
+#define CONFIG_LIBGSM_MS_DECODER 0
+#define CONFIG_LIBOPENCORE_AMRNB_DECODER 0
+#define CONFIG_LIBOPENCORE_AMRWB_DECODER 0
+#define CONFIG_LIBOPENJPEG_DECODER 0
+#define CONFIG_LIBSCHROEDINGER_DECODER 0
+#define CONFIG_LIBSPEEX_DECODER 0
+#define CONFIG_LIBVPX_DECODER 0
+#define CONFIG_A64MULTI_ENCODER 0
+#define CONFIG_A64MULTI5_ENCODER 0
+#define CONFIG_ASV1_ENCODER 0
+#define CONFIG_ASV2_ENCODER 0
+#define CONFIG_BMP_ENCODER 0
+#define CONFIG_DNXHD_ENCODER 0
+#define CONFIG_DPX_ENCODER 0
+#define CONFIG_DVVIDEO_ENCODER 0
+#define CONFIG_FFV1_ENCODER 0
+#define CONFIG_FFVHUFF_ENCODER 0
+#define CONFIG_FLASHSV_ENCODER 0
+#define CONFIG_FLASHSV2_ENCODER 0
+#define CONFIG_FLV_ENCODER 0
+#define CONFIG_GIF_ENCODER 0
+#define CONFIG_H261_ENCODER 0
+#define CONFIG_H263_ENCODER 0
+#define CONFIG_H263P_ENCODER 0
+#define CONFIG_HUFFYUV_ENCODER 0
+#define CONFIG_JPEGLS_ENCODER 0
+#define CONFIG_LJPEG_ENCODER 0
+#define CONFIG_MJPEG_ENCODER 0
+#define CONFIG_MPEG1VIDEO_ENCODER 0
+#define CONFIG_MPEG2VIDEO_ENCODER 0
+#define CONFIG_MPEG4_ENCODER 0
+#define CONFIG_MSMPEG4V2_ENCODER 0
+#define CONFIG_MSMPEG4V3_ENCODER 0
+#define CONFIG_MSVIDEO1_ENCODER 0
+#define CONFIG_PAM_ENCODER 0
+#define CONFIG_PBM_ENCODER 0
+#define CONFIG_PCX_ENCODER 0
+#define CONFIG_PGM_ENCODER 0
+#define CONFIG_PGMYUV_ENCODER 0
+#define CONFIG_PNG_ENCODER 0
+#define CONFIG_PPM_ENCODER 0
+#define CONFIG_QTRLE_ENCODER 0
+#define CONFIG_RAWVIDEO_ENCODER 0
+#define CONFIG_ROQ_ENCODER 0
+#define CONFIG_RV10_ENCODER 0
+#define CONFIG_RV20_ENCODER 0
+#define CONFIG_SGI_ENCODER 0
+#define CONFIG_SNOW_ENCODER 0
+#define CONFIG_SVQ1_ENCODER 0
+#define CONFIG_TARGA_ENCODER 0
+#define CONFIG_TIFF_ENCODER 0
+#define CONFIG_V210_ENCODER 0
+#define CONFIG_WMV1_ENCODER 0
+#define CONFIG_WMV2_ENCODER 0
+#define CONFIG_ZLIB_ENCODER 0
+#define CONFIG_ZMBV_ENCODER 0
+#define CONFIG_AAC_ENCODER 0
+#define CONFIG_AC3_ENCODER 0
+#define CONFIG_AC3_FIXED_ENCODER 0
+#define CONFIG_AC3_FLOAT_ENCODER 0
+#define CONFIG_ALAC_ENCODER 0
+#define CONFIG_DCA_ENCODER 0
+#define CONFIG_EAC3_ENCODER 0
+#define CONFIG_FLAC_ENCODER 0
+#define CONFIG_MP2_ENCODER 0
+#define CONFIG_NELLYMOSER_ENCODER 0
+#define CONFIG_RA_144_ENCODER 0
+#define CONFIG_SONIC_ENCODER 0
+#define CONFIG_SONIC_LS_ENCODER 0
+#define CONFIG_VORBIS_ENCODER 0
+#define CONFIG_WMAV1_ENCODER 0
+#define CONFIG_WMAV2_ENCODER 0
+#define CONFIG_PCM_ALAW_ENCODER 0
+#define CONFIG_PCM_F32BE_ENCODER 0
+#define CONFIG_PCM_F32LE_ENCODER 0
+#define CONFIG_PCM_F64BE_ENCODER 0
+#define CONFIG_PCM_F64LE_ENCODER 0
+#define CONFIG_PCM_MULAW_ENCODER 0
+#define CONFIG_PCM_S8_ENCODER 0
+#define CONFIG_PCM_S16BE_ENCODER 0
+#define CONFIG_PCM_S16LE_ENCODER 0
+#define CONFIG_PCM_S24BE_ENCODER 0
+#define CONFIG_PCM_S24DAUD_ENCODER 0
+#define CONFIG_PCM_S24LE_ENCODER 0
+#define CONFIG_PCM_S32BE_ENCODER 0
+#define CONFIG_PCM_S32LE_ENCODER 0
+#define CONFIG_PCM_U8_ENCODER 0
+#define CONFIG_PCM_U16BE_ENCODER 0
+#define CONFIG_PCM_U16LE_ENCODER 0
+#define CONFIG_PCM_U24BE_ENCODER 0
+#define CONFIG_PCM_U24LE_ENCODER 0
+#define CONFIG_PCM_U32BE_ENCODER 0
+#define CONFIG_PCM_U32LE_ENCODER 0
+#define CONFIG_PCM_ZORK_ENCODER 0
+#define CONFIG_ROQ_DPCM_ENCODER 0
+#define CONFIG_ADPCM_ADX_ENCODER 0
+#define CONFIG_ADPCM_G722_ENCODER 0
+#define CONFIG_ADPCM_G726_ENCODER 0
+#define CONFIG_ADPCM_IMA_QT_ENCODER 0
+#define CONFIG_ADPCM_IMA_WAV_ENCODER 0
+#define CONFIG_ADPCM_MS_ENCODER 0
+#define CONFIG_ADPCM_SWF_ENCODER 0
+#define CONFIG_ADPCM_YAMAHA_ENCODER 0
+#define CONFIG_ASS_ENCODER 0
+#define CONFIG_DVBSUB_ENCODER 0
+#define CONFIG_DVDSUB_ENCODER 0
+#define CONFIG_SRT_ENCODER 0
+#define CONFIG_XSUB_ENCODER 0
+#define CONFIG_LIBDIRAC_ENCODER 0
+#define CONFIG_LIBFAAC_ENCODER 0
+#define CONFIG_LIBGSM_ENCODER 0
+#define CONFIG_LIBGSM_MS_ENCODER 0
+#define CONFIG_LIBMP3LAME_ENCODER 0
+#define CONFIG_LIBOPENCORE_AMRNB_ENCODER 0
+#define CONFIG_LIBSCHROEDINGER_ENCODER 0
+#define CONFIG_LIBTHEORA_ENCODER 0
+#define CONFIG_LIBVO_AACENC_ENCODER 0
+#define CONFIG_LIBVO_AMRWBENC_ENCODER 0
+#define CONFIG_LIBVORBIS_ENCODER 0
+#define CONFIG_LIBVPX_ENCODER 0
+#define CONFIG_LIBX264_ENCODER 0
+#define CONFIG_LIBXAVS_ENCODER 0
+#define CONFIG_LIBXVID_ENCODER 0
+#define CONFIG_H263_VAAPI_HWACCEL 0
+#define CONFIG_H264_DXVA2_HWACCEL 0
+#define CONFIG_H264_VAAPI_HWACCEL 0
+#define CONFIG_MPEG1_VDPAU_HWACCEL 0
+#define CONFIG_MPEG2_DXVA2_HWACCEL 0
+#define CONFIG_MPEG2_VAAPI_HWACCEL 0
+#define CONFIG_MPEG2_VDPAU_HWACCEL 0
+#define CONFIG_MPEG4_VAAPI_HWACCEL 0
+#define CONFIG_VC1_DXVA2_HWACCEL 0
+#define CONFIG_VC1_VAAPI_HWACCEL 0
+#define CONFIG_WMV3_DXVA2_HWACCEL 0
+#define CONFIG_WMV3_VAAPI_HWACCEL 0
+#define CONFIG_AAC_PARSER 1
+#define CONFIG_AAC_LATM_PARSER 1
+#define CONFIG_AC3_PARSER 1
+#define CONFIG_CAVSVIDEO_PARSER 1
+#define CONFIG_DCA_PARSER 1
+#define CONFIG_DIRAC_PARSER 1
+#define CONFIG_DNXHD_PARSER 1
+#define CONFIG_DVBSUB_PARSER 1
+#define CONFIG_DVDSUB_PARSER 1
+#define CONFIG_FLAC_PARSER 1
+#define CONFIG_H261_PARSER 1
+#define CONFIG_H263_PARSER 1
+#define CONFIG_H264_PARSER 1
+#define CONFIG_MJPEG_PARSER 1
+#define CONFIG_MLP_PARSER 1
+#define CONFIG_MPEG4VIDEO_PARSER 1
+#define CONFIG_MPEGAUDIO_PARSER 1
+#define CONFIG_MPEGVIDEO_PARSER 1
+#define CONFIG_PNM_PARSER 1
+#define CONFIG_VC1_PARSER 1
+#define CONFIG_VP3_PARSER 1
+#define CONFIG_VP8_PARSER 1
+#define CONFIG_AAC_ADTSTOASC_BSF 1
+#define CONFIG_CHOMP_BSF 1
+#define CONFIG_DUMP_EXTRADATA_BSF 1
+#define CONFIG_H264_MP4TOANNEXB_BSF 1
+#define CONFIG_IMX_DUMP_HEADER_BSF 1
+#define CONFIG_MJPEG2JPEG_BSF 1
+#define CONFIG_MJPEGA_DUMP_HEADER_BSF 1
+#define CONFIG_MP3_HEADER_COMPRESS_BSF 1
+#define CONFIG_MP3_HEADER_DECOMPRESS_BSF 1
+#define CONFIG_MOV2TEXTSUB_BSF 1
+#define CONFIG_NOISE_BSF 1
+#define CONFIG_REMOVE_EXTRADATA_BSF 1
+#define CONFIG_TEXT2MOVSUB_BSF 1
+#define CONFIG_AAC_DEMUXER 1
+#define CONFIG_AC3_DEMUXER 1
+#define CONFIG_AEA_DEMUXER 1
+#define CONFIG_AIFF_DEMUXER 1
+#define CONFIG_AMR_DEMUXER 1
+#define CONFIG_ANM_DEMUXER 1
+#define CONFIG_APC_DEMUXER 1
+#define CONFIG_APE_DEMUXER 1
+#define CONFIG_APPLEHTTP_DEMUXER 1
+#define CONFIG_ASF_DEMUXER 1
+#define CONFIG_ASS_DEMUXER 1
+#define CONFIG_AU_DEMUXER 1
+#define CONFIG_AVI_DEMUXER 1
+#define CONFIG_AVISYNTH_DEMUXER 0
+#define CONFIG_AVS_DEMUXER 1
+#define CONFIG_BETHSOFTVID_DEMUXER 1
+#define CONFIG_BFI_DEMUXER 1
+#define CONFIG_BINK_DEMUXER 1
+#define CONFIG_C93_DEMUXER 1
+#define CONFIG_CAF_DEMUXER 1
+#define CONFIG_CAVSVIDEO_DEMUXER 1
+#define CONFIG_CDG_DEMUXER 1
+#define CONFIG_DAUD_DEMUXER 1
+#define CONFIG_DFA_DEMUXER 1
+#define CONFIG_DIRAC_DEMUXER 1
+#define CONFIG_DNXHD_DEMUXER 1
+#define CONFIG_DSICIN_DEMUXER 1
+#define CONFIG_DTS_DEMUXER 1
+#define CONFIG_DV_DEMUXER 1
+#define CONFIG_DXA_DEMUXER 1
+#define CONFIG_EA_DEMUXER 1
+#define CONFIG_EA_CDATA_DEMUXER 1
+#define CONFIG_EAC3_DEMUXER 1
+#define CONFIG_FFM_DEMUXER 1
+#define CONFIG_FFMETADATA_DEMUXER 1
+#define CONFIG_FILMSTRIP_DEMUXER 1
+#define CONFIG_FLAC_DEMUXER 1
+#define CONFIG_FLIC_DEMUXER 1
+#define CONFIG_FLV_DEMUXER 1
+#define CONFIG_FOURXM_DEMUXER 1
+#define CONFIG_G722_DEMUXER 1
+#define CONFIG_GSM_DEMUXER 1
+#define CONFIG_GXF_DEMUXER 1
+#define CONFIG_H261_DEMUXER 1
+#define CONFIG_H263_DEMUXER 1
+#define CONFIG_H264_DEMUXER 1
+#define CONFIG_IDCIN_DEMUXER 1
+#define CONFIG_IFF_DEMUXER 1
+#define CONFIG_IMAGE2_DEMUXER 1
+#define CONFIG_IMAGE2PIPE_DEMUXER 1
+#define CONFIG_INGENIENT_DEMUXER 1
+#define CONFIG_IPMOVIE_DEMUXER 1
+#define CONFIG_ISS_DEMUXER 1
+#define CONFIG_IV8_DEMUXER 1
+#define CONFIG_IVF_DEMUXER 1
+#define CONFIG_JV_DEMUXER 1
+#define CONFIG_LMLM4_DEMUXER 1
+#define CONFIG_LXF_DEMUXER 1
+#define CONFIG_M4V_DEMUXER 1
+#define CONFIG_MATROSKA_DEMUXER 1
+#define CONFIG_MICRODVD_DEMUXER 1
+#define CONFIG_MJPEG_DEMUXER 1
+#define CONFIG_MLP_DEMUXER 1
+#define CONFIG_MM_DEMUXER 1
+#define CONFIG_MMF_DEMUXER 1
+#define CONFIG_MOV_DEMUXER 1
+#define CONFIG_MP3_DEMUXER 1
+#define CONFIG_MPC_DEMUXER 1
+#define CONFIG_MPC8_DEMUXER 1
+#define CONFIG_MPEGPS_DEMUXER 1
+#define CONFIG_MPEGTS_DEMUXER 1
+#define CONFIG_MPEGTSRAW_DEMUXER 1
+#define CONFIG_MPEGVIDEO_DEMUXER 1
+#define CONFIG_MSNWC_TCP_DEMUXER 1
+#define CONFIG_MTV_DEMUXER 1
+#define CONFIG_MVI_DEMUXER 1
+#define CONFIG_MXF_DEMUXER 1
+#define CONFIG_MXG_DEMUXER 1
+#define CONFIG_NC_DEMUXER 1
+#define CONFIG_NSV_DEMUXER 1
+#define CONFIG_NUT_DEMUXER 1
+#define CONFIG_NUV_DEMUXER 1
+#define CONFIG_OGG_DEMUXER 1
+#define CONFIG_OMA_DEMUXER 1
+#define CONFIG_PCM_ALAW_DEMUXER 1
+#define CONFIG_PCM_MULAW_DEMUXER 1
+#define CONFIG_PCM_F64BE_DEMUXER 1
+#define CONFIG_PCM_F64LE_DEMUXER 1
+#define CONFIG_PCM_F32BE_DEMUXER 1
+#define CONFIG_PCM_F32LE_DEMUXER 1
+#define CONFIG_PCM_S32BE_DEMUXER 1
+#define CONFIG_PCM_S32LE_DEMUXER 1
+#define CONFIG_PCM_S24BE_DEMUXER 1
+#define CONFIG_PCM_S24LE_DEMUXER 1
+#define CONFIG_PCM_S16BE_DEMUXER 1
+#define CONFIG_PCM_S16LE_DEMUXER 1
+#define CONFIG_PCM_S8_DEMUXER 1
+#define CONFIG_PCM_U32BE_DEMUXER 1
+#define CONFIG_PCM_U32LE_DEMUXER 1
+#define CONFIG_PCM_U24BE_DEMUXER 1
+#define CONFIG_PCM_U24LE_DEMUXER 1
+#define CONFIG_PCM_U16BE_DEMUXER 1
+#define CONFIG_PCM_U16LE_DEMUXER 1
+#define CONFIG_PCM_U8_DEMUXER 1
+#define CONFIG_PMP_DEMUXER 1
+#define CONFIG_PVA_DEMUXER 1
+#define CONFIG_QCP_DEMUXER 1
+#define CONFIG_R3D_DEMUXER 1
+#define CONFIG_RAWVIDEO_DEMUXER 1
+#define CONFIG_RL2_DEMUXER 1
+#define CONFIG_RM_DEMUXER 1
+#define CONFIG_ROQ_DEMUXER 1
+#define CONFIG_RPL_DEMUXER 1
+#define CONFIG_RSO_DEMUXER 1
+#define CONFIG_RTP_DEMUXER 1
+#define CONFIG_RTSP_DEMUXER 1
+#define CONFIG_SAP_DEMUXER 1
+#define CONFIG_SDP_DEMUXER 1
+#define CONFIG_SEGAFILM_DEMUXER 1
+#define CONFIG_SHORTEN_DEMUXER 1
+#define CONFIG_SIFF_DEMUXER 1
+#define CONFIG_SMACKER_DEMUXER 1
+#define CONFIG_SOL_DEMUXER 1
+#define CONFIG_SOX_DEMUXER 1
+#define CONFIG_SPDIF_DEMUXER 1
+#define CONFIG_SRT_DEMUXER 1
+#define CONFIG_STR_DEMUXER 1
+#define CONFIG_SWF_DEMUXER 1
+#define CONFIG_THP_DEMUXER 1
+#define CONFIG_TIERTEXSEQ_DEMUXER 1
+#define CONFIG_TMV_DEMUXER 1
+#define CONFIG_TRUEHD_DEMUXER 1
+#define CONFIG_TTA_DEMUXER 1
+#define CONFIG_TXD_DEMUXER 1
+#define CONFIG_TTY_DEMUXER 1
+#define CONFIG_VC1_DEMUXER 1
+#define CONFIG_VC1T_DEMUXER 1
+#define CONFIG_VMD_DEMUXER 1
+#define CONFIG_VOC_DEMUXER 1
+#define CONFIG_VQF_DEMUXER 1
+#define CONFIG_W64_DEMUXER 1
+#define CONFIG_WAV_DEMUXER 1
+#define CONFIG_WC3_DEMUXER 1
+#define CONFIG_WSAUD_DEMUXER 1
+#define CONFIG_WSVQA_DEMUXER 1
+#define CONFIG_WTV_DEMUXER 1
+#define CONFIG_WV_DEMUXER 1
+#define CONFIG_XA_DEMUXER 1
+#define CONFIG_XWMA_DEMUXER 1
+#define CONFIG_YOP_DEMUXER 1
+#define CONFIG_YUV4MPEGPIPE_DEMUXER 1
+#define CONFIG_LIBNUT_DEMUXER 0
+#define CONFIG_A64_MUXER 1
+#define CONFIG_AC3_MUXER 1
+#define CONFIG_ADTS_MUXER 1
+#define CONFIG_AIFF_MUXER 1
+#define CONFIG_AMR_MUXER 1
+#define CONFIG_ASF_MUXER 1
+#define CONFIG_ASS_MUXER 1
+#define CONFIG_ASF_STREAM_MUXER 1
+#define CONFIG_AU_MUXER 1
+#define CONFIG_AVI_MUXER 1
+#define CONFIG_AVM2_MUXER 1
+#define CONFIG_CAF_MUXER 1
+#define CONFIG_CAVSVIDEO_MUXER 1
+#define CONFIG_CRC_MUXER 1
+#define CONFIG_DAUD_MUXER 1
+#define CONFIG_DIRAC_MUXER 1
+#define CONFIG_DNXHD_MUXER 1
+#define CONFIG_DTS_MUXER 1
+#define CONFIG_DV_MUXER 1
+#define CONFIG_EAC3_MUXER 1
+#define CONFIG_FFM_MUXER 1
+#define CONFIG_FFMETADATA_MUXER 1
+#define CONFIG_FILMSTRIP_MUXER 1
+#define CONFIG_FLAC_MUXER 1
+#define CONFIG_FLV_MUXER 1
+#define CONFIG_FRAMECRC_MUXER 1
+#define CONFIG_FRAMEMD5_MUXER 1
+#define CONFIG_G722_MUXER 1
+#define CONFIG_GIF_MUXER 1
+#define CONFIG_GXF_MUXER 1
+#define CONFIG_H261_MUXER 1
+#define CONFIG_H263_MUXER 1
+#define CONFIG_H264_MUXER 1
+#define CONFIG_IMAGE2_MUXER 1
+#define CONFIG_IMAGE2PIPE_MUXER 1
+#define CONFIG_IPOD_MUXER 1
+#define CONFIG_IVF_MUXER 1
+#define CONFIG_M4V_MUXER 1
+#define CONFIG_MD5_MUXER 1
+#define CONFIG_MATROSKA_MUXER 1
+#define CONFIG_MATROSKA_AUDIO_MUXER 1
+#define CONFIG_MICRODVD_MUXER 1
+#define CONFIG_MJPEG_MUXER 1
+#define CONFIG_MLP_MUXER 1
+#define CONFIG_MMF_MUXER 1
+#define CONFIG_MOV_MUXER 1
+#define CONFIG_MP2_MUXER 1
+#define CONFIG_MP3_MUXER 1
+#define CONFIG_MP4_MUXER 1
+#define CONFIG_MPEG1SYSTEM_MUXER 1
+#define CONFIG_MPEG1VCD_MUXER 1
+#define CONFIG_MPEG1VIDEO_MUXER 1
+#define CONFIG_MPEG2DVD_MUXER 1
+#define CONFIG_MPEG2SVCD_MUXER 1
+#define CONFIG_MPEG2VIDEO_MUXER 1
+#define CONFIG_MPEG2VOB_MUXER 1
+#define CONFIG_MPEGTS_MUXER 1
+#define CONFIG_MPJPEG_MUXER 1
+#define CONFIG_MXF_MUXER 1
+#define CONFIG_MXF_D10_MUXER 1
+#define CONFIG_NULL_MUXER 1
+#define CONFIG_NUT_MUXER 1
+#define CONFIG_OGG_MUXER 1
+#define CONFIG_PCM_ALAW_MUXER 1
+#define CONFIG_PCM_MULAW_MUXER 1
+#define CONFIG_PCM_F64BE_MUXER 1
+#define CONFIG_PCM_F64LE_MUXER 1
+#define CONFIG_PCM_F32BE_MUXER 1
+#define CONFIG_PCM_F32LE_MUXER 1
+#define CONFIG_PCM_S32BE_MUXER 1
+#define CONFIG_PCM_S32LE_MUXER 1
+#define CONFIG_PCM_S24BE_MUXER 1
+#define CONFIG_PCM_S24LE_MUXER 1
+#define CONFIG_PCM_S16BE_MUXER 1
+#define CONFIG_PCM_S16LE_MUXER 1
+#define CONFIG_PCM_S8_MUXER 1
+#define CONFIG_PCM_U32BE_MUXER 1
+#define CONFIG_PCM_U32LE_MUXER 1
+#define CONFIG_PCM_U24BE_MUXER 1
+#define CONFIG_PCM_U24LE_MUXER 1
+#define CONFIG_PCM_U16BE_MUXER 1
+#define CONFIG_PCM_U16LE_MUXER 1
+#define CONFIG_PCM_U8_MUXER 1
+#define CONFIG_PSP_MUXER 1
+#define CONFIG_RAWVIDEO_MUXER 1
+#define CONFIG_RM_MUXER 1
+#define CONFIG_ROQ_MUXER 1
+#define CONFIG_RSO_MUXER 1
+#define CONFIG_RTP_MUXER 1
+#define CONFIG_RTSP_MUXER 1
+#define CONFIG_SAP_MUXER 1
+#define CONFIG_SOX_MUXER 1
+#define CONFIG_SPDIF_MUXER 1
+#define CONFIG_SRT_MUXER 1
+#define CONFIG_SWF_MUXER 1
+#define CONFIG_TG2_MUXER 1
+#define CONFIG_TGP_MUXER 1
+#define CONFIG_TRUEHD_MUXER 1
+#define CONFIG_VC1T_MUXER 1
+#define CONFIG_VOC_MUXER 1
+#define CONFIG_WAV_MUXER 1
+#define CONFIG_WEBM_MUXER 1
+#define CONFIG_YUV4MPEGPIPE_MUXER 1
+#define CONFIG_LIBNUT_MUXER 0
+#define CONFIG_ANULL_FILTER 1
+#define CONFIG_ANULLSRC_FILTER 1
+#define CONFIG_ANULLSINK_FILTER 1
+#define CONFIG_BLACKFRAME_FILTER 0
+#define CONFIG_COPY_FILTER 1
+#define CONFIG_CROP_FILTER 1
+#define CONFIG_CROPDETECT_FILTER 0
+#define CONFIG_DRAWBOX_FILTER 1
+#define CONFIG_DRAWTEXT_FILTER 0
+#define CONFIG_FADE_FILTER 1
+#define CONFIG_FIELDORDER_FILTER 1
+#define CONFIG_FIFO_FILTER 1
+#define CONFIG_FORMAT_FILTER 1
+#define CONFIG_FREI0R_FILTER 0
+#define CONFIG_GRADFUN_FILTER 1
+#define CONFIG_HFLIP_FILTER 1
+#define CONFIG_HQDN3D_FILTER 0
+#define CONFIG_LUT_FILTER 1
+#define CONFIG_LUTRGB_FILTER 1
+#define CONFIG_LUTYUV_FILTER 1
+#define CONFIG_MP_FILTER 0
+#define CONFIG_NEGATE_FILTER 1
+#define CONFIG_NOFORMAT_FILTER 1
+#define CONFIG_NULL_FILTER 1
+#define CONFIG_OCV_FILTER 0
+#define CONFIG_OVERLAY_FILTER 1
+#define CONFIG_PAD_FILTER 1
+#define CONFIG_PIXDESCTEST_FILTER 1
+#define CONFIG_SCALE_FILTER 1
+#define CONFIG_SELECT_FILTER 1
+#define CONFIG_SETDAR_FILTER 1
+#define CONFIG_SETPTS_FILTER 1
+#define CONFIG_SETSAR_FILTER 1
+#define CONFIG_SETTB_FILTER 1
+#define CONFIG_SHOWINFO_FILTER 1
+#define CONFIG_SLICIFY_FILTER 1
+#define CONFIG_SPLIT_FILTER 1
+#define CONFIG_TRANSPOSE_FILTER 1
+#define CONFIG_UNSHARP_FILTER 1
+#define CONFIG_VFLIP_FILTER 1
+#define CONFIG_YADIF_FILTER 0
+#define CONFIG_BUFFER_FILTER 1
+#define CONFIG_COLOR_FILTER 1
+#define CONFIG_FREI0R_SRC_FILTER 0
+#define CONFIG_MOVIE_FILTER 1
+#define CONFIG_NULLSRC_FILTER 1
+#define CONFIG_BUFFERSINK_FILTER 1
+#define CONFIG_NULLSINK_FILTER 1
+#define CONFIG_APPLEHTTP_PROTOCOL 1
+#define CONFIG_CONCAT_PROTOCOL 1
+#define CONFIG_CRYPTO_PROTOCOL 1
+#define CONFIG_FILE_PROTOCOL 1
+#define CONFIG_GOPHER_PROTOCOL 1
+#define CONFIG_HTTP_PROTOCOL 1
+#define CONFIG_MMSH_PROTOCOL 1
+#define CONFIG_MMST_PROTOCOL 1
+#define CONFIG_MD5_PROTOCOL 1
+#define CONFIG_PIPE_PROTOCOL 1
+#define CONFIG_RTMP_PROTOCOL 1
+#define CONFIG_RTMPT_PROTOCOL 1
+#define CONFIG_RTMPE_PROTOCOL 1
+#define CONFIG_RTMPTE_PROTOCOL 1
+#define CONFIG_RTMPS_PROTOCOL 1
+#define CONFIG_RTP_PROTOCOL 1
+#define CONFIG_TCP_PROTOCOL 1
+#define CONFIG_UDP_PROTOCOL 1
+#define CONFIG_ALSA_INDEV 0
+#define CONFIG_BKTR_INDEV 0
+#define CONFIG_DSHOW_INDEV 0
+#define CONFIG_DV1394_INDEV 1
+#define CONFIG_FBDEV_INDEV 1
+#define CONFIG_JACK_INDEV 0
+#define CONFIG_OSS_INDEV 1
+#define CONFIG_SNDIO_INDEV 0
+#define CONFIG_V4L2_INDEV 1
+#define CONFIG_V4L_INDEV 1
+#define CONFIG_VFWCAP_INDEV 0
+#define CONFIG_X11_GRAB_DEVICE_INDEV 0
+#define CONFIG_LIBDC1394_INDEV 0
+#define CONFIG_ALSA_OUTDEV 0
+#define CONFIG_OSS_OUTDEV 1
+#define CONFIG_SDL_OUTDEV 0
+#define CONFIG_SNDIO_OUTDEV 0
+#endif /* FFMPEG_CONFIG_H */
diff --git a/amffmpeg/config.log b/amffmpeg/config.log
new file mode 100644
index 0000000..06fbf04
--- /dev/null
+++ b/amffmpeg/config.log
@@ -0,0 +1,5063 @@
+# ./configure --disable-yasm --disable-ffplay --cross-prefix=arm-none-linux-gnueabi- --enable-cross-compile --target-os=linux --arch=arm
+ACODEC_TESTS='ac3_fixed_test
+adpcm_ima_qt_test
+adpcm_ima_wav_test
+adpcm_ms_test
+adpcm_swf_test
+adpcm_yam_test
+alac_test
+aref_test
+flac_test
+g726_test
+mp2_test
+pcm_test
+wmav1_test
+wmav2_test'
+ANDROID_BUILD_PATHS=':/nishome/zhouzhi/android/android_rootfs_ref/out/host/linux-x86/bin:/nishome/zhouzhi/android/android_rootfs_ref/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin:/nishome/zhouzhi/android/android_rootfs_ref/development/emulator/qtools:/nishome/zhouzhi/android/android_rootfs_ref/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin:/nishome/zhouzhi/android/android_rootfs_ref/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin'
+ANDROID_BUILD_TOP='/nishome/zhouzhi/android/android_rootfs_ref'
+ANDROID_EABI_TOOLCHAIN='/nishome/zhouzhi/android/android_rootfs_ref/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin'
+ANDROID_PRODUCT_OUT='/nishome/zhouzhi/android/android_rootfs_ref/out/target/product/m1ref'
+ANDROID_QTOOLS='/nishome/zhouzhi/android/android_rootfs_ref/development/emulator/qtools'
+ANDROID_TOOLCHAIN='/nishome/zhouzhi/android/android_rootfs_ref/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin'
+ARCH_EXT_LIST='
+    altivec
+    amd3dnow
+    amd3dnowext
+    armv5te
+    armv6
+    armv6t2
+    armvfp
+    avx
+    iwmmxt
+    mmi
+    mmx
+    mmx2
+    neon
+    ppc4xx
+    sse
+    ssse3
+    vfpv3
+    vis
+'
+ARCH_LIST='
+    alpha
+    arm
+    avr32
+    avr32_ap
+    avr32_uc
+    bfin
+    ia64
+    m68k
+    mips
+    mips64
+    parisc
+    ppc
+    ppc64
+    s390
+    sh4
+    sparc
+    sparc64
+    tomi
+    x86
+    x86_32
+    x86_64
+'
+BSF_LIST='aac_adtstoasc_bsf
+chomp_bsf
+dump_extradata_bsf
+h264_mp4toannexb_bsf
+imx_dump_header_bsf
+mjpeg2jpeg_bsf
+mjpega_dump_header_bsf
+mp3_header_compress_bsf
+mp3_header_decompress_bsf
+mov2textsub_bsf
+noise_bsf
+remove_extradata_bsf
+text2movsub_bsf'
+BUILD_ENV_SEQUENCE_NUMBER='9'
+CC_O='-o $@'
+CMDLINE_APPEND='
+    extra_cflags
+'
+CMDLINE_SELECT='
+    
+    altivec
+    amd3dnow
+    amd3dnowext
+    armv5te
+    armv6
+    armv6t2
+    armvfp
+    avx
+    iwmmxt
+    mmi
+    mmx
+    mmx2
+    neon
+    ppc4xx
+    sse
+    ssse3
+    vfpv3
+    vis
+
+    
+    
+    bsfs
+    decoders
+    demuxers
+    encoders
+    filters
+    hwaccels
+    indevs
+    muxers
+    outdevs
+    parsers
+    protocols
+
+    aandct
+    ac3dsp
+    avcodec
+    avdevice
+    avfilter
+    avformat
+    avisynth
+    bzlib
+    crystalhd
+    dct
+    doc
+    dwt
+    dxva2
+    fastdiv
+    ffmpeg
+    ffplay
+    ffprobe
+    ffserver
+    fft
+    frei0r
+    golomb
+    gpl
+    gray
+    h264dsp
+    h264pred
+    hardcoded_tables
+    huffman
+    libcelt
+    libdc1394
+    libdirac
+    libfaac
+    libfreetype
+    libgsm
+    libmp3lame
+    libnut
+    libopencore_amrnb
+    libopencore_amrwb
+    libopencv
+    libopenjpeg
+    librtmp
+    libschroedinger
+    libspeex
+    libtheora
+    libvo_aacenc
+    libvo_amrwbenc
+    libvorbis
+    libvpx
+    libx264
+    libxavs
+    libxvid
+    lpc
+    lsp
+    mdct
+    memalign_hack
+    mlib
+    mpegaudiodsp
+    network
+    nonfree
+    pic
+    postproc
+    rdft
+    rtpdec
+    runtime_cpudetect
+    shared
+    sinewin
+    small
+    sram
+    static
+    swscale
+    swscale_alpha
+    vaapi
+    vdpau
+    version3
+    x11grab
+    zlib
+
+    
+    pthreads
+    w32threads
+
+    asm
+    cross_compile
+    debug
+    extra_warnings
+    logging
+    optimizations
+    stripping
+    symver
+    yasm
+'
+CMDLINE_SET='
+    
+    bindir
+    datadir
+    incdir
+    libdir
+    mandir
+    prefix
+    shlibdir
+
+    ar
+    arch
+    as
+    build_suffix
+    cc
+    cpu
+    cross_prefix
+    dep_cc
+    extra_version
+    host_cc
+    host_cflags
+    host_ldflags
+    host_libs
+    host_os
+    install
+    ld
+    logfile
+    malloc_prefix
+    nm
+    pkg_config
+    samples
+    strip
+    sysinclude
+    sysroot
+    target_exec
+    target_os
+    target_path
+'
+COMPONENT_LIST='
+    bsfs
+    decoders
+    demuxers
+    encoders
+    filters
+    hwaccels
+    indevs
+    muxers
+    outdevs
+    parsers
+    protocols
+'
+CONFIG_EXTRA='
+    avutil
+    gplv3
+    lgplv3
+'
+CONFIG_LIST='
+    
+    bsfs
+    decoders
+    demuxers
+    encoders
+    filters
+    hwaccels
+    indevs
+    muxers
+    outdevs
+    parsers
+    protocols
+
+    aandct
+    ac3dsp
+    avcodec
+    avdevice
+    avfilter
+    avformat
+    avisynth
+    bzlib
+    crystalhd
+    dct
+    doc
+    dwt
+    dxva2
+    fastdiv
+    ffmpeg
+    ffplay
+    ffprobe
+    ffserver
+    fft
+    frei0r
+    golomb
+    gpl
+    gray
+    h264dsp
+    h264pred
+    hardcoded_tables
+    huffman
+    libcelt
+    libdc1394
+    libdirac
+    libfaac
+    libfreetype
+    libgsm
+    libmp3lame
+    libnut
+    libopencore_amrnb
+    libopencore_amrwb
+    libopencv
+    libopenjpeg
+    librtmp
+    libschroedinger
+    libspeex
+    libtheora
+    libvo_aacenc
+    libvo_amrwbenc
+    libvorbis
+    libvpx
+    libx264
+    libxavs
+    libxvid
+    lpc
+    lsp
+    mdct
+    memalign_hack
+    mlib
+    mpegaudiodsp
+    network
+    nonfree
+    pic
+    postproc
+    rdft
+    rtpdec
+    runtime_cpudetect
+    shared
+    sinewin
+    small
+    sram
+    static
+    swscale
+    swscale_alpha
+    vaapi
+    vdpau
+    version3
+    x11grab
+    zlib
+'
+DECODER_LIST='aasc_decoder
+amv_decoder
+anm_decoder
+ansi_decoder
+asv1_decoder
+asv2_decoder
+aura_decoder
+aura2_decoder
+avs_decoder
+bethsoftvid_decoder
+bfi_decoder
+bink_decoder
+bmp_decoder
+c93_decoder
+cavs_decoder
+cdgraphics_decoder
+cinepak_decoder
+cljr_decoder
+cscd_decoder
+cyuv_decoder
+dfa_decoder
+dnxhd_decoder
+dpx_decoder
+dsicinvideo_decoder
+dvvideo_decoder
+dxa_decoder
+eacmv_decoder
+eamad_decoder
+eatgq_decoder
+eatgv_decoder
+eatqi_decoder
+eightbps_decoder
+eightsvx_exp_decoder
+eightsvx_fib_decoder
+eightsvx_raw_decoder
+escape124_decoder
+ffv1_decoder
+ffvhuff_decoder
+flashsv_decoder
+flic_decoder
+flv_decoder
+fourxm_decoder
+fraps_decoder
+frwu_decoder
+gif_decoder
+h261_decoder
+h263_decoder
+h263i_decoder
+h264_decoder
+h264_crystalhd_decoder
+h264_vdpau_decoder
+huffyuv_decoder
+idcin_decoder
+iff_byterun1_decoder
+iff_ilbm_decoder
+indeo2_decoder
+indeo3_decoder
+indeo5_decoder
+interplay_video_decoder
+jpeg2000_decoder
+jpegls_decoder
+jv_decoder
+kgv1_decoder
+kmvc_decoder
+lagarith_decoder
+loco_decoder
+mdec_decoder
+mimic_decoder
+mjpeg_decoder
+mjpegb_decoder
+mmvideo_decoder
+motionpixels_decoder
+mpeg_xvmc_decoder
+mpeg1video_decoder
+mpeg2video_decoder
+mpeg4_decoder
+mpeg4_crystalhd_decoder
+mpeg4_vdpau_decoder
+mpegvideo_decoder
+mpeg_vdpau_decoder
+mpeg1_vdpau_decoder
+mpeg2_crystalhd_decoder
+msmpeg4_crystalhd_decoder
+msmpeg4v1_decoder
+msmpeg4v2_decoder
+msmpeg4v3_decoder
+msrle_decoder
+msvideo1_decoder
+mszh_decoder
+mxpeg_decoder
+nuv_decoder
+pam_decoder
+pbm_decoder
+pcx_decoder
+pgm_decoder
+pgmyuv_decoder
+pictor_decoder
+png_decoder
+ppm_decoder
+ptx_decoder
+qdraw_decoder
+qpeg_decoder
+qtrle_decoder
+r10k_decoder
+r210_decoder
+rawvideo_decoder
+rl2_decoder
+roq_decoder
+rpza_decoder
+rv10_decoder
+rv20_decoder
+rv30_decoder
+rv40_decoder
+s302m_decoder
+sgi_decoder
+smacker_decoder
+smc_decoder
+snow_decoder
+sp5x_decoder
+sunrast_decoder
+svq1_decoder
+svq3_decoder
+targa_decoder
+theora_decoder
+thp_decoder
+tiertexseqvideo_decoder
+tiff_decoder
+tmv_decoder
+truemotion1_decoder
+truemotion2_decoder
+tscc_decoder
+txd_decoder
+ulti_decoder
+v210_decoder
+v210x_decoder
+vb_decoder
+vc1_decoder
+vc1_crystalhd_decoder
+vc1_vdpau_decoder
+vcr1_decoder
+vmdvideo_decoder
+vmnc_decoder
+vp3_decoder
+vp5_decoder
+vp6_decoder
+vp6a_decoder
+vp6f_decoder
+vp8_decoder
+vqa_decoder
+wmv1_decoder
+wmv2_decoder
+wmv3_decoder
+wmv3_crystalhd_decoder
+wmv3_vdpau_decoder
+wnv1_decoder
+xan_wc3_decoder
+xan_wc4_decoder
+xl_decoder
+yop_decoder
+zlib_decoder
+zmbv_decoder
+aac_decoder
+aac_latm_decoder
+ac3_decoder
+alac_decoder
+als_decoder
+amrnb_decoder
+amrwb_decoder
+ape_decoder
+atrac1_decoder
+atrac3_decoder
+binkaudio_dct_decoder
+binkaudio_rdft_decoder
+cook_decoder
+dca_decoder
+dsicinaudio_decoder
+eac3_decoder
+flac_decoder
+gsm_decoder
+gsm_ms_decoder
+imc_decoder
+mace3_decoder
+mace6_decoder
+mlp_decoder
+mp1_decoder
+mp1float_decoder
+mp2_decoder
+mp2float_decoder
+mp3_decoder
+mp3float_decoder
+mp3adu_decoder
+mp3adufloat_decoder
+mp3on4_decoder
+mp3on4float_decoder
+mpc7_decoder
+mpc8_decoder
+nellymoser_decoder
+qcelp_decoder
+qdm2_decoder
+ra_144_decoder
+ra_288_decoder
+shorten_decoder
+sipr_decoder
+smackaud_decoder
+sonic_decoder
+truehd_decoder
+truespeech_decoder
+tta_decoder
+twinvq_decoder
+vmdaudio_decoder
+vorbis_decoder
+wavpack_decoder
+wmapro_decoder
+wmav1_decoder
+wmav2_decoder
+wmavoice_decoder
+ws_snd1_decoder
+pcm_alaw_decoder
+pcm_bluray_decoder
+pcm_dvd_decoder
+pcm_f32be_decoder
+pcm_f32le_decoder
+pcm_f64be_decoder
+pcm_f64le_decoder
+pcm_lxf_decoder
+pcm_mulaw_decoder
+pcm_s8_decoder
+pcm_s16be_decoder
+pcm_s16le_decoder
+pcm_s16le_planar_decoder
+pcm_s24be_decoder
+pcm_s24daud_decoder
+pcm_s24le_decoder
+pcm_s32be_decoder
+pcm_s32le_decoder
+pcm_u8_decoder
+pcm_u16be_decoder
+pcm_u16le_decoder
+pcm_u24be_decoder
+pcm_u24le_decoder
+pcm_u32be_decoder
+pcm_u32le_decoder
+pcm_zork_decoder
+interplay_dpcm_decoder
+roq_dpcm_decoder
+sol_dpcm_decoder
+xan_dpcm_decoder
+adpcm_4xm_decoder
+adpcm_adx_decoder
+adpcm_ct_decoder
+adpcm_ea_decoder
+adpcm_ea_maxis_xa_decoder
+adpcm_ea_r1_decoder
+adpcm_ea_r2_decoder
+adpcm_ea_r3_decoder
+adpcm_ea_xas_decoder
+adpcm_g722_decoder
+adpcm_g726_decoder
+adpcm_ima_amv_decoder
+adpcm_ima_dk3_decoder
+adpcm_ima_dk4_decoder
+adpcm_ima_ea_eacs_decoder
+adpcm_ima_ea_sead_decoder
+adpcm_ima_iss_decoder
+adpcm_ima_qt_decoder
+adpcm_ima_smjpeg_decoder
+adpcm_ima_wav_decoder
+adpcm_ima_ws_decoder
+adpcm_ms_decoder
+adpcm_sbpro_2_decoder
+adpcm_sbpro_3_decoder
+adpcm_sbpro_4_decoder
+adpcm_swf_decoder
+adpcm_thp_decoder
+adpcm_xa_decoder
+adpcm_yamaha_decoder
+ass_decoder
+dvbsub_decoder
+dvdsub_decoder
+pgssub_decoder
+srt_decoder
+xsub_decoder
+libcelt_decoder
+libdirac_decoder
+libgsm_decoder
+libgsm_ms_decoder
+libopencore_amrnb_decoder
+libopencore_amrwb_decoder
+libopenjpeg_decoder
+libschroedinger_decoder
+libspeex_decoder
+libvpx_decoder'
+DEMUXER_LIST='aac_demuxer
+ac3_demuxer
+aea_demuxer
+aiff_demuxer
+amr_demuxer
+anm_demuxer
+apc_demuxer
+ape_demuxer
+applehttp_demuxer
+asf_demuxer
+ass_demuxer
+au_demuxer
+avi_demuxer
+avisynth_demuxer
+avs_demuxer
+bethsoftvid_demuxer
+bfi_demuxer
+bink_demuxer
+c93_demuxer
+caf_demuxer
+cavsvideo_demuxer
+cdg_demuxer
+daud_demuxer
+dfa_demuxer
+dirac_demuxer
+dnxhd_demuxer
+dsicin_demuxer
+dts_demuxer
+dv_demuxer
+dxa_demuxer
+ea_demuxer
+ea_cdata_demuxer
+eac3_demuxer
+ffm_demuxer
+ffmetadata_demuxer
+filmstrip_demuxer
+flac_demuxer
+flic_demuxer
+flv_demuxer
+fourxm_demuxer
+g722_demuxer
+gsm_demuxer
+gxf_demuxer
+h261_demuxer
+h263_demuxer
+h264_demuxer
+idcin_demuxer
+iff_demuxer
+image2_demuxer
+image2pipe_demuxer
+ingenient_demuxer
+ipmovie_demuxer
+iss_demuxer
+iv8_demuxer
+ivf_demuxer
+jv_demuxer
+lmlm4_demuxer
+lxf_demuxer
+m4v_demuxer
+matroska_demuxer
+microdvd_demuxer
+mjpeg_demuxer
+mlp_demuxer
+mm_demuxer
+mmf_demuxer
+mov_demuxer
+mp3_demuxer
+mpc_demuxer
+mpc8_demuxer
+mpegps_demuxer
+mpegts_demuxer
+mpegtsraw_demuxer
+mpegvideo_demuxer
+msnwc_tcp_demuxer
+mtv_demuxer
+mvi_demuxer
+mxf_demuxer
+mxg_demuxer
+nc_demuxer
+nsv_demuxer
+nut_demuxer
+nuv_demuxer
+ogg_demuxer
+oma_demuxer
+pcm_alaw_demuxer
+pcm_mulaw_demuxer
+pcm_f64be_demuxer
+pcm_f64le_demuxer
+pcm_f32be_demuxer
+pcm_f32le_demuxer
+pcm_s32be_demuxer
+pcm_s32le_demuxer
+pcm_s24be_demuxer
+pcm_s24le_demuxer
+pcm_s16be_demuxer
+pcm_s16le_demuxer
+pcm_s8_demuxer
+pcm_u32be_demuxer
+pcm_u32le_demuxer
+pcm_u24be_demuxer
+pcm_u24le_demuxer
+pcm_u16be_demuxer
+pcm_u16le_demuxer
+pcm_u8_demuxer
+pmp_demuxer
+pva_demuxer
+qcp_demuxer
+r3d_demuxer
+rawvideo_demuxer
+rl2_demuxer
+rm_demuxer
+roq_demuxer
+rpl_demuxer
+rso_demuxer
+rtp_demuxer
+rtsp_demuxer
+sap_demuxer
+sdp_demuxer
+segafilm_demuxer
+shorten_demuxer
+siff_demuxer
+smacker_demuxer
+sol_demuxer
+sox_demuxer
+spdif_demuxer
+srt_demuxer
+str_demuxer
+swf_demuxer
+thp_demuxer
+tiertexseq_demuxer
+tmv_demuxer
+truehd_demuxer
+tta_demuxer
+txd_demuxer
+tty_demuxer
+vc1_demuxer
+vc1t_demuxer
+vmd_demuxer
+voc_demuxer
+vqf_demuxer
+w64_demuxer
+wav_demuxer
+wc3_demuxer
+wsaud_demuxer
+wsvqa_demuxer
+wtv_demuxer
+wv_demuxer
+xa_demuxer
+xwma_demuxer
+yop_demuxer
+yuv4mpegpipe_demuxer
+libnut_demuxer'
+DEPEND_CMD='$(DEPCC) $(DEPFLAGS) $< | sed -e "/^\#.*/d" -e "s,^[[:space:]]*$(*F)\\.o,$(@D)/$(*F).o," > $(@:.o=.d)'
+DEPFLAGS='$(CPPFLAGS) $(CFLAGS) -MM'
+DISABLE_DEXPREOPT='true'
+E1='0'
+E2='2'
+ENCODER_LIST='a64multi_encoder
+a64multi5_encoder
+asv1_encoder
+asv2_encoder
+bmp_encoder
+dnxhd_encoder
+dpx_encoder
+dvvideo_encoder
+ffv1_encoder
+ffvhuff_encoder
+flashsv_encoder
+flashsv2_encoder
+flv_encoder
+gif_encoder
+h261_encoder
+h263_encoder
+h263p_encoder
+huffyuv_encoder
+jpegls_encoder
+ljpeg_encoder
+mjpeg_encoder
+mpeg1video_encoder
+mpeg2video_encoder
+mpeg4_encoder
+msmpeg4v2_encoder
+msmpeg4v3_encoder
+msvideo1_encoder
+pam_encoder
+pbm_encoder
+pcx_encoder
+pgm_encoder
+pgmyuv_encoder
+png_encoder
+ppm_encoder
+qtrle_encoder
+rawvideo_encoder
+roq_encoder
+rv10_encoder
+rv20_encoder
+sgi_encoder
+snow_encoder
+svq1_encoder
+targa_encoder
+tiff_encoder
+v210_encoder
+wmv1_encoder
+wmv2_encoder
+zlib_encoder
+zmbv_encoder
+aac_encoder
+ac3_encoder
+ac3_fixed_encoder
+ac3_float_encoder
+alac_encoder
+dca_encoder
+eac3_encoder
+flac_encoder
+mp2_encoder
+nellymoser_encoder
+ra_144_encoder
+sonic_encoder
+sonic_ls_encoder
+vorbis_encoder
+wmav1_encoder
+wmav2_encoder
+pcm_alaw_encoder
+pcm_f32be_encoder
+pcm_f32le_encoder
+pcm_f64be_encoder
+pcm_f64le_encoder
+pcm_mulaw_encoder
+pcm_s8_encoder
+pcm_s16be_encoder
+pcm_s16le_encoder
+pcm_s24be_encoder
+pcm_s24daud_encoder
+pcm_s24le_encoder
+pcm_s32be_encoder
+pcm_s32le_encoder
+pcm_u8_encoder
+pcm_u16be_encoder
+pcm_u16le_encoder
+pcm_u24be_encoder
+pcm_u24le_encoder
+pcm_u32be_encoder
+pcm_u32le_encoder
+pcm_zork_encoder
+roq_dpcm_encoder
+adpcm_adx_encoder
+adpcm_g722_encoder
+adpcm_g726_encoder
+adpcm_ima_qt_encoder
+adpcm_ima_wav_encoder
+adpcm_ms_encoder
+adpcm_swf_encoder
+adpcm_yamaha_encoder
+ass_encoder
+dvbsub_encoder
+dvdsub_encoder
+srt_encoder
+xsub_encoder
+libdirac_encoder
+libfaac_encoder
+libgsm_encoder
+libgsm_ms_encoder
+libmp3lame_encoder
+libopencore_amrnb_encoder
+libschroedinger_encoder
+libtheora_encoder
+libvo_aacenc_encoder
+libvo_amrwbenc_encoder
+libvorbis_encoder
+libvpx_encoder
+libx264_encoder
+libxavs_encoder
+libxvid_encoder'
+FFMPEG_CONFIGURATION='--disable-yasm --disable-ffplay --cross-prefix=arm-none-linux-gnueabi- --enable-cross-compile --target-os=linux --arch=arm'
+FFSERVERLDFLAGS='-Wl,-E'
+FILTER_LIST='anull_filter
+anullsrc_filter
+anullsink_filter
+blackframe_filter
+copy_filter
+crop_filter
+cropdetect_filter
+drawbox_filter
+drawtext_filter
+fade_filter
+fieldorder_filter
+fifo_filter
+format_filter
+frei0r_filter
+gradfun_filter
+hflip_filter
+hqdn3d_filter
+lut_filter
+lutrgb_filter
+lutyuv_filter
+mp_filter
+negate_filter
+noformat_filter
+null_filter
+ocv_filter
+overlay_filter
+pad_filter
+pixdesctest_filter
+scale_filter
+select_filter
+setdar_filter
+setpts_filter
+setsar_filter
+settb_filter
+showinfo_filter
+slicify_filter
+split_filter
+transpose_filter
+unsharp_filter
+vflip_filter
+yadif_filter
+buffer_filter
+color_filter
+frei0r_src_filter
+movie_filter
+nullsrc_filter
+buffersink_filter
+nullsink_filter'
+FULLNAME='$(NAME)$(BUILDSUF)'
+HAVE_LIST='
+    
+    altivec
+    amd3dnow
+    amd3dnowext
+    armv5te
+    armv6
+    armv6t2
+    armvfp
+    avx
+    iwmmxt
+    mmi
+    mmx
+    mmx2
+    neon
+    ppc4xx
+    sse
+    ssse3
+    vfpv3
+    vis
+
+    
+    bigendian
+    fast_unaligned
+
+    
+    pthreads
+    w32threads
+
+    aligned_stack
+    alsa_asoundlib_h
+    altivec_h
+    arpa_inet_h
+    attribute_may_alias
+    attribute_packed
+    bswap
+    closesocket
+    cmov
+    dcbzl
+    dev_bktr_ioctl_bt848_h
+    dev_bktr_ioctl_meteor_h
+    dev_ic_bt8xx_h
+    dev_video_meteor_ioctl_meteor_h
+    dev_video_bktr_ioctl_bt848_h
+    dlfcn_h
+    dlopen
+    dos_paths
+    ebp_available
+    ebx_available
+    exp2
+    exp2f
+    fast_64bit
+    fast_clz
+    fast_cmov
+    fcntl
+    fork
+    getaddrinfo
+    gethrtime
+    GetProcessMemoryInfo
+    GetProcessTimes
+    getrusage
+    gnu_as
+    struct_rusage_ru_maxrss
+    ibm_asm
+    inet_aton
+    inline_asm
+    isatty
+    kbhit
+    ldbrx
+    llrint
+    llrintf
+    local_aligned_16
+    local_aligned_8
+    localtime_r
+    log2
+    log2f
+    loongson
+    lrint
+    lrintf
+    lzo1x_999_compress
+    machine_ioctl_bt848_h
+    machine_ioctl_meteor_h
+    malloc_h
+    MapViewOfFile
+    memalign
+    mkstemp
+    mmap
+    pld
+    posix_memalign
+    round
+    roundf
+    sdl
+    sdl_video_size
+    setmode
+    sndio_h
+    socklen_t
+    soundcard_h
+    poll_h
+    setrlimit
+    strerror_r
+    strtok_r
+    struct_addrinfo
+    struct_ipv6_mreq
+    struct_sockaddr_in6
+    struct_sockaddr_sa_len
+    struct_sockaddr_storage
+    symver
+    symver_gnu_asm
+    symver_asm_label
+    sys_mman_h
+    sys_resource_h
+    sys_select_h
+    sys_soundcard_h
+    sys_videoio_h
+    ten_operands
+    termios_h
+    threads
+    trunc
+    truncf
+    vfp_args
+    VirtualAlloc
+    winsock2_h
+    xform_asm
+    xmm_clobbers
+    yasm
+'
+HAVE_LIST_PUB='
+    bigendian
+    fast_unaligned
+'
+HOME='/nishome/zhouzhi'
+HWACCEL_LIST='h263_vaapi_hwaccel
+h264_dxva2_hwaccel
+h264_vaapi_hwaccel
+mpeg1_vdpau_hwaccel
+mpeg2_dxva2_hwaccel
+mpeg2_vaapi_hwaccel
+mpeg2_vdpau_hwaccel
+mpeg4_vaapi_hwaccel
+vc1_dxva2_hwaccel
+vc1_vaapi_hwaccel
+wmv3_dxva2_hwaccel
+wmv3_vaapi_hwaccel'
+IFS=' 	
+'
+INDEV_LIST='alsa_indev
+bktr_indev
+dshow_indev
+dv1394_indev
+fbdev_indev
+jack_indev
+oss_indev
+sndio_indev
+v4l2_indev
+v4l_indev
+vfwcap_indev
+x11_grab_device_indev
+libdc1394_indev'
+JAVA_HOME='/usr/lib/jvm/java-1.5.0-sun'
+LANG='en_US.UTF-8'
+LAVFI_TESTS='crop_test
+crop_scale_test
+crop_scale_vflip_test
+crop_vflip_test
+null_test
+pixdesc_be_test
+pixdesc_le_test
+pixfmts_copy_le_test
+pixfmts_crop_le_test
+pixfmts_hflip_le_test
+pixfmts_null_le_test
+pixfmts_pad_le_test
+pixfmts_scale_le_test
+pixfmts_vflip_le_test
+scale200_test
+scale500_test
+vflip_test
+vflip_crop_test
+vflip_vflip_test'
+LAVF_TESTS='aiff_test
+alaw_test
+asf_test
+au_test
+avi_test
+bmp_test
+dv_fmt_test
+ffm_test
+flv_fmt_test
+gif_test
+gxf_test
+jpg_test
+mkv_test
+mmf_test
+mov_test
+mpg_test
+mulaw_test
+mxf_test
+nut_test
+ogg_test
+pbmpipe_test
+pcx_test
+pgm_test
+pgmpipe_test
+pixfmt_test
+png_test
+ppm_test
+ppmpipe_test
+rm_test
+sgi_test
+swf_test
+tga_test
+tiff_test
+ts_test
+voc_test
+voc_s16_test
+wav_test
+yuv4mpeg_test'
+LC_ALL='C'
+LIBNAME='$(LIBPREF)$(FULLNAME)$(LIBSUF)'
+LIBPREF='lib'
+LIBSUF='.a'
+LIB_INSTALL_EXTRA_CMD='$$(RANLIB) "$(LIBDIR)/$(LIBNAME)"'
+LOGNAME='zhouzhi'
+MAIL='/var/mail/zhouzhi'
+MUXER_LIST='a64_muxer
+ac3_muxer
+adts_muxer
+aiff_muxer
+amr_muxer
+asf_muxer
+ass_muxer
+asf_stream_muxer
+au_muxer
+avi_muxer
+avm2_muxer
+caf_muxer
+cavsvideo_muxer
+crc_muxer
+daud_muxer
+dirac_muxer
+dnxhd_muxer
+dts_muxer
+dv_muxer
+eac3_muxer
+ffm_muxer
+ffmetadata_muxer
+filmstrip_muxer
+flac_muxer
+flv_muxer
+framecrc_muxer
+framemd5_muxer
+g722_muxer
+gif_muxer
+gxf_muxer
+h261_muxer
+h263_muxer
+h264_muxer
+image2_muxer
+image2pipe_muxer
+ipod_muxer
+ivf_muxer
+m4v_muxer
+md5_muxer
+matroska_muxer
+matroska_audio_muxer
+microdvd_muxer
+mjpeg_muxer
+mlp_muxer
+mmf_muxer
+mov_muxer
+mp2_muxer
+mp3_muxer
+mp4_muxer
+mpeg1system_muxer
+mpeg1vcd_muxer
+mpeg1video_muxer
+mpeg2dvd_muxer
+mpeg2svcd_muxer
+mpeg2video_muxer
+mpeg2vob_muxer
+mpegts_muxer
+mpjpeg_muxer
+mxf_muxer
+mxf_d10_muxer
+null_muxer
+nut_muxer
+ogg_muxer
+pcm_alaw_muxer
+pcm_mulaw_muxer
+pcm_f64be_muxer
+pcm_f64le_muxer
+pcm_f32be_muxer
+pcm_f32le_muxer
+pcm_s32be_muxer
+pcm_s32le_muxer
+pcm_s24be_muxer
+pcm_s24le_muxer
+pcm_s16be_muxer
+pcm_s16le_muxer
+pcm_s8_muxer
+pcm_u32be_muxer
+pcm_u32le_muxer
+pcm_u24be_muxer
+pcm_u24le_muxer
+pcm_u16be_muxer
+pcm_u16le_muxer
+pcm_u8_muxer
+psp_muxer
+rawvideo_muxer
+rm_muxer
+roq_muxer
+rso_muxer
+rtp_muxer
+rtsp_muxer
+sap_muxer
+sox_muxer
+spdif_muxer
+srt_muxer
+swf_muxer
+tg2_muxer
+tgp_muxer
+truehd_muxer
+vc1t_muxer
+voc_muxer
+wav_muxer
+webm_muxer
+yuv4mpegpipe_muxer
+libnut_muxer'
+OLDPWD='/nishome/zhouzhi/android/android_rootfs_ref/packages/amlogic/LibPlayer'
+OPROFILE_EVENTS_DIR='/nishome/zhouzhi/android/android_rootfs_ref/prebuilt/linux-x86/oprofile'
+OPTIND='1'
+OUT='/nishome/zhouzhi/android/android_rootfs_ref/out/target/product/m1ref'
+OUTDEV_LIST='alsa_outdev
+oss_outdev
+sdl_outdev
+sndio_outdev'
+PARSER_LIST='aac_parser
+aac_latm_parser
+ac3_parser
+cavsvideo_parser
+dca_parser
+dirac_parser
+dnxhd_parser
+dvbsub_parser
+dvdsub_parser
+flac_parser
+h261_parser
+h263_parser
+h264_parser
+mjpeg_parser
+mlp_parser
+mpeg4video_parser
+mpegaudio_parser
+mpegvideo_parser
+pnm_parser
+vc1_parser
+vp3_parser
+vp8_parser'
+PATH='/opt/jdk1.5.0_21/bin:/opt/jdk1.5.0_21/bin:/opt/jdk1.5.0_21/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/arm/4.3.2/bin:/usr/local/arm-q1/bin:/nishome/zhouzhi/bin:/nishome/zhouzhi/android/android_rootfs_ref/out/host/linux-x86/bin:/nishome/zhouzhi/android/android_rootfs_ref/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin:/nishome/zhouzhi/android/android_rootfs_ref/development/emulator/qtools:/nishome/zhouzhi/android/android_rootfs_ref/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin:/nishome/zhouzhi/android/android_rootfs_ref/prebuilt/linux-x86/toolchain/arm-eabi-4.4.0/bin'
+PATHS_LIST='
+    bindir
+    datadir
+    incdir
+    libdir
+    mandir
+    prefix
+    shlibdir
+'
+PPID='8263'
+PROMPT_COMMAND='echo -ne "\033]0;[m1ref-eng] zhouzhi@droid04-bj: /nishome/zhouzhi/android/android_rootfs_ref\007"'
+PROTOCOL_LIST='applehttp_protocol
+concat_protocol
+crypto_protocol
+file_protocol
+gopher_protocol
+http_protocol
+mmsh_protocol
+mmst_protocol
+md5_protocol
+pipe_protocol
+rtmp_protocol
+rtmpt_protocol
+rtmpe_protocol
+rtmpte_protocol
+rtmps_protocol
+rtp_protocol
+tcp_protocol
+udp_protocol'
+PS1='$ '
+PS2='> '
+PS4='+ '
+PWD='/nishome/zhouzhi/android/android_rootfs_ref/packages/amlogic/LibPlayer/amffmpeg-0.8'
+SEEK_TESTS='seek_ac3_rm_test
+seek_adpcm_ima_wav_test
+seek_adpcm_ms_wav_test
+seek_adpcm_qt_aiff_test
+seek_adpcm_swf_flv_test
+seek_adpcm_yam_wav_test
+seek_alac_m4a_test
+seek_asv1_avi_test
+seek_asv2_avi_test
+seek_dnxhd_1080i_mov_test
+seek_dnxhd_720p_dnxhd_test
+seek_dnxhd_720p_rd_dnxhd_test
+seek_dv411_dv_test
+seek_dv50_dv_test
+seek_dv_dv_test
+seek_error_mpeg4_adv_avi_test
+seek_ffv1_avi_test
+seek_flac_flac_test
+seek_flashsv_flv_test
+seek_flv_flv_test
+seek_g726_wav_test
+seek_h261_avi_test
+seek_h263_avi_test
+seek_h263p_avi_test
+seek_huffyuv_avi_test
+seek_image_bmp_test
+seek_image_jpg_test
+seek_image_pcx_test
+seek_image_pgm_test
+seek_image_ppm_test
+seek_image_sgi_test
+seek_image_tga_test
+seek_image_tiff_test
+seek_jpegls_avi_test
+seek_lavf_aif_test
+seek_lavf_al_test
+seek_lavf_asf_test
+seek_lavf_au_test
+seek_lavf_avi_test
+seek_lavf_dv_test
+seek_lavf_ffm_test
+seek_lavf_flv_test
+seek_lavf_gif_test
+seek_lavf_gxf_test
+seek_lavf_mkv_test
+seek_lavf_mmf_test
+seek_lavf_mov_test
+seek_lavf_mpg_test
+seek_lavf_mxf_test
+seek_lavf_mxf_d10_test
+seek_lavf_nut_test
+seek_lavf_ogg_test
+seek_lavf_rm_test
+seek_lavf_swf_test
+seek_lavf_ts_test
+seek_lavf_ul_test
+seek_lavf_voc_test
+seek_lavf_wav_test
+seek_lavf_y4m_test
+seek_ljpeg_avi_test
+seek_mjpeg_avi_test
+seek_mp2_mp2_test
+seek_mpeg1_mpg_test
+seek_mpeg1b_mpg_test
+seek_mpeg2_422_mpg_test
+seek_mpeg2_mpg_test
+seek_mpeg2i_mpg_test
+seek_mpeg2ivlc_qprd_mpg_test
+seek_mpeg2reuse_mpg_test
+seek_mpeg2thread_mpg_test
+seek_mpeg2threadivlc_mpg_test
+seek_mpeg4_adap_avi_test
+seek_mpeg4_adv_avi_test
+seek_mpeg4_nr_avi_test
+seek_mpeg4_qprd_avi_test
+seek_mpeg4_rc_avi_test
+seek_mpeg4_thread_avi_test
+seek_msmpeg4_avi_test
+seek_msmpeg4v2_avi_test
+seek_odivx_mp4_test
+seek_pbmpipe_pbm_test
+seek_pcm_alaw_wav_test
+seek_pcm_f32be_au_test
+seek_pcm_f32le_wav_test
+seek_pcm_f64be_au_test
+seek_pcm_f64le_wav_test
+seek_pcm_mulaw_wav_test
+seek_pcm_s16be_mkv_test
+seek_pcm_s16be_mov_test
+seek_pcm_s16le_mkv_test
+seek_pcm_s16le_wav_test
+seek_pcm_s24be_mov_test
+seek_pcm_s24daud_302_test
+seek_pcm_s24le_wav_test
+seek_pcm_s32be_mov_test
+seek_pcm_s32le_wav_test
+seek_pcm_s8_mov_test
+seek_pcm_u8_wav_test
+seek_pcm_zork_wav_test
+seek_pgmpipe_pgm_test
+seek_ppmpipe_ppm_test
+seek_rgb_avi_test
+seek_roqav_roq_test
+seek_rv10_rm_test
+seek_rv20_rm_test
+seek_snow53_avi_test
+seek_snow_avi_test
+seek_svq1_mov_test
+seek_wmav1_asf_test
+seek_wmav2_asf_test
+seek_wmv1_avi_test
+seek_wmv2_avi_test
+seek_yuv_avi_test'
+SHELL='/bin/bash'
+SHFLAGS='-shared -Wl,-soname,$$(@F)'
+SHLVL='1'
+SLIBNAME='$(SLIBPREF)$(FULLNAME)$(SLIBSUF)'
+SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'
+SLIBNAME_WITH_VERSION='$(SLIBNAME).$(LIBVERSION)'
+SLIBPREF='lib'
+SLIBSUF='.so'
+SSH_CLIENT='10.68.11.119 32894 22'
+SSH_CONNECTION='10.68.11.119 32894 10.68.11.60 22'
+SSH_TTY='/dev/pts/3'
+TARGET_BUILD_APPS=''
+TARGET_BUILD_TYPE='release'
+TARGET_BUILD_VARIANT='eng'
+TARGET_PRODUCT='m1ref'
+TARGET_SIMULATOR='false'
+TERM='linux'
+THREADS_LIST='
+    pthreads
+    w32threads
+'
+USER='zhouzhi'
+VCODEC_TESTS='asv1_test
+asv2_test
+dnxhd_1080i_test
+dnxhd_720p_test
+dnxhd_720p_rd_test
+dv_test
+dv50_test
+error_test
+ffv1_test
+flashsv_test
+flashsv2_test
+flv_test
+h261_test
+h263_test
+h263p_test
+huffyuv_test
+jpegls_test
+ljpeg_test
+mjpeg_test
+mpeg_test
+mpeg1b_test
+mpeg2_test
+mpeg2thread_test
+mpeg4_test
+mpeg4adv_test
+mpeg4nr_test
+mpeg4thread_test
+msmpeg4_test
+msmpeg4v2_test
+msvideo1_test
+qtrle_test
+qtrlegray_test
+rc_test
+rgb_test
+roq_test
+rv10_test
+rv20_test
+snow_test
+snowll_test
+svq1_test
+vref_test
+wmv1_test
+wmv2_test
+yuv_test'
+XDG_SESSION_COOKIE='577f62317afe98710854310000000006-1309138777.662114-2143907601'
+_='./configure'
+a64_muxer='yes'
+a64multi5_encoder='yes'
+a64multi_encoder='yes'
+aac_adtstoasc_bsf='yes'
+aac_decoder='yes'
+aac_decoder_select='mdct sinewin'
+aac_demuxer='yes'
+aac_encoder='yes'
+aac_encoder_select='mdct sinewin'
+aac_latm_decoder='yes'
+aac_latm_decoder_select='aac_decoder aac_latm_parser'
+aac_latm_parser='yes'
+aac_parser='yes'
+aasc_decoder='yes'
+ac3_decoder='yes'
+ac3_decoder_select='mdct ac3dsp ac3_parser'
+ac3_demuxer='yes'
+ac3_demuxer_select='ac3_parser'
+ac3_encoder='yes'
+ac3_encoder_select='mdct ac3dsp'
+ac3_fixed_encoder='yes'
+ac3_fixed_encoder_select='mdct ac3dsp'
+ac3_fixed_test='yes'
+ac3_fixed_test_deps='ac3_fixed_encoder ac3_decoder rm_muxer rm_demuxer'
+ac3_float_encoder='yes'
+ac3_muxer='yes'
+ac3_parser='yes'
+action='enable'
+adpcm_4xm_decoder='yes'
+adpcm_adx_decoder='yes'
+adpcm_adx_encoder='yes'
+adpcm_ct_decoder='yes'
+adpcm_ea_decoder='yes'
+adpcm_ea_maxis_xa_decoder='yes'
+adpcm_ea_r1_decoder='yes'
+adpcm_ea_r2_decoder='yes'
+adpcm_ea_r3_decoder='yes'
+adpcm_ea_xas_decoder='yes'
+adpcm_g722_decoder='yes'
+adpcm_g722_encoder='yes'
+adpcm_g726_decoder='yes'
+adpcm_g726_encoder='yes'
+adpcm_ima_amv_decoder='yes'
+adpcm_ima_dk3_decoder='yes'
+adpcm_ima_dk4_decoder='yes'
+adpcm_ima_ea_eacs_decoder='yes'
+adpcm_ima_ea_sead_decoder='yes'
+adpcm_ima_iss_decoder='yes'
+adpcm_ima_qt_decoder='yes'
+adpcm_ima_qt_encoder='yes'
+adpcm_ima_qt_test='yes'
+adpcm_ima_qt_test_deps='adpcm_ima_qt_encoder adpcm_ima_qt_decoder'
+adpcm_ima_smjpeg_decoder='yes'
+adpcm_ima_wav_decoder='yes'
+adpcm_ima_wav_encoder='yes'
+adpcm_ima_wav_test='yes'
+adpcm_ima_wav_test_deps='adpcm_ima_wav_encoder adpcm_ima_wav_decoder'
+adpcm_ima_ws_decoder='yes'
+adpcm_ms_decoder='yes'
+adpcm_ms_encoder='yes'
+adpcm_ms_test='yes'
+adpcm_ms_test_deps='adpcm_ms_encoder adpcm_ms_decoder'
+adpcm_sbpro_2_decoder='yes'
+adpcm_sbpro_3_decoder='yes'
+adpcm_sbpro_4_decoder='yes'
+adpcm_swf_decoder='yes'
+adpcm_swf_encoder='yes'
+adpcm_swf_test='yes'
+adpcm_swf_test_deps='adpcm_swf_encoder adpcm_swf_decoder'
+adpcm_thp_decoder='yes'
+adpcm_xa_decoder='yes'
+adpcm_yam_test='yes'
+adpcm_yam_test_deps='adpcm_yamaha_encoder adpcm_yamaha_decoder'
+adpcm_yamaha_decoder='yes'
+adpcm_yamaha_encoder='yes'
+adts_muxer='yes'
+aea_demuxer='yes'
+aiff_demuxer='yes'
+aiff_muxer='yes'
+aiff_test='yes'
+aiff_test_deps='aiff_muxer aiff_demuxer'
+alac_decoder='yes'
+alac_encoder='yes'
+alac_encoder_select='lpc'
+alac_test='yes'
+alac_test_deps='alac_encoder alac_decoder'
+alaw_test='yes'
+alaw_test_deps='pcm_alaw_muxer pcm_alaw_demuxer'
+aligned_stack_if_any='ppc x86'
+als_decoder='yes'
+alsa_indev='yes'
+alsa_indev_deps='alsa_asoundlib_h snd_pcm_htimestamp'
+alsa_outdev='yes'
+alsa_outdev_deps='alsa_asoundlib_h'
+altivec='yes'
+altivec_deps='ppc'
+amd3dnow='yes'
+amd3dnow_deps='mmx'
+amd3dnowext='yes'
+amd3dnowext_deps='amd3dnow'
+amr_demuxer='yes'
+amr_muxer='yes'
+amrnb_decoder='yes'
+amrnb_decoder_select='lsp'
+amrwb_decoder='yes'
+amrwb_decoder_select='lsp'
+amv_decoder='yes'
+anm_decoder='yes'
+anm_demuxer='yes'
+ansi_decoder='yes'
+anull_filter='yes'
+anullsink_filter='yes'
+anullsrc_filter='yes'
+apc_demuxer='yes'
+ape_decoder='yes'
+ape_demuxer='yes'
+applehttp_demuxer='yes'
+applehttp_protocol='yes'
+ar_default='ar'
+arch='arm'
+arch_default='i686'
+aref_test='yes'
+armv5te='yes'
+armv5te_deps='arm'
+armv6='yes'
+armv6_deps='arm'
+armv6t2='yes'
+armv6t2_deps='arm'
+armvfp='yes'
+armvfp_deps='arm'
+asf_demuxer='yes'
+asf_muxer='yes'
+asf_stream_muxer='yes'
+asf_stream_muxer_select='asf_muxer'
+asf_test='yes'
+asf_test_deps='asf_muxer asf_demuxer'
+asm='yes'
+ass_decoder='yes'
+ass_demuxer='yes'
+ass_encoder='yes'
+ass_muxer='yes'
+asv1_decoder='yes'
+asv1_encoder='yes'
+asv1_test='yes'
+asv1_test_deps='asv1_encoder asv1_decoder'
+asv2_decoder='yes'
+asv2_encoder='yes'
+asv2_test='yes'
+asv2_test_deps='asv2_encoder asv2_decoder'
+atrac1_decoder='yes'
+atrac1_decoder_select='mdct sinewin'
+atrac3_decoder='yes'
+atrac3_decoder_select='mdct'
+au_demuxer='yes'
+au_muxer='yes'
+au_test='yes'
+au_test_deps='au_muxer au_demuxer'
+aura2_decoder='yes'
+aura_decoder='yes'
+avcodec='yes'
+avdevice='yes'
+avdevice_deps='avcodec avformat'
+avfilter='yes'
+avformat='yes'
+avformat_deps='avcodec'
+avi_demuxer='yes'
+avi_muxer='yes'
+avi_test='yes'
+avi_test_deps='avi_muxer avi_demuxer'
+avisynth_demuxer='yes'
+avisynth_demuxer_deps='avisynth'
+avm2_muxer='yes'
+avs_decoder='yes'
+avs_demuxer='yes'
+avutil='yes'
+avx='yes'
+avx_deps='ssse3'
+bethsoftvid_decoder='yes'
+bethsoftvid_demuxer='yes'
+bfi_decoder='yes'
+bfi_demuxer='yes'
+bindir_default='${prefix}/bin'
+bink_decoder='yes'
+bink_demuxer='yes'
+binkaudio_dct_decoder='yes'
+binkaudio_dct_decoder_select='mdct rdft dct sinewin'
+binkaudio_rdft_decoder='yes'
+binkaudio_rdft_decoder_select='mdct rdft sinewin'
+bktr_indev='yes'
+bktr_indev_deps_any='dev_bktr_ioctl_bt848_h machine_ioctl_bt848_h dev_video_bktr_ioctl_bt848_h dev_ic_bt8xx_h'
+blackframe_filter='yes'
+blackframe_filter_deps='gpl'
+bmp_decoder='yes'
+bmp_encoder='yes'
+bmp_test='yes'
+bmp_test_deps='bmp_encoder bmp_decoder'
+bsfs_if_any='aac_adtstoasc_bsf
+chomp_bsf
+dump_extradata_bsf
+h264_mp4toannexb_bsf
+imx_dump_header_bsf
+mjpeg2jpeg_bsf
+mjpega_dump_header_bsf
+mp3_header_compress_bsf
+mp3_header_decompress_bsf
+mov2textsub_bsf
+noise_bsf
+remove_extradata_bsf
+text2movsub_bsf'
+buffer_filter='yes'
+buffersink_filter='yes'
+c93_decoder='yes'
+c93_demuxer='yes'
+caf_demuxer='yes'
+caf_muxer='yes'
+cavs_decoder='yes'
+cavs_decoder_select='golomb'
+cavsvideo_demuxer='yes'
+cavsvideo_muxer='yes'
+cavsvideo_parser='yes'
+cc_default='gcc'
+cc_version='"unknown"'
+cdg_demuxer='yes'
+cdgraphics_decoder='yes'
+chomp_bsf='yes'
+cinepak_decoder='yes'
+cljr_decoder='yes'
+color_filter='yes'
+concat_protocol='yes'
+cook_decoder='yes'
+cook_decoder_select='mdct sinewin'
+copy_filter='yes'
+cpu='generic'
+crc_muxer='yes'
+crop_filter='yes'
+crop_scale_test='yes'
+crop_scale_vflip_test='yes'
+crop_test='yes'
+crop_vflip_test='yes'
+cropdetect_filter='yes'
+cropdetect_filter_deps='gpl'
+cross_compile='yes'
+cross_prefix='arm-none-linux-gnueabi-'
+crypto_protocol='yes'
+crystalhd_deps='libcrystalhd_libcrystalhd_if_h'
+cscd_decoder='yes'
+cscd_decoder_suggest='zlib'
+cyuv_decoder='yes'
+datadir_default='${prefix}/share/ffmpeg'
+daud_demuxer='yes'
+daud_muxer='yes'
+dca_decoder='yes'
+dca_decoder_select='mdct'
+dca_encoder='yes'
+dca_parser='yes'
+dct_select='rdft'
+debug='yes'
+decoders_if_any='aasc_decoder
+amv_decoder
+anm_decoder
+ansi_decoder
+asv1_decoder
+asv2_decoder
+aura_decoder
+aura2_decoder
+avs_decoder
+bethsoftvid_decoder
+bfi_decoder
+bink_decoder
+bmp_decoder
+c93_decoder
+cavs_decoder
+cdgraphics_decoder
+cinepak_decoder
+cljr_decoder
+cscd_decoder
+cyuv_decoder
+dfa_decoder
+dnxhd_decoder
+dpx_decoder
+dsicinvideo_decoder
+dvvideo_decoder
+dxa_decoder
+eacmv_decoder
+eamad_decoder
+eatgq_decoder
+eatgv_decoder
+eatqi_decoder
+eightbps_decoder
+eightsvx_exp_decoder
+eightsvx_fib_decoder
+eightsvx_raw_decoder
+escape124_decoder
+ffv1_decoder
+ffvhuff_decoder
+flashsv_decoder
+flic_decoder
+flv_decoder
+fourxm_decoder
+fraps_decoder
+frwu_decoder
+gif_decoder
+h261_decoder
+h263_decoder
+h263i_decoder
+h264_decoder
+h264_crystalhd_decoder
+h264_vdpau_decoder
+huffyuv_decoder
+idcin_decoder
+iff_byterun1_decoder
+iff_ilbm_decoder
+indeo2_decoder
+indeo3_decoder
+indeo5_decoder
+interplay_video_decoder
+jpeg2000_decoder
+jpegls_decoder
+jv_decoder
+kgv1_decoder
+kmvc_decoder
+lagarith_decoder
+loco_decoder
+mdec_decoder
+mimic_decoder
+mjpeg_decoder
+mjpegb_decoder
+mmvideo_decoder
+motionpixels_decoder
+mpeg_xvmc_decoder
+mpeg1video_decoder
+mpeg2video_decoder
+mpeg4_decoder
+mpeg4_crystalhd_decoder
+mpeg4_vdpau_decoder
+mpegvideo_decoder
+mpeg_vdpau_decoder
+mpeg1_vdpau_decoder
+mpeg2_crystalhd_decoder
+msmpeg4_crystalhd_decoder
+msmpeg4v1_decoder
+msmpeg4v2_decoder
+msmpeg4v3_decoder
+msrle_decoder
+msvideo1_decoder
+mszh_decoder
+mxpeg_decoder
+nuv_decoder
+pam_decoder
+pbm_decoder
+pcx_decoder
+pgm_decoder
+pgmyuv_decoder
+pictor_decoder
+png_decoder
+ppm_decoder
+ptx_decoder
+qdraw_decoder
+qpeg_decoder
+qtrle_decoder
+r10k_decoder
+r210_decoder
+rawvideo_decoder
+rl2_decoder
+roq_decoder
+rpza_decoder
+rv10_decoder
+rv20_decoder
+rv30_decoder
+rv40_decoder
+s302m_decoder
+sgi_decoder
+smacker_decoder
+smc_decoder
+snow_decoder
+sp5x_decoder
+sunrast_decoder
+svq1_decoder
+svq3_decoder
+targa_decoder
+theora_decoder
+thp_decoder
+tiertexseqvideo_decoder
+tiff_decoder
+tmv_decoder
+truemotion1_decoder
+truemotion2_decoder
+tscc_decoder
+txd_decoder
+ulti_decoder
+v210_decoder
+v210x_decoder
+vb_decoder
+vc1_decoder
+vc1_crystalhd_decoder
+vc1_vdpau_decoder
+vcr1_decoder
+vmdvideo_decoder
+vmnc_decoder
+vp3_decoder
+vp5_decoder
+vp6_decoder
+vp6a_decoder
+vp6f_decoder
+vp8_decoder
+vqa_decoder
+wmv1_decoder
+wmv2_decoder
+wmv3_decoder
+wmv3_crystalhd_decoder
+wmv3_vdpau_decoder
+wnv1_decoder
+xan_wc3_decoder
+xan_wc4_decoder
+xl_decoder
+yop_decoder
+zlib_decoder
+zmbv_decoder
+aac_decoder
+aac_latm_decoder
+ac3_decoder
+alac_decoder
+als_decoder
+amrnb_decoder
+amrwb_decoder
+ape_decoder
+atrac1_decoder
+atrac3_decoder
+binkaudio_dct_decoder
+binkaudio_rdft_decoder
+cook_decoder
+dca_decoder
+dsicinaudio_decoder
+eac3_decoder
+flac_decoder
+gsm_decoder
+gsm_ms_decoder
+imc_decoder
+mace3_decoder
+mace6_decoder
+mlp_decoder
+mp1_decoder
+mp1float_decoder
+mp2_decoder
+mp2float_decoder
+mp3_decoder
+mp3float_decoder
+mp3adu_decoder
+mp3adufloat_decoder
+mp3on4_decoder
+mp3on4float_decoder
+mpc7_decoder
+mpc8_decoder
+nellymoser_decoder
+qcelp_decoder
+qdm2_decoder
+ra_144_decoder
+ra_288_decoder
+shorten_decoder
+sipr_decoder
+smackaud_decoder
+sonic_decoder
+truehd_decoder
+truespeech_decoder
+tta_decoder
+twinvq_decoder
+vmdaudio_decoder
+vorbis_decoder
+wavpack_decoder
+wmapro_decoder
+wmav1_decoder
+wmav2_decoder
+wmavoice_decoder
+ws_snd1_decoder
+pcm_alaw_decoder
+pcm_bluray_decoder
+pcm_dvd_decoder
+pcm_f32be_decoder
+pcm_f32le_decoder
+pcm_f64be_decoder
+pcm_f64le_decoder
+pcm_lxf_decoder
+pcm_mulaw_decoder
+pcm_s8_decoder
+pcm_s16be_decoder
+pcm_s16le_decoder
+pcm_s16le_planar_decoder
+pcm_s24be_decoder
+pcm_s24daud_decoder
+pcm_s24le_decoder
+pcm_s32be_decoder
+pcm_s32le_decoder
+pcm_u8_decoder
+pcm_u16be_decoder
+pcm_u16le_decoder
+pcm_u24be_decoder
+pcm_u24le_decoder
+pcm_u32be_decoder
+pcm_u32le_decoder
+pcm_zork_decoder
+interplay_dpcm_decoder
+roq_dpcm_decoder
+sol_dpcm_decoder
+xan_dpcm_decoder
+adpcm_4xm_decoder
+adpcm_adx_decoder
+adpcm_ct_decoder
+adpcm_ea_decoder
+adpcm_ea_maxis_xa_decoder
+adpcm_ea_r1_decoder
+adpcm_ea_r2_decoder
+adpcm_ea_r3_decoder
+adpcm_ea_xas_decoder
+adpcm_g722_decoder
+adpcm_g726_decoder
+adpcm_ima_amv_decoder
+adpcm_ima_dk3_decoder
+adpcm_ima_dk4_decoder
+adpcm_ima_ea_eacs_decoder
+adpcm_ima_ea_sead_decoder
+adpcm_ima_iss_decoder
+adpcm_ima_qt_decoder
+adpcm_ima_smjpeg_decoder
+adpcm_ima_wav_decoder
+adpcm_ima_ws_decoder
+adpcm_ms_decoder
+adpcm_sbpro_2_decoder
+adpcm_sbpro_3_decoder
+adpcm_sbpro_4_decoder
+adpcm_swf_decoder
+adpcm_thp_decoder
+adpcm_xa_decoder
+adpcm_yamaha_decoder
+ass_decoder
+dvbsub_decoder
+dvdsub_decoder
+pgssub_decoder
+srt_decoder
+xsub_decoder
+libcelt_decoder
+libdirac_decoder
+libgsm_decoder
+libgsm_ms_decoder
+libopencore_amrnb_decoder
+libopencore_amrwb_decoder
+libopenjpeg_decoder
+libschroedinger_decoder
+libspeex_decoder
+libvpx_decoder'
+demuxers_if_any='aac_demuxer
+ac3_demuxer
+aea_demuxer
+aiff_demuxer
+amr_demuxer
+anm_demuxer
+apc_demuxer
+ape_demuxer
+applehttp_demuxer
+asf_demuxer
+ass_demuxer
+au_demuxer
+avi_demuxer
+avisynth_demuxer
+avs_demuxer
+bethsoftvid_demuxer
+bfi_demuxer
+bink_demuxer
+c93_demuxer
+caf_demuxer
+cavsvideo_demuxer
+cdg_demuxer
+daud_demuxer
+dfa_demuxer
+dirac_demuxer
+dnxhd_demuxer
+dsicin_demuxer
+dts_demuxer
+dv_demuxer
+dxa_demuxer
+ea_demuxer
+ea_cdata_demuxer
+eac3_demuxer
+ffm_demuxer
+ffmetadata_demuxer
+filmstrip_demuxer
+flac_demuxer
+flic_demuxer
+flv_demuxer
+fourxm_demuxer
+g722_demuxer
+gsm_demuxer
+gxf_demuxer
+h261_demuxer
+h263_demuxer
+h264_demuxer
+idcin_demuxer
+iff_demuxer
+image2_demuxer
+image2pipe_demuxer
+ingenient_demuxer
+ipmovie_demuxer
+iss_demuxer
+iv8_demuxer
+ivf_demuxer
+jv_demuxer
+lmlm4_demuxer
+lxf_demuxer
+m4v_demuxer
+matroska_demuxer
+microdvd_demuxer
+mjpeg_demuxer
+mlp_demuxer
+mm_demuxer
+mmf_demuxer
+mov_demuxer
+mp3_demuxer
+mpc_demuxer
+mpc8_demuxer
+mpegps_demuxer
+mpegts_demuxer
+mpegtsraw_demuxer
+mpegvideo_demuxer
+msnwc_tcp_demuxer
+mtv_demuxer
+mvi_demuxer
+mxf_demuxer
+mxg_demuxer
+nc_demuxer
+nsv_demuxer
+nut_demuxer
+nuv_demuxer
+ogg_demuxer
+oma_demuxer
+pcm_alaw_demuxer
+pcm_mulaw_demuxer
+pcm_f64be_demuxer
+pcm_f64le_demuxer
+pcm_f32be_demuxer
+pcm_f32le_demuxer
+pcm_s32be_demuxer
+pcm_s32le_demuxer
+pcm_s24be_demuxer
+pcm_s24le_demuxer
+pcm_s16be_demuxer
+pcm_s16le_demuxer
+pcm_s8_demuxer
+pcm_u32be_demuxer
+pcm_u32le_demuxer
+pcm_u24be_demuxer
+pcm_u24le_demuxer
+pcm_u16be_demuxer
+pcm_u16le_demuxer
+pcm_u8_demuxer
+pmp_demuxer
+pva_demuxer
+qcp_demuxer
+r3d_demuxer
+rawvideo_demuxer
+rl2_demuxer
+rm_demuxer
+roq_demuxer
+rpl_demuxer
+rso_demuxer
+rtp_demuxer
+rtsp_demuxer
+sap_demuxer
+sdp_demuxer
+segafilm_demuxer
+shorten_demuxer
+siff_demuxer
+smacker_demuxer
+sol_demuxer
+sox_demuxer
+spdif_demuxer
+srt_demuxer
+str_demuxer
+swf_demuxer
+thp_demuxer
+tiertexseq_demuxer
+tmv_demuxer
+truehd_demuxer
+tta_demuxer
+txd_demuxer
+tty_demuxer
+vc1_demuxer
+vc1t_demuxer
+vmd_demuxer
+voc_demuxer
+vqf_demuxer
+w64_demuxer
+wav_demuxer
+wc3_demuxer
+wsaud_demuxer
+wsvqa_demuxer
+wtv_demuxer
+wv_demuxer
+xa_demuxer
+xwma_demuxer
+yop_demuxer
+yuv4mpegpipe_demuxer
+libnut_demuxer'
+dep='yuv4mpegpipe'
+dfa_decoder='yes'
+dfa_demuxer='yes'
+dirac_demuxer='yes'
+dirac_demuxer_select='dirac_parser'
+dirac_muxer='yes'
+dirac_parser='yes'
+dnxhd_1080i_test='yes'
+dnxhd_1080i_test_deps='dnxhd_encoder dnxhd_decoder'
+dnxhd_720p_rd_test='yes'
+dnxhd_720p_rd_test_deps='dnxhd_encoder dnxhd_decoder'
+dnxhd_720p_test='yes'
+dnxhd_720p_test_deps='dnxhd_encoder dnxhd_decoder'
+dnxhd_decoder='yes'
+dnxhd_demuxer='yes'
+dnxhd_encoder='yes'
+dnxhd_encoder_select='aandct'
+dnxhd_muxer='yes'
+dnxhd_parser='yes'
+doc='yes'
+doc_deps='texi2html'
+dpx_decoder='yes'
+dpx_encoder='yes'
+drawbox_filter='yes'
+drawtext_filter='yes'
+drawtext_filter_deps='libfreetype'
+dshow_indev='yes'
+dshow_indev_deps='IBaseFilter'
+dshow_indev_extralibs='-lpsapi -lole32 -lstrmiids -luuid'
+dsicin_demuxer='yes'
+dsicinaudio_decoder='yes'
+dsicinvideo_decoder='yes'
+dts_demuxer='yes'
+dts_muxer='yes'
+dump_extradata_bsf='yes'
+dv1394_indev='yes'
+dv1394_indev_deps='dv1394 dv_demuxer'
+dv50_test='yes'
+dv50_test_deps='dvvideo_encoder dvvideo_decoder'
+dv_demuxer='yes'
+dv_fmt_test='yes'
+dv_fmt_test_deps='dv_muxer dv_demuxer'
+dv_muxer='yes'
+dv_test='yes'
+dv_test_deps='dvvideo_encoder dvvideo_decoder'
+dvbsub_decoder='yes'
+dvbsub_encoder='yes'
+dvbsub_parser='yes'
+dvdsub_decoder='yes'
+dvdsub_encoder='yes'
+dvdsub_parser='yes'
+dvvideo_decoder='yes'
+dvvideo_encoder='yes'
+dxa_decoder='yes'
+dxa_decoder_select='zlib'
+dxa_demuxer='yes'
+ea_cdata_demuxer='yes'
+ea_demuxer='yes'
+eac3_decoder='yes'
+eac3_decoder_select='ac3_decoder'
+eac3_demuxer='yes'
+eac3_demuxer_select='ac3_parser'
+eac3_encoder='yes'
+eac3_encoder_select='mdct ac3dsp'
+eac3_muxer='yes'
+eacmv_decoder='yes'
+eamad_decoder='yes'
+eamad_decoder_select='aandct'
+eatgq_decoder='yes'
+eatgq_decoder_select='aandct'
+eatgv_decoder='yes'
+eatqi_decoder='yes'
+eatqi_decoder_select='aandct'
+eightbps_decoder='yes'
+eightsvx_exp_decoder='yes'
+eightsvx_fib_decoder='yes'
+eightsvx_raw_decoder='yes'
+encoders_if_any='a64multi_encoder
+a64multi5_encoder
+asv1_encoder
+asv2_encoder
+bmp_encoder
+dnxhd_encoder
+dpx_encoder
+dvvideo_encoder
+ffv1_encoder
+ffvhuff_encoder
+flashsv_encoder
+flashsv2_encoder
+flv_encoder
+gif_encoder
+h261_encoder
+h263_encoder
+h263p_encoder
+huffyuv_encoder
+jpegls_encoder
+ljpeg_encoder
+mjpeg_encoder
+mpeg1video_encoder
+mpeg2video_encoder
+mpeg4_encoder
+msmpeg4v2_encoder
+msmpeg4v3_encoder
+msvideo1_encoder
+pam_encoder
+pbm_encoder
+pcx_encoder
+pgm_encoder
+pgmyuv_encoder
+png_encoder
+ppm_encoder
+qtrle_encoder
+rawvideo_encoder
+roq_encoder
+rv10_encoder
+rv20_encoder
+sgi_encoder
+snow_encoder
+svq1_encoder
+targa_encoder
+tiff_encoder
+v210_encoder
+wmv1_encoder
+wmv2_encoder
+zlib_encoder
+zmbv_encoder
+aac_encoder
+ac3_encoder
+ac3_fixed_encoder
+ac3_float_encoder
+alac_encoder
+dca_encoder
+eac3_encoder
+flac_encoder
+mp2_encoder
+nellymoser_encoder
+ra_144_encoder
+sonic_encoder
+sonic_ls_encoder
+vorbis_encoder
+wmav1_encoder
+wmav2_encoder
+pcm_alaw_encoder
+pcm_f32be_encoder
+pcm_f32le_encoder
+pcm_f64be_encoder
+pcm_f64le_encoder
+pcm_mulaw_encoder
+pcm_s8_encoder
+pcm_s16be_encoder
+pcm_s16le_encoder
+pcm_s24be_encoder
+pcm_s24daud_encoder
+pcm_s24le_encoder
+pcm_s32be_encoder
+pcm_s32le_encoder
+pcm_u8_encoder
+pcm_u16be_encoder
+pcm_u16le_encoder
+pcm_u24be_encoder
+pcm_u24le_encoder
+pcm_u32be_encoder
+pcm_u32le_encoder
+pcm_zork_encoder
+roq_dpcm_encoder
+adpcm_adx_encoder
+adpcm_g722_encoder
+adpcm_g726_encoder
+adpcm_ima_qt_encoder
+adpcm_ima_wav_encoder
+adpcm_ms_encoder
+adpcm_swf_encoder
+adpcm_yamaha_encoder
+ass_encoder
+dvbsub_encoder
+dvdsub_encoder
+srt_encoder
+xsub_encoder
+libdirac_encoder
+libfaac_encoder
+libgsm_encoder
+libgsm_ms_encoder
+libmp3lame_encoder
+libopencore_amrnb_encoder
+libschroedinger_encoder
+libtheora_encoder
+libvo_aacenc_encoder
+libvo_amrwbenc_encoder
+libvorbis_encoder
+libvpx_encoder
+libx264_encoder
+libxavs_encoder
+libxvid_encoder'
+error_test='yes'
+error_test_deps='mpeg4_encoder mpeg4_decoder'
+escape124_decoder='yes'
+fade_filter='yes'
+fast_64bit_if_any='alpha ia64 mips64 parisc64 ppc64 sparc64 x86_64'
+fast_clz_if_any='alpha armv5te avr32 mips ppc x86'
+fast_unaligned_if_any='armv6 ppc x86'
+fastdiv='yes'
+fbdev_indev='yes'
+fbdev_indev_deps='linux_fb_h'
+ffm_demuxer='yes'
+ffm_muxer='yes'
+ffm_test='yes'
+ffm_test_deps='ffm_muxer ffm_demuxer'
+ffmetadata_demuxer='yes'
+ffmetadata_muxer='yes'
+ffmpeg='yes'
+ffmpeg_deps='avcodec avformat swscale'
+ffmpeg_select='buffer_filter'
+ffplay='no'
+ffplay_deps='avcodec avformat swscale sdl'
+ffplay_select='rdft'
+ffprobe='yes'
+ffprobe_deps='avcodec avformat'
+ffserver='yes'
+ffserver_deps='avformat ffm_muxer fork rtp_protocol rtsp_demuxer'
+ffserver_extralibs='$ldl'
+ffv1_decoder='yes'
+ffv1_decoder_select='golomb'
+ffv1_encoder='yes'
+ffv1_test='yes'
+ffv1_test_deps='ffv1_encoder ffv1_decoder'
+ffvhuff_decoder='yes'
+ffvhuff_encoder='yes'
+fieldorder_filter='yes'
+fifo_filter='yes'
+file_protocol='yes'
+filmstrip_demuxer='yes'
+filmstrip_muxer='yes'
+filters_if_any='anull_filter
+anullsrc_filter
+anullsink_filter
+blackframe_filter
+copy_filter
+crop_filter
+cropdetect_filter
+drawbox_filter
+drawtext_filter
+fade_filter
+fieldorder_filter
+fifo_filter
+format_filter
+frei0r_filter
+gradfun_filter
+hflip_filter
+hqdn3d_filter
+lut_filter
+lutrgb_filter
+lutyuv_filter
+mp_filter
+negate_filter
+noformat_filter
+null_filter
+ocv_filter
+overlay_filter
+pad_filter
+pixdesctest_filter
+scale_filter
+select_filter
+setdar_filter
+setpts_filter
+setsar_filter
+settb_filter
+showinfo_filter
+slicify_filter
+split_filter
+transpose_filter
+unsharp_filter
+vflip_filter
+yadif_filter
+buffer_filter
+color_filter
+frei0r_src_filter
+movie_filter
+nullsrc_filter
+buffersink_filter
+nullsink_filter'
+flac_decoder='yes'
+flac_decoder_select='golomb'
+flac_demuxer='yes'
+flac_demuxer_select='flac_parser'
+flac_encoder='yes'
+flac_encoder_select='golomb lpc'
+flac_muxer='yes'
+flac_parser='yes'
+flac_test='yes'
+flac_test_deps='flac_encoder flac_decoder'
+flashsv2_encoder='yes'
+flashsv2_encoder_select='zlib'
+flashsv2_test='yes'
+flashsv_decoder='yes'
+flashsv_decoder_select='zlib'
+flashsv_encoder='yes'
+flashsv_encoder_select='zlib'
+flashsv_test='yes'
+flashsv_test_deps='flashsv_encoder flashsv_decoder'
+flic_decoder='yes'
+flic_demuxer='yes'
+flv_decoder='yes'
+flv_decoder_select='h263_decoder'
+flv_demuxer='yes'
+flv_encoder='yes'
+flv_encoder_select='h263_encoder'
+flv_fmt_test='yes'
+flv_fmt_test_deps='flv_muxer flv_demuxer'
+flv_muxer='yes'
+flv_test='yes'
+flv_test_deps='flv_encoder flv_decoder'
+format_filter='yes'
+fourxm_decoder='yes'
+fourxm_demuxer='yes'
+framecrc_muxer='yes'
+framemd5_muxer='yes'
+fraps_decoder='yes'
+fraps_decoder_select='huffman'
+frei0r_filter='yes'
+frei0r_filter_deps='frei0r dlopen strtok_r'
+frei0r_src_filter='yes'
+frei0r_src_filter_deps='frei0r dlopen strtok_r'
+frwu_decoder='yes'
+g722_demuxer='yes'
+g722_muxer='yes'
+g726_test='yes'
+g726_test_deps='adpcm_g726_encoder adpcm_g726_decoder'
+gif_decoder='yes'
+gif_encoder='yes'
+gif_muxer='yes'
+gif_test='yes'
+gif_test_deps='gif_encoder gif_decoder'
+gopher_protocol='yes'
+gopher_protocol_deps='network'
+gradfun_filter='yes'
+gsm_decoder='yes'
+gsm_demuxer='yes'
+gsm_ms_decoder='yes'
+gxf_demuxer='yes'
+gxf_muxer='yes'
+gxf_test='yes'
+gxf_test_deps='gxf_muxer gxf_demuxer'
+h261_decoder='yes'
+h261_demuxer='yes'
+h261_encoder='yes'
+h261_encoder_select='aandct'
+h261_muxer='yes'
+h261_parser='yes'
+h261_test='yes'
+h261_test_deps='h261_encoder h261_decoder'
+h263_decoder='yes'
+h263_decoder_select='h263_parser'
+h263_demuxer='yes'
+h263_encoder='yes'
+h263_encoder_select='aandct'
+h263_muxer='yes'
+h263_parser='yes'
+h263_test='yes'
+h263_test_deps='h263_encoder h263_decoder'
+h263_vaapi_hwaccel='yes'
+h263_vaapi_hwaccel_select='vaapi h263_decoder'
+h263i_decoder='yes'
+h263i_decoder_select='h263_decoder'
+h263p_encoder='yes'
+h263p_encoder_select='h263_encoder'
+h263p_test='yes'
+h263p_test_deps='h263_encoder h263_decoder'
+h264_crystalhd_decoder='yes'
+h264_crystalhd_decoder_select='crystalhd h264_mp4toannexb_bsf h264_parser'
+h264_decoder='yes'
+h264_decoder_select='golomb h264dsp h264pred'
+h264_demuxer='yes'
+h264_dxva2_hwaccel='yes'
+h264_dxva2_hwaccel_deps='dxva2api_h'
+h264_dxva2_hwaccel_select='dxva2 h264_decoder'
+h264_mp4toannexb_bsf='yes'
+h264_muxer='yes'
+h264_parser='yes'
+h264_parser_select='golomb h264dsp h264pred'
+h264_vaapi_hwaccel='yes'
+h264_vaapi_hwaccel_select='vaapi'
+h264_vdpau_decoder='yes'
+h264_vdpau_decoder_select='vdpau h264_decoder'
+hflip_filter='yes'
+host_cc_default='gcc'
+host_cflags='-D_ISOC99_SOURCE -O3 -g'
+host_libs='-lm'
+host_os='linux'
+hqdn3d_filter='yes'
+hqdn3d_filter_deps='gpl'
+http_protocol='yes'
+http_protocol_deps='network'
+http_protocol_select='tcp_protocol'
+huffyuv_decoder='yes'
+huffyuv_encoder='yes'
+huffyuv_test='yes'
+huffyuv_test_deps='huffyuv_encoder huffyuv_decoder'
+hwaccels_if_any='h263_vaapi_hwaccel
+h264_dxva2_hwaccel
+h264_vaapi_hwaccel
+mpeg1_vdpau_hwaccel
+mpeg2_dxva2_hwaccel
+mpeg2_vaapi_hwaccel
+mpeg2_vdpau_hwaccel
+mpeg4_vaapi_hwaccel
+vc1_dxva2_hwaccel
+vc1_vaapi_hwaccel
+wmv3_dxva2_hwaccel
+wmv3_vaapi_hwaccel'
+idcin_decoder='yes'
+idcin_demuxer='yes'
+iff_byterun1_decoder='yes'
+iff_demuxer='yes'
+iff_ilbm_decoder='yes'
+image2_demuxer='yes'
+image2_muxer='yes'
+image2pipe_demuxer='yes'
+image2pipe_muxer='yes'
+imc_decoder='yes'
+imc_decoder_select='fft mdct sinewin'
+imx_dump_header_bsf='yes'
+incdir_default='${prefix}/include'
+indeo2_decoder='yes'
+indeo3_decoder='yes'
+indeo5_decoder='yes'
+indevs_if_any='alsa_indev
+bktr_indev
+dshow_indev
+dv1394_indev
+fbdev_indev
+jack_indev
+oss_indev
+sndio_indev
+v4l2_indev
+v4l_indev
+vfwcap_indev
+x11_grab_device_indev
+libdc1394_indev'
+ingenient_demuxer='yes'
+inline_asm_deps='!tms470'
+install='install'
+interplay_dpcm_decoder='yes'
+interplay_video_decoder='yes'
+ipmovie_demuxer='yes'
+ipod_muxer='yes'
+ipod_muxer_select='mov_muxer'
+iss_demuxer='yes'
+iv8_demuxer='yes'
+ivf_demuxer='yes'
+ivf_muxer='yes'
+iwmmxt='yes'
+iwmmxt_deps='arm'
+jack_indev='yes'
+jack_indev_deps='jack_jack_h sem_timedwait'
+jpeg2000_decoder='yes'
+jpegls_decoder='yes'
+jpegls_decoder_select='golomb'
+jpegls_encoder='yes'
+jpegls_encoder_select='golomb'
+jpegls_test='yes'
+jpegls_test_deps='jpegls_encoder jpegls_decoder'
+jpg_test='yes'
+jpg_test_deps='mjpeg_encoder mjpeg_decoder'
+jv_decoder='yes'
+jv_demuxer='yes'
+kgv1_decoder='yes'
+kmvc_decoder='yes'
+l='--arch='
+lagarith_decoder='yes'
+libcelt_decoder='yes'
+libcelt_decoder_deps='libcelt'
+libdc1394_indev='yes'
+libdc1394_indev_deps='libdc1394'
+libdir_default='${prefix}/lib'
+libdirac_decoder='yes'
+libdirac_decoder_deps='libdirac !libschroedinger'
+libdirac_encoder='yes'
+libdirac_encoder_deps='libdirac'
+libfaac_encoder='yes'
+libfaac_encoder_deps='libfaac'
+libgsm_decoder='yes'
+libgsm_decoder_deps='libgsm'
+libgsm_encoder='yes'
+libgsm_encoder_deps='libgsm'
+libgsm_ms_decoder='yes'
+libgsm_ms_decoder_deps='libgsm'
+libgsm_ms_encoder='yes'
+libgsm_ms_encoder_deps='libgsm'
+libmp3lame_encoder='yes'
+libmp3lame_encoder_deps='libmp3lame'
+libnut_demuxer='yes'
+libnut_demuxer_deps='libnut'
+libnut_muxer='yes'
+libnut_muxer_deps='libnut'
+libopencore_amrnb_decoder='yes'
+libopencore_amrnb_decoder_deps='libopencore_amrnb'
+libopencore_amrnb_encoder='yes'
+libopencore_amrnb_encoder_deps='libopencore_amrnb'
+libopencore_amrwb_decoder='yes'
+libopencore_amrwb_decoder_deps='libopencore_amrwb'
+libopenjpeg_decoder='yes'
+libopenjpeg_decoder_deps='libopenjpeg'
+libschroedinger_decoder='yes'
+libschroedinger_decoder_deps='libschroedinger'
+libschroedinger_encoder='yes'
+libschroedinger_encoder_deps='libschroedinger'
+libspeex_decoder='yes'
+libspeex_decoder_deps='libspeex'
+libtheora_encoder='yes'
+libtheora_encoder_deps='libtheora'
+libvo_aacenc_encoder='yes'
+libvo_aacenc_encoder_deps='libvo_aacenc'
+libvo_amrwbenc_encoder='yes'
+libvo_amrwbenc_encoder_deps='libvo_amrwbenc'
+libvorbis_encoder='yes'
+libvorbis_encoder_deps='libvorbis'
+libvpx_decoder='yes'
+libvpx_decoder_deps='libvpx'
+libvpx_encoder='yes'
+libvpx_encoder_deps='libvpx'
+libx264_encoder='yes'
+libx264_encoder_deps='libx264'
+libxavs_encoder='yes'
+libxavs_encoder_deps='libxavs'
+libxvid_encoder='yes'
+libxvid_encoder_deps='libxvid'
+ljpeg_encoder='yes'
+ljpeg_encoder_select='aandct'
+ljpeg_test='yes'
+ljpeg_test_deps='mjpeg_encoder mjpeg_decoder'
+lmlm4_demuxer='yes'
+ln_s='ln -sf'
+loco_decoder='yes'
+loco_decoder_select='golomb'
+logfile='config.log'
+lut_filter='yes'
+lutrgb_filter='yes'
+lutyuv_filter='yes'
+lxf_demuxer='yes'
+m4v_demuxer='yes'
+m4v_muxer='yes'
+mace3_decoder='yes'
+mace6_decoder='yes'
+mandir_default='${prefix}/share/man'
+matroska_audio_muxer='yes'
+matroska_audio_muxer_select='matroska_muxer'
+matroska_demuxer='yes'
+matroska_demuxer_suggest='zlib bzlib'
+matroska_muxer='yes'
+md5_muxer='yes'
+md5_protocol='yes'
+mdct_select='fft'
+mdec_decoder='yes'
+microdvd_demuxer='yes'
+microdvd_muxer='yes'
+mimic_decoder='yes'
+mjpeg2jpeg_bsf='yes'
+mjpeg_decoder='yes'
+mjpeg_demuxer='yes'
+mjpeg_encoder='yes'
+mjpeg_encoder_select='aandct'
+mjpeg_muxer='yes'
+mjpeg_parser='yes'
+mjpeg_test='yes'
+mjpeg_test_deps='mjpeg_encoder mjpeg_decoder'
+mjpega_dump_header_bsf='yes'
+mjpegb_decoder='yes'
+mkv_test='yes'
+mkv_test_deps='matroska_muxer matroska_demuxer'
+mlp_decoder='yes'
+mlp_decoder_select='mlp_parser'
+mlp_demuxer='yes'
+mlp_muxer='yes'
+mlp_parser='yes'
+mm_demuxer='yes'
+mmf_demuxer='yes'
+mmf_muxer='yes'
+mmf_test='yes'
+mmf_test_deps='mmf_muxer mmf_demuxer'
+mmi='yes'
+mmi_deps='mips'
+mmsh_protocol='yes'
+mmsh_protocol_select='http_protocol'
+mmst_protocol='yes'
+mmst_protocol_deps='network'
+mmvideo_decoder='yes'
+mmx='yes'
+mmx2='yes'
+mmx2_deps='mmx'
+mmx_deps='x86'
+motionpixels_decoder='yes'
+mov2textsub_bsf='yes'
+mov_demuxer='yes'
+mov_demuxer_suggest='zlib'
+mov_muxer='yes'
+mov_test='yes'
+mov_test_deps='mov_muxer mov_demuxer'
+movie_filter='yes'
+movie_filter_deps='avcodec avformat'
+mp1_decoder='yes'
+mp1_decoder_select='mpegaudiodsp'
+mp1float_decoder='yes'
+mp1float_decoder_select='mpegaudiodsp'
+mp2_decoder='yes'
+mp2_decoder_select='mpegaudiodsp'
+mp2_encoder='yes'
+mp2_muxer='yes'
+mp2_test='yes'
+mp2_test_deps='mp2_encoder mp2_decoder'
+mp2float_decoder='yes'
+mp2float_decoder_select='mpegaudiodsp'
+mp3_decoder='yes'
+mp3_decoder_select='mpegaudiodsp'
+mp3_demuxer='yes'
+mp3_demuxer_select='mpegaudio_parser'
+mp3_header_compress_bsf='yes'
+mp3_header_decompress_bsf='yes'
+mp3_muxer='yes'
+mp3adu_decoder='yes'
+mp3adu_decoder_select='mpegaudiodsp'
+mp3adufloat_decoder='yes'
+mp3adufloat_decoder_select='mpegaudiodsp'
+mp3float_decoder='yes'
+mp3float_decoder_select='mpegaudiodsp'
+mp3on4_decoder='yes'
+mp3on4_decoder_select='mpegaudiodsp'
+mp3on4float_decoder='yes'
+mp3on4float_decoder_select='mpegaudiodsp'
+mp4_muxer='yes'
+mp4_muxer_select='mov_muxer'
+mp_filter='yes'
+mp_filter_deps='gpl avcodec'
+mpc7_decoder='yes'
+mpc8_decoder='yes'
+mpc8_demuxer='yes'
+mpc_demuxer='yes'
+mpeg1_vdpau_decoder='yes'
+mpeg1_vdpau_decoder_select='vdpau mpeg1video_decoder'
+mpeg1_vdpau_hwaccel='yes'
+mpeg1_vdpau_hwaccel_select='vdpau mpeg1video_decoder'
+mpeg1b_test='yes'
+mpeg1b_test_deps='mpeg1video_encoder mpeg1video_decoder'
+mpeg1system_muxer='yes'
+mpeg1vcd_muxer='yes'
+mpeg1video_decoder='yes'
+mpeg1video_encoder='yes'
+mpeg1video_encoder_select='aandct'
+mpeg1video_muxer='yes'
+mpeg2_crystalhd_decoder='yes'
+mpeg2_crystalhd_decoder_select='crystalhd'
+mpeg2_dxva2_hwaccel='yes'
+mpeg2_dxva2_hwaccel_deps='dxva2api_h'
+mpeg2_dxva2_hwaccel_select='dxva2 mpeg2video_decoder'
+mpeg2_test='yes'
+mpeg2_test_deps='mpeg2video_encoder mpeg2video_decoder'
+mpeg2_vaapi_hwaccel='yes'
+mpeg2_vaapi_hwaccel_select='vaapi mpeg2video_decoder'
+mpeg2_vdpau_hwaccel='yes'
+mpeg2_vdpau_hwaccel_select='vdpau mpeg2video_decoder'
+mpeg2dvd_muxer='yes'
+mpeg2svcd_muxer='yes'
+mpeg2thread_test='yes'
+mpeg2thread_test_deps='mpeg2video_encoder mpeg2video_decoder'
+mpeg2video_decoder='yes'
+mpeg2video_encoder='yes'
+mpeg2video_encoder_select='aandct'
+mpeg2video_muxer='yes'
+mpeg2vob_muxer='yes'
+mpeg4_crystalhd_decoder='yes'
+mpeg4_crystalhd_decoder_select='crystalhd'
+mpeg4_decoder='yes'
+mpeg4_decoder_select='h263_decoder mpeg4video_parser'
+mpeg4_encoder='yes'
+mpeg4_encoder_select='h263_encoder'
+mpeg4_test='yes'
+mpeg4_test_deps='mpeg4_encoder mpeg4_decoder'
+mpeg4_vaapi_hwaccel='yes'
+mpeg4_vaapi_hwaccel_select='vaapi mpeg4_decoder'
+mpeg4_vdpau_decoder='yes'
+mpeg4_vdpau_decoder_select='vdpau mpeg4_decoder'
+mpeg4adv_test='yes'
+mpeg4adv_test_deps='mpeg4_encoder mpeg4_decoder'
+mpeg4nr_test='yes'
+mpeg4nr_test_deps='mpeg4_encoder mpeg4_decoder'
+mpeg4thread_test='yes'
+mpeg4thread_test_deps='mpeg4_encoder mpeg4_decoder'
+mpeg4video_parser='yes'
+mpeg_test='yes'
+mpeg_test_deps='mpeg1video_encoder mpeg1video_decoder'
+mpeg_vdpau_decoder='yes'
+mpeg_vdpau_decoder_select='vdpau mpegvideo_decoder'
+mpeg_xvmc_decoder='yes'
+mpeg_xvmc_decoder_deps='X11_extensions_XvMClib_h'
+mpeg_xvmc_decoder_select='mpegvideo_decoder'
+mpegaudio_parser='yes'
+mpegaudiodsp_select='dct'
+mpegps_demuxer='yes'
+mpegts_demuxer='yes'
+mpegts_muxer='yes'
+mpegtsraw_demuxer='yes'
+mpegtsraw_demuxer_select='mpegts_demuxer'
+mpegvideo_decoder='yes'
+mpegvideo_demuxer='yes'
+mpegvideo_parser='yes'
+mpg_test='yes'
+mpg_test_deps='mpeg1system_muxer mpegps_demuxer'
+mpjpeg_muxer='yes'
+msmpeg4_crystalhd_decoder='yes'
+msmpeg4_crystalhd_decoder_select='crystalhd'
+msmpeg4_test='yes'
+msmpeg4_test_deps='msmpeg4v3_encoder msmpeg4v3_decoder'
+msmpeg4v1_decoder='yes'
+msmpeg4v1_decoder_select='h263_decoder'
+msmpeg4v1_encoder_select='h263_encoder'
+msmpeg4v2_decoder='yes'
+msmpeg4v2_decoder_select='h263_decoder'
+msmpeg4v2_encoder='yes'
+msmpeg4v2_encoder_select='h263_encoder'
+msmpeg4v2_test='yes'
+msmpeg4v2_test_deps='msmpeg4v2_encoder msmpeg4v2_decoder'
+msmpeg4v3_decoder='yes'
+msmpeg4v3_decoder_select='h263_decoder'
+msmpeg4v3_encoder='yes'
+msmpeg4v3_encoder_select='h263_encoder'
+msnwc_tcp_demuxer='yes'
+msrle_decoder='yes'
+msvideo1_decoder='yes'
+msvideo1_encoder='yes'
+msvideo1_test='yes'
+mszh_decoder='yes'
+mtv_demuxer='yes'
+mulaw_test='yes'
+mulaw_test_deps='pcm_mulaw_muxer pcm_mulaw_demuxer'
+muxers_if_any='a64_muxer
+ac3_muxer
+adts_muxer
+aiff_muxer
+amr_muxer
+asf_muxer
+ass_muxer
+asf_stream_muxer
+au_muxer
+avi_muxer
+avm2_muxer
+caf_muxer
+cavsvideo_muxer
+crc_muxer
+daud_muxer
+dirac_muxer
+dnxhd_muxer
+dts_muxer
+dv_muxer
+eac3_muxer
+ffm_muxer
+ffmetadata_muxer
+filmstrip_muxer
+flac_muxer
+flv_muxer
+framecrc_muxer
+framemd5_muxer
+g722_muxer
+gif_muxer
+gxf_muxer
+h261_muxer
+h263_muxer
+h264_muxer
+image2_muxer
+image2pipe_muxer
+ipod_muxer
+ivf_muxer
+m4v_muxer
+md5_muxer
+matroska_muxer
+matroska_audio_muxer
+microdvd_muxer
+mjpeg_muxer
+mlp_muxer
+mmf_muxer
+mov_muxer
+mp2_muxer
+mp3_muxer
+mp4_muxer
+mpeg1system_muxer
+mpeg1vcd_muxer
+mpeg1video_muxer
+mpeg2dvd_muxer
+mpeg2svcd_muxer
+mpeg2video_muxer
+mpeg2vob_muxer
+mpegts_muxer
+mpjpeg_muxer
+mxf_muxer
+mxf_d10_muxer
+null_muxer
+nut_muxer
+ogg_muxer
+pcm_alaw_muxer
+pcm_mulaw_muxer
+pcm_f64be_muxer
+pcm_f64le_muxer
+pcm_f32be_muxer
+pcm_f32le_muxer
+pcm_s32be_muxer
+pcm_s32le_muxer
+pcm_s24be_muxer
+pcm_s24le_muxer
+pcm_s16be_muxer
+pcm_s16le_muxer
+pcm_s8_muxer
+pcm_u32be_muxer
+pcm_u32le_muxer
+pcm_u24be_muxer
+pcm_u24le_muxer
+pcm_u16be_muxer
+pcm_u16le_muxer
+pcm_u8_muxer
+psp_muxer
+rawvideo_muxer
+rm_muxer
+roq_muxer
+rso_muxer
+rtp_muxer
+rtsp_muxer
+sap_muxer
+sox_muxer
+spdif_muxer
+srt_muxer
+swf_muxer
+tg2_muxer
+tgp_muxer
+truehd_muxer
+vc1t_muxer
+voc_muxer
+wav_muxer
+webm_muxer
+yuv4mpegpipe_muxer
+libnut_muxer'
+mvi_demuxer='yes'
+mxf_d10_muxer='yes'
+mxf_d10_muxer_select='mxf_muxer'
+mxf_demuxer='yes'
+mxf_muxer='yes'
+mxf_test='yes'
+mxf_test_deps='mxf_muxer mxf_demuxer'
+mxg_demuxer='yes'
+mxpeg_decoder='yes'
+n='protocols'
+name='yuv4mpeg'
+nc_demuxer='yes'
+need_memalign='altivec neon sse'
+negate_filter='yes'
+negate_filter_deps='lut_filter'
+nellymoser_decoder='yes'
+nellymoser_decoder_select='mdct sinewin'
+nellymoser_encoder='yes'
+nellymoser_encoder_select='mdct sinewin'
+neon='yes'
+neon_deps='arm'
+network='yes'
+nm_default='nm'
+nm_opts='-g'
+noformat_filter='yes'
+nogas=':'
+noise_bsf='yes'
+nsv_demuxer='yes'
+null_filter='yes'
+null_muxer='yes'
+null_test='yes'
+nullsink_filter='yes'
+nullsrc_filter='yes'
+nut_demuxer='yes'
+nut_muxer='yes'
+nut_test='yes'
+nut_test_deps='nut_muxer nut_demuxer'
+nuv_decoder='yes'
+nuv_demuxer='yes'
+objformat='elf'
+ocv_filter='yes'
+ocv_filter_deps='libopencv'
+ogg_demuxer='yes'
+ogg_demuxer_select='golomb'
+ogg_muxer='yes'
+ogg_test='yes'
+ogg_test_deps='ogg_muxer ogg_demuxer'
+oma_demuxer='yes'
+op='='
+opt='--arch=arm'
+optimizations='yes'
+option='cross_compile'
+optname='arch'
+optval='arm'
+oss_indev='yes'
+oss_indev_deps_any='soundcard_h sys_soundcard_h'
+oss_outdev='yes'
+oss_outdev_deps_any='soundcard_h sys_soundcard_h'
+outdevs_if_any='alsa_outdev
+oss_outdev
+sdl_outdev
+sndio_outdev'
+overlay_filter='yes'
+pad_filter='yes'
+pam_decoder='yes'
+pam_encoder='yes'
+parsers_if_any='aac_parser
+aac_latm_parser
+ac3_parser
+cavsvideo_parser
+dca_parser
+dirac_parser
+dnxhd_parser
+dvbsub_parser
+dvdsub_parser
+flac_parser
+h261_parser
+h263_parser
+h264_parser
+mjpeg_parser
+mlp_parser
+mpeg4video_parser
+mpegaudio_parser
+mpegvideo_parser
+pnm_parser
+vc1_parser
+vp3_parser
+vp8_parser'
+pbm_decoder='yes'
+pbm_encoder='yes'
+pbmpipe_test='yes'
+pbmpipe_test_deps='pbm_encoder pbm_decoder'
+pcm_alaw_decoder='yes'
+pcm_alaw_demuxer='yes'
+pcm_alaw_encoder='yes'
+pcm_alaw_muxer='yes'
+pcm_bluray_decoder='yes'
+pcm_dvd_decoder='yes'
+pcm_f32be_decoder='yes'
+pcm_f32be_demuxer='yes'
+pcm_f32be_encoder='yes'
+pcm_f32be_muxer='yes'
+pcm_f32le_decoder='yes'
+pcm_f32le_demuxer='yes'
+pcm_f32le_encoder='yes'
+pcm_f32le_muxer='yes'
+pcm_f64be_decoder='yes'
+pcm_f64be_demuxer='yes'
+pcm_f64be_encoder='yes'
+pcm_f64be_muxer='yes'
+pcm_f64le_decoder='yes'
+pcm_f64le_demuxer='yes'
+pcm_f64le_encoder='yes'
+pcm_f64le_muxer='yes'
+pcm_lxf_decoder='yes'
+pcm_mulaw_decoder='yes'
+pcm_mulaw_demuxer='yes'
+pcm_mulaw_encoder='yes'
+pcm_mulaw_muxer='yes'
+pcm_s16be_decoder='yes'
+pcm_s16be_demuxer='yes'
+pcm_s16be_encoder='yes'
+pcm_s16be_muxer='yes'
+pcm_s16le_decoder='yes'
+pcm_s16le_demuxer='yes'
+pcm_s16le_encoder='yes'
+pcm_s16le_muxer='yes'
+pcm_s16le_planar_decoder='yes'
+pcm_s24be_decoder='yes'
+pcm_s24be_demuxer='yes'
+pcm_s24be_encoder='yes'
+pcm_s24be_muxer='yes'
+pcm_s24daud_decoder='yes'
+pcm_s24daud_encoder='yes'
+pcm_s24le_decoder='yes'
+pcm_s24le_demuxer='yes'
+pcm_s24le_encoder='yes'
+pcm_s24le_muxer='yes'
+pcm_s32be_decoder='yes'
+pcm_s32be_demuxer='yes'
+pcm_s32be_encoder='yes'
+pcm_s32be_muxer='yes'
+pcm_s32le_decoder='yes'
+pcm_s32le_demuxer='yes'
+pcm_s32le_encoder='yes'
+pcm_s32le_muxer='yes'
+pcm_s8_decoder='yes'
+pcm_s8_demuxer='yes'
+pcm_s8_encoder='yes'
+pcm_s8_muxer='yes'
+pcm_test='yes'
+pcm_test_deps='pcm_alaw_decoder pcm_alaw_encoder
+pcm_f32be_decoder pcm_f32be_encoder
+pcm_f32le_decoder pcm_f32le_encoder
+pcm_f64be_decoder pcm_f64be_encoder
+pcm_f64le_decoder pcm_f64le_encoder
+pcm_mulaw_decoder pcm_mulaw_encoder
+pcm_s8_decoder pcm_s8_encoder
+pcm_s16be_decoder pcm_s16be_encoder
+pcm_s16le_decoder pcm_s16le_encoder
+pcm_s24be_decoder pcm_s24be_encoder
+pcm_s24daud_decoder pcm_s24daud_encoder
+pcm_s24le_decoder pcm_s24le_encoder
+pcm_s32be_decoder pcm_s32be_encoder
+pcm_s32le_decoder pcm_s32le_encoder
+pcm_u8_decoder pcm_u8_encoder
+pcm_u16be_decoder pcm_u16be_encoder
+pcm_u16le_decoder pcm_u16le_encoder
+pcm_u24be_decoder pcm_u24be_encoder
+pcm_u24le_decoder pcm_u24le_encoder
+pcm_u32be_decoder pcm_u32be_encoder
+pcm_u32le_decoder pcm_u32le_encoder
+pcm_zork_decoder pcm_zork_encoder'
+pcm_u16be_decoder='yes'
+pcm_u16be_demuxer='yes'
+pcm_u16be_encoder='yes'
+pcm_u16be_muxer='yes'
+pcm_u16le_decoder='yes'
+pcm_u16le_demuxer='yes'
+pcm_u16le_encoder='yes'
+pcm_u16le_muxer='yes'
+pcm_u24be_decoder='yes'
+pcm_u24be_demuxer='yes'
+pcm_u24be_encoder='yes'
+pcm_u24be_muxer='yes'
+pcm_u24le_decoder='yes'
+pcm_u24le_demuxer='yes'
+pcm_u24le_encoder='yes'
+pcm_u24le_muxer='yes'
+pcm_u32be_decoder='yes'
+pcm_u32be_demuxer='yes'
+pcm_u32be_encoder='yes'
+pcm_u32be_muxer='yes'
+pcm_u32le_decoder='yes'
+pcm_u32le_demuxer='yes'
+pcm_u32le_encoder='yes'
+pcm_u32le_muxer='yes'
+pcm_u8_decoder='yes'
+pcm_u8_demuxer='yes'
+pcm_u8_encoder='yes'
+pcm_u8_muxer='yes'
+pcm_zork_decoder='yes'
+pcm_zork_encoder='yes'
+pcx_decoder='yes'
+pcx_encoder='yes'
+pcx_test='yes'
+pcx_test_deps='pcx_encoder pcx_decoder'
+pgm_decoder='yes'
+pgm_encoder='yes'
+pgm_test='yes'
+pgm_test_deps='pgm_encoder pgm_decoder'
+pgmpipe_test='yes'
+pgmpipe_test_deps='pgm_encoder pgm_decoder'
+pgmyuv_decoder='yes'
+pgmyuv_encoder='yes'
+pgssub_decoder='yes'
+pictor_decoder='yes'
+pipe_protocol='yes'
+pixdesc_be_test='yes'
+pixdesc_be_test_deps='bigendian'
+pixdesc_le_test='yes'
+pixdesc_le_test_deps='!bigendian'
+pixdesctest_filter='yes'
+pixfmt_test='yes'
+pixfmt_test_deps='rawvideo_muxer rawvideo_demuxer'
+pixfmts_copy_be_test_deps='bigendian'
+pixfmts_copy_le_test='yes'
+pixfmts_copy_le_test_deps='!bigendian'
+pixfmts_crop_be_test_deps='bigendian'
+pixfmts_crop_le_test='yes'
+pixfmts_crop_le_test_deps='!bigendian'
+pixfmts_hflip_be_test_deps='bigendian'
+pixfmts_hflip_le_test='yes'
+pixfmts_hflip_le_test_deps='!bigendian'
+pixfmts_null_be_test_deps='bigendian'
+pixfmts_null_le_test='yes'
+pixfmts_null_le_test_deps='!bigendian'
+pixfmts_pad_be_test_deps='bigendian'
+pixfmts_pad_le_test='yes'
+pixfmts_pad_le_test_deps='!bigendian'
+pixfmts_scale_be_test_deps='bigendian'
+pixfmts_scale_le_test='yes'
+pixfmts_scale_le_test_deps='!bigendian'
+pixfmts_vflip_be_test_deps='bigendian'
+pixfmts_vflip_le_test='yes'
+pixfmts_vflip_le_test_deps='!bigendian'
+pkg_config_default='pkg-config'
+pmp_demuxer='yes'
+png_decoder='yes'
+png_decoder_select='zlib'
+png_encoder='yes'
+png_encoder_select='zlib'
+png_test='yes'
+png_test_deps='png_encoder png_decoder'
+pnm_parser='yes'
+postproc='yes'
+postproc_deps='gpl'
+ppc4xx='yes'
+ppc4xx_deps='ppc'
+ppm_decoder='yes'
+ppm_encoder='yes'
+ppm_test='yes'
+ppm_test_deps='ppm_encoder ppm_decoder'
+ppmpipe_test='yes'
+ppmpipe_test_deps='ppm_encoder ppm_decoder'
+prefix_default='/usr/local'
+protocols='yes'
+protocols_if_any='applehttp_protocol
+concat_protocol
+crypto_protocol
+file_protocol
+gopher_protocol
+http_protocol
+mmsh_protocol
+mmst_protocol
+md5_protocol
+pipe_protocol
+rtmp_protocol
+rtmpt_protocol
+rtmpe_protocol
+rtmpte_protocol
+rtmps_protocol
+rtp_protocol
+tcp_protocol
+udp_protocol'
+psp_muxer='yes'
+psp_muxer_select='mov_muxer'
+ptx_decoder='yes'
+pva_demuxer='yes'
+qcelp_decoder='yes'
+qcelp_decoder_select='lsp'
+qcp_demuxer='yes'
+qdm2_decoder='yes'
+qdm2_decoder_select='mdct rdft mpegaudiodsp'
+qdraw_decoder='yes'
+qpeg_decoder='yes'
+qtrle_decoder='yes'
+qtrle_encoder='yes'
+qtrle_test='yes'
+qtrlegray_test='yes'
+quotes='""'
+r='arm'
+r10k_decoder='yes'
+r210_decoder='yes'
+r3d_demuxer='yes'
+ra_144_decoder='yes'
+ra_144_encoder='yes'
+ra_144_encoder_select='lpc'
+ra_288_decoder='yes'
+ranlib='ranlib'
+rawvideo_decoder='yes'
+rawvideo_demuxer='yes'
+rawvideo_encoder='yes'
+rawvideo_muxer='yes'
+rc_test='yes'
+rc_test_deps='mpeg4_encoder mpeg4_decoder'
+rdft_select='fft'
+remove_extradata_bsf='yes'
+rgb_test='yes'
+rgb_test_deps='rawvideo_encoder rawvideo_decoder'
+rl2_decoder='yes'
+rl2_demuxer='yes'
+rm_demuxer='yes'
+rm_muxer='yes'
+rm_test='yes'
+rm_test_deps='rm_muxer rm_demuxer'
+roq_decoder='yes'
+roq_demuxer='yes'
+roq_dpcm_decoder='yes'
+roq_dpcm_encoder='yes'
+roq_encoder='yes'
+roq_muxer='yes'
+roq_test='yes'
+roq_test_deps='roq_encoder roq_decoder'
+rpl_demuxer='yes'
+rpza_decoder='yes'
+rso_demuxer='yes'
+rso_muxer='yes'
+rtmp_protocol='yes'
+rtmp_protocol_select='tcp_protocol'
+rtmpe_protocol='yes'
+rtmps_protocol='yes'
+rtmpt_protocol='yes'
+rtmpte_protocol='yes'
+rtp_demuxer='yes'
+rtp_demuxer_select='sdp_demuxer'
+rtp_muxer='yes'
+rtp_protocol='yes'
+rtp_protocol_select='udp_protocol'
+rtpdec_select='asf_demuxer rm_demuxer rtp_protocol mpegts_demuxer mov_demuxer'
+rtsp_demuxer='yes'
+rtsp_demuxer_select='http_protocol rtpdec'
+rtsp_muxer='yes'
+rtsp_muxer_select='rtp_muxer http_protocol rtp_protocol'
+rv10_decoder='yes'
+rv10_decoder_select='h263_decoder'
+rv10_encoder='yes'
+rv10_encoder_select='h263_encoder'
+rv10_test='yes'
+rv10_test_deps='rv10_encoder rv10_decoder'
+rv20_decoder='yes'
+rv20_decoder_select='h263_decoder'
+rv20_encoder='yes'
+rv20_encoder_select='h263_encoder'
+rv20_test='yes'
+rv20_test_deps='rv20_encoder rv20_decoder'
+rv30_decoder='yes'
+rv30_decoder_select='golomb h264pred'
+rv40_decoder='yes'
+rv40_decoder_select='golomb h264pred'
+s302m_decoder='yes'
+sap_demuxer='yes'
+sap_demuxer_select='sdp_demuxer'
+sap_muxer='yes'
+sap_muxer_select='rtp_muxer rtp_protocol'
+scale200_test='yes'
+scale500_test='yes'
+scale_filter='yes'
+scale_filter_deps='swscale'
+sdl_outdev='yes'
+sdl_outdev_deps='sdl'
+sdp_demuxer='yes'
+sdp_demuxer_select='rtpdec'
+seek_ac3_rm_test='yes'
+seek_adpcm_ima_wav_test='yes'
+seek_adpcm_ms_wav_test='yes'
+seek_adpcm_qt_aiff_test='yes'
+seek_adpcm_swf_flv_test='yes'
+seek_adpcm_yam_wav_test='yes'
+seek_alac_m4a_test='yes'
+seek_asv1_avi_test='yes'
+seek_asv2_avi_test='yes'
+seek_dnxhd_1080i_mov_test='yes'
+seek_dnxhd_720p_dnxhd_test='yes'
+seek_dnxhd_720p_rd_dnxhd_test='yes'
+seek_dv411_dv_test='yes'
+seek_dv50_dv_test='yes'
+seek_dv_dv_test='yes'
+seek_error_mpeg4_adv_avi_test='yes'
+seek_ffv1_avi_test='yes'
+seek_flac_flac_test='yes'
+seek_flashsv_flv_test='yes'
+seek_flv_flv_test='yes'
+seek_g726_wav_test='yes'
+seek_h261_avi_test='yes'
+seek_h263_avi_test='yes'
+seek_h263p_avi_test='yes'
+seek_huffyuv_avi_test='yes'
+seek_image_bmp_test='yes'
+seek_image_jpg_test='yes'
+seek_image_pcx_test='yes'
+seek_image_pgm_test='yes'
+seek_image_ppm_test='yes'
+seek_image_sgi_test='yes'
+seek_image_tga_test='yes'
+seek_image_tiff_test='yes'
+seek_jpegls_avi_test='yes'
+seek_lavf_aif_test='yes'
+seek_lavf_al_test='yes'
+seek_lavf_asf_test='yes'
+seek_lavf_au_test='yes'
+seek_lavf_avi_test='yes'
+seek_lavf_dv_test='yes'
+seek_lavf_ffm_test='yes'
+seek_lavf_flv_test='yes'
+seek_lavf_gif_test='yes'
+seek_lavf_gxf_test='yes'
+seek_lavf_mkv_test='yes'
+seek_lavf_mmf_test='yes'
+seek_lavf_mov_test='yes'
+seek_lavf_mpg_test='yes'
+seek_lavf_mxf_d10_test='yes'
+seek_lavf_mxf_test='yes'
+seek_lavf_nut_test='yes'
+seek_lavf_ogg_test='yes'
+seek_lavf_rm_test='yes'
+seek_lavf_swf_test='yes'
+seek_lavf_ts_test='yes'
+seek_lavf_ul_test='yes'
+seek_lavf_voc_test='yes'
+seek_lavf_wav_test='yes'
+seek_lavf_y4m_test='yes'
+seek_ljpeg_avi_test='yes'
+seek_mjpeg_avi_test='yes'
+seek_mp2_mp2_test='yes'
+seek_mpeg1_mpg_test='yes'
+seek_mpeg1b_mpg_test='yes'
+seek_mpeg2_422_mpg_test='yes'
+seek_mpeg2_mpg_test='yes'
+seek_mpeg2i_mpg_test='yes'
+seek_mpeg2ivlc_qprd_mpg_test='yes'
+seek_mpeg2reuse_mpg_test='yes'
+seek_mpeg2thread_mpg_test='yes'
+seek_mpeg2threadivlc_mpg_test='yes'
+seek_mpeg4_adap_avi_test='yes'
+seek_mpeg4_adv_avi_test='yes'
+seek_mpeg4_nr_avi_test='yes'
+seek_mpeg4_qprd_avi_test='yes'
+seek_mpeg4_rc_avi_test='yes'
+seek_mpeg4_thread_avi_test='yes'
+seek_msmpeg4_avi_test='yes'
+seek_msmpeg4v2_avi_test='yes'
+seek_odivx_mp4_test='yes'
+seek_pbmpipe_pbm_test='yes'
+seek_pcm_alaw_wav_test='yes'
+seek_pcm_f32be_au_test='yes'
+seek_pcm_f32le_wav_test='yes'
+seek_pcm_f64be_au_test='yes'
+seek_pcm_f64le_wav_test='yes'
+seek_pcm_mulaw_wav_test='yes'
+seek_pcm_s16be_mkv_test='yes'
+seek_pcm_s16be_mov_test='yes'
+seek_pcm_s16le_mkv_test='yes'
+seek_pcm_s16le_wav_test='yes'
+seek_pcm_s24be_mov_test='yes'
+seek_pcm_s24daud_302_test='yes'
+seek_pcm_s24le_wav_test='yes'
+seek_pcm_s32be_mov_test='yes'
+seek_pcm_s32le_wav_test='yes'
+seek_pcm_s8_mov_test='yes'
+seek_pcm_u8_wav_test='yes'
+seek_pcm_zork_wav_test='yes'
+seek_pgmpipe_pgm_test='yes'
+seek_ppmpipe_ppm_test='yes'
+seek_rgb_avi_test='yes'
+seek_roqav_roq_test='yes'
+seek_rv10_rm_test='yes'
+seek_rv20_rm_test='yes'
+seek_snow53_avi_test='yes'
+seek_snow_avi_test='yes'
+seek_svq1_mov_test='yes'
+seek_wmav1_asf_test='yes'
+seek_wmav2_asf_test='yes'
+seek_wmv1_avi_test='yes'
+seek_wmv2_avi_test='yes'
+seek_yuv_avi_test='yes'
+segafilm_demuxer='yes'
+select_filter='yes'
+setdar_filter='yes'
+setpts_filter='yes'
+setsar_filter='yes'
+settb_filter='yes'
+sgi_decoder='yes'
+sgi_encoder='yes'
+sgi_test='yes'
+sgi_test_deps='sgi_encoder sgi_decoder'
+shlibdir_default='${prefix}/lib'
+shorten_decoder='yes'
+shorten_decoder_select='golomb'
+shorten_demuxer='yes'
+showinfo_filter='yes'
+siff_demuxer='yes'
+sipr_decoder='yes'
+sipr_decoder_select='lsp'
+slicify_filter='yes'
+smackaud_decoder='yes'
+smacker_decoder='yes'
+smacker_demuxer='yes'
+smc_decoder='yes'
+sndio_indev='yes'
+sndio_indev_deps='sndio_h'
+sndio_outdev='yes'
+sndio_outdev_deps='sndio_h'
+snow_decoder='yes'
+snow_decoder_select='dwt'
+snow_encoder='yes'
+snow_encoder_select='aandct dwt'
+snow_test='yes'
+snow_test_deps='snow_encoder snow_decoder'
+snowll_test='yes'
+snowll_test_deps='snow_encoder snow_decoder'
+sol_demuxer='yes'
+sol_dpcm_decoder='yes'
+sonic_decoder='yes'
+sonic_decoder_select='golomb'
+sonic_encoder='yes'
+sonic_encoder_select='golomb'
+sonic_ls_encoder='yes'
+sonic_ls_encoder_select='golomb'
+source_path='/nishome/zhouzhi/android/android_rootfs_ref/packages/amlogic/LibPlayer/amffmpeg-0.8'
+source_path_used='no'
+sox_demuxer='yes'
+sox_muxer='yes'
+sp5x_decoder='yes'
+spdif_demuxer='yes'
+spdif_muxer='yes'
+spdif_muxer_select='aac_parser'
+split_filter='yes'
+srt_decoder='yes'
+srt_demuxer='yes'
+srt_encoder='yes'
+srt_muxer='yes'
+sse='yes'
+sse_deps='mmx'
+ssse3='yes'
+ssse3_deps='sse'
+static='yes'
+str_demuxer='yes'
+strip_default='strip'
+stripping='yes'
+suf1='_muxer'
+suf2='_demuxer'
+sunrast_decoder='yes'
+svq1_decoder='yes'
+svq1_encoder='yes'
+svq1_encoder_select='aandct'
+svq1_test='yes'
+svq1_test_deps='svq1_encoder svq1_decoder'
+svq3_decoder='yes'
+svq3_decoder_select='golomb h264dsp h264pred'
+svq3_decoder_suggest='zlib'
+swf_demuxer='yes'
+swf_muxer='yes'
+swf_test='yes'
+swf_test_deps='swf_muxer swf_demuxer'
+swscale='yes'
+swscale_alpha='yes'
+symver_if_any='symver_asm_label symver_gnu_asm'
+targa_decoder='yes'
+targa_encoder='yes'
+target_os='linux'
+target_os_default='linux'
+target_path='$(CURDIR)'
+tcp_protocol='yes'
+tcp_protocol_deps='network'
+tests='yuv4mpeg'
+text2movsub_bsf='yes'
+tg2_muxer='yes'
+tg2_muxer_select='mov_muxer'
+tga_test='yes'
+tga_test_deps='targa_encoder targa_decoder'
+tgp_muxer='yes'
+tgp_muxer_select='mov_muxer'
+theora_decoder='yes'
+theora_decoder_select='vp3_decoder'
+thp_decoder='yes'
+thp_demuxer='yes'
+tiertexseq_demuxer='yes'
+tiertexseqvideo_decoder='yes'
+tiff_decoder='yes'
+tiff_decoder_suggest='zlib'
+tiff_encoder='yes'
+tiff_encoder_suggest='zlib'
+tiff_test='yes'
+tiff_test_deps='tiff_encoder tiff_decoder'
+tmv_decoder='yes'
+tmv_demuxer='yes'
+transpose_filter='yes'
+truehd_decoder='yes'
+truehd_decoder_select='mlp_decoder'
+truehd_demuxer='yes'
+truehd_muxer='yes'
+truemotion1_decoder='yes'
+truemotion2_decoder='yes'
+truespeech_decoder='yes'
+ts_test='yes'
+ts_test_deps='mpegts_muxer mpegts_demuxer'
+tscc_decoder='yes'
+tscc_decoder_select='zlib'
+tta_decoder='yes'
+tta_demuxer='yes'
+tty_demuxer='yes'
+twinvq_decoder='yes'
+twinvq_decoder_select='mdct lsp sinewin'
+txd_decoder='yes'
+txd_demuxer='yes'
+udp_protocol='yes'
+udp_protocol_deps='network'
+ulti_decoder='yes'
+unsharp_filter='yes'
+v='PROTOCOL_LIST'
+v210_decoder='yes'
+v210_encoder='yes'
+v210x_decoder='yes'
+v4l2_indev='yes'
+v4l2_indev_deps_any='linux_videodev2_h sys_videoio_h'
+v4l_indev='yes'
+v4l_indev_deps='linux_videodev_h'
+vaapi_deps='va_va_h'
+value='arch'
+var='arch'
+vb_decoder='yes'
+vc1_crystalhd_decoder='yes'
+vc1_crystalhd_decoder_select='crystalhd'
+vc1_decoder='yes'
+vc1_decoder_select='h263_decoder'
+vc1_demuxer='yes'
+vc1_dxva2_hwaccel='yes'
+vc1_dxva2_hwaccel_deps='dxva2api_h DXVA_PictureParameters_wDecodedPictureIndex'
+vc1_dxva2_hwaccel_select='dxva2 vc1_decoder'
+vc1_parser='yes'
+vc1_vaapi_hwaccel='yes'
+vc1_vaapi_hwaccel_select='vaapi vc1_decoder'
+vc1_vdpau_decoder='yes'
+vc1_vdpau_decoder_select='vdpau vc1_decoder'
+vc1t_demuxer='yes'
+vc1t_muxer='yes'
+vcr1_decoder='yes'
+vdpau_deps='vdpau_vdpau_h vdpau_vdpau_x11_h'
+vflip_crop_test='yes'
+vflip_filter='yes'
+vflip_test='yes'
+vflip_vflip_test='yes'
+vfpv3='yes'
+vfpv3_deps='armvfp'
+vfwcap_indev='yes'
+vfwcap_indev_deps='capCreateCaptureWindow vfwcap_defines'
+vfwcap_indev_extralibs='-lavicap32'
+vis='yes'
+vis_deps='sparc'
+vmd_demuxer='yes'
+vmdaudio_decoder='yes'
+vmdvideo_decoder='yes'
+vmnc_decoder='yes'
+voc_demuxer='yes'
+voc_muxer='yes'
+voc_s16_test='yes'
+voc_test='yes'
+voc_test_deps='voc_muxer voc_demuxer'
+vorbis_decoder='yes'
+vorbis_decoder_select='mdct'
+vorbis_encoder='yes'
+vorbis_encoder_select='mdct'
+vp3_decoder='yes'
+vp3_parser='yes'
+vp5_decoder='yes'
+vp6_decoder='yes'
+vp6_decoder_select='huffman'
+vp6a_decoder='yes'
+vp6a_decoder_select='vp6_decoder'
+vp6f_decoder='yes'
+vp6f_decoder_select='vp6_decoder'
+vp8_decoder='yes'
+vp8_decoder_select='h264pred'
+vp8_parser='yes'
+vqa_decoder='yes'
+vqf_demuxer='yes'
+vref_test='yes'
+w64_demuxer='yes'
+w64_demuxer_deps='wav_demuxer'
+wav_demuxer='yes'
+wav_muxer='yes'
+wav_test='yes'
+wav_test_deps='wav_muxer wav_demuxer'
+wavpack_decoder='yes'
+wc3_demuxer='yes'
+webm_muxer='yes'
+wmapro_decoder='yes'
+wmapro_decoder_select='mdct sinewin'
+wmav1_decoder='yes'
+wmav1_decoder_select='mdct sinewin'
+wmav1_encoder='yes'
+wmav1_encoder_select='mdct sinewin'
+wmav1_test='yes'
+wmav1_test_deps='wmav1_encoder wmav1_decoder'
+wmav2_decoder='yes'
+wmav2_decoder_select='mdct sinewin'
+wmav2_encoder='yes'
+wmav2_encoder_select='mdct sinewin'
+wmav2_test='yes'
+wmav2_test_deps='wmav2_encoder wmav2_decoder'
+wmavoice_decoder='yes'
+wmavoice_decoder_select='lsp rdft dct mdct sinewin'
+wmv1_decoder='yes'
+wmv1_decoder_select='h263_decoder'
+wmv1_encoder='yes'
+wmv1_encoder_select='h263_encoder'
+wmv1_test='yes'
+wmv1_test_deps='wmv1_encoder wmv1_decoder'
+wmv2_decoder='yes'
+wmv2_decoder_select='h263_decoder'
+wmv2_encoder='yes'
+wmv2_encoder_select='h263_encoder'
+wmv2_test='yes'
+wmv2_test_deps='wmv2_encoder wmv2_decoder'
+wmv3_crystalhd_decoder='yes'
+wmv3_crystalhd_decoder_select='crystalhd'
+wmv3_decoder='yes'
+wmv3_decoder_select='vc1_decoder'
+wmv3_dxva2_hwaccel='yes'
+wmv3_dxva2_hwaccel_select='vc1_dxva2_hwaccel'
+wmv3_vaapi_hwaccel='yes'
+wmv3_vaapi_hwaccel_select='vc1_vaapi_hwaccel'
+wmv3_vdpau_decoder='yes'
+wmv3_vdpau_decoder_select='vc1_vdpau_decoder'
+wnv1_decoder='yes'
+ws_snd1_decoder='yes'
+wsaud_demuxer='yes'
+wsvqa_demuxer='yes'
+wtv_demuxer='yes'
+wv_demuxer='yes'
+x11_grab_device_indev='yes'
+x11_grab_device_indev_deps='x11grab XShmCreateImage'
+x11_grab_device_indev_extralibs='-lX11 -lXext -lXfixes'
+x86_64_suggest='cmov fast_cmov'
+xa_demuxer='yes'
+xan_dpcm_decoder='yes'
+xan_wc3_decoder='yes'
+xan_wc4_decoder='yes'
+xl_decoder='yes'
+xsub_decoder='yes'
+xsub_encoder='yes'
+xwma_demuxer='yes'
+yadif_filter='yes'
+yadif_filter_deps='gpl'
+yasm='no'
+yasmexe='yasm'
+yop_decoder='yes'
+yop_demuxer='yes'
+yuv4mpeg_test='yes'
+yuv4mpeg_test_deps='yuv4mpegpipe_muxer yuv4mpegpipe_demuxer'
+yuv4mpegpipe_demuxer='yes'
+yuv4mpegpipe_muxer='yes'
+yuv_test='yes'
+yuv_test_deps='rawvideo_encoder rawvideo_decoder'
+zlib_decoder='yes'
+zlib_decoder_select='zlib'
+zlib_encoder='yes'
+zlib_encoder_select='zlib'
+zmbv_decoder='yes'
+zmbv_decoder_select='zlib'
+zmbv_encoder='yes'
+zmbv_encoder_select='zlib'
+WARNING: arm-none-linux-gnueabi-pkg-config not found, library detection may fail.
+mktemp -u XXXXXX
+i5Ux2q
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_cflags -std=c99
+check_cc -std=c99
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -std=c99 -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cc -D_FILE_OFFSET_BITS=64
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <stdlib.h>
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -std=c99 -D_FILE_OFFSET_BITS=64 -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cc -D_LARGEFILE_SOURCE
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <stdlib.h>
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -std=c99 -D_LARGEFILE_SOURCE -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_host_cflags -std=c99
+check_host_cc -std=c99
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+gcc -D_ISOC99_SOURCE -O3 -g -std=c99 -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_host_cflags -Wall
+check_host_cc -Wall
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+gcc -D_ISOC99_SOURCE -O3 -g -std=c99 -Wall -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cpp_condition stdlib.h defined(__PIC__) || defined(__pic__) || defined(PIC)
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <stdlib.h>
+    2	#if !(defined(__PIC__) || defined(__pic__) || defined(PIC))
+    3	#error "unsatisfied condition: defined(__PIC__) || defined(__pic__) || defined(PIC)"
+    4	#endif
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:3:2: error: #error "unsatisfied condition: defined(__PIC__) || defined(__pic__) || defined(PIC)"
+check_cflags -fomit-frame-pointer
+check_cc -fomit-frame-pointer
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int ff_extern;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	void foo(void) { __asm__ volatile ("" ::); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	void foo(char * restrict p);
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	struct { int x; } __attribute__((packed)) x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	union { int x; } __attribute__((may_alias)) x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	unsigned int endian = 'B' << 24 | 'I' << 16 | 'G' << 8 | 'E';
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cflags -marm
+check_cc -marm
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cpp_condition stddef.h defined __ARM_PCS_VFP
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <stddef.h>
+    2	#if !(defined __ARM_PCS_VFP)
+    3	#error "unsatisfied condition: defined __ARM_PCS_VFP"
+    4	#endif
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:3:2: error: #error "unsatisfied condition: defined __ARM_PCS_VFP"
+check_cpp_condition stddef.h defined __ARM_PCS || defined __SOFTFP__
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <stddef.h>
+    2	#if !(defined __ARM_PCS || defined __SOFTFP__)
+    3	#error "unsatisfied condition: defined __ARM_PCS || defined __SOFTFP__"
+    4	#endif
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_asm pld "pld [r0]"
+check_as
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	void foo(void){ __asm__ volatile("pld [r0]"); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ccvIcH3H.s: Assembler messages:
+/tmp/ccvIcH3H.s:24: Error: selected processor does not support `pld [r0]'
+check_asm armv5te "qadd r0, r0, r0"
+check_as
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	void foo(void){ __asm__ volatile("qadd r0, r0, r0"); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ccwGgqPJ.s: Assembler messages:
+/tmp/ccwGgqPJ.s:24: Error: selected processor does not support `qadd r0,r0,r0'
+check_asm armv6 "sadd16 r0, r0, r0"
+check_as
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	void foo(void){ __asm__ volatile("sadd16 r0, r0, r0"); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ccTHoZRN.s: Assembler messages:
+/tmp/ccTHoZRN.s:24: Error: selected processor does not support `sadd16 r0,r0,r0'
+check_asm armv6t2 "movt r0, #0"
+check_as
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	void foo(void){ __asm__ volatile("movt r0, #0"); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ccQ5edCP.s: Assembler messages:
+/tmp/ccQ5edCP.s:24: Error: selected processor does not support `movt r0,#0'
+check_asm armvfp "fadds s0, s0, s0"
+check_as
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	void foo(void){ __asm__ volatile("fadds s0, s0, s0"); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ccxT0s1O.s: Assembler messages:
+/tmp/ccxT0s1O.s:24: Error: selected processor does not support `fadds s0,s0,s0'
+check_asm iwmmxt "wunpckelub wr6, wr4"
+check_as
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	void foo(void){ __asm__ volatile("wunpckelub wr6, wr4"); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ccEoefMQ.s: Assembler messages:
+/tmp/ccEoefMQ.s:24: Error: selected processor does not support `wunpckelub wr6,wr4'
+check_asm neon "vadd.i16 q0, q0, q0"
+check_as
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	void foo(void){ __asm__ volatile("vadd.i16 q0, q0, q0"); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/cc1bh9QU.s: Assembler messages:
+/tmp/cc1bh9QU.s:24: Error: bad instruction `vadd.i16 q0,q0,q0'
+check_asm vfpv3 "vmov.f32 s0, #1.0"
+check_as
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	void foo(void){ __asm__ volatile("vmov.f32 s0, #1.0"); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ccY3xZZW.s: Assembler messages:
+/tmp/ccY3xZZW.s:24: Error: bad instruction `vmov.f32 s0,#1.0'
+check_asm gnu_as ".macro m n
+\n:.int 0
+.endm
+m x"
+check_as
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	void foo(void){ __asm__ volatile(".macro m n\n\\n:.int 0\n.endm\nm x"); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_ldflags -Wl,--as-needed
+test_ldflags -Wl,--as-needed
+check_ld -Wl,--as-needed
+check_cc -Wl,--as-needed
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -Wl,--as-needed -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func dlopen
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int dlopen();
+    2	int main(void){ dlopen(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+/tmp/ffconf.X8XHPEsx.o: In function `main':
+ffconf.t8GLzA5g.c:(.text+0x4): undefined reference to `dlopen'
+collect2: ld returned 1 exit status
+check_func dlopen -ldl
+check_ld -ldl
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int dlopen();
+    2	int main(void){ dlopen(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -ldl
+check_type sys/types.h sys/socket.h socklen_t
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	
+    2	#include <sys/types.h>
+    3	#include <sys/socket.h>
+    4	socklen_t v;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_type netdb.h struct addrinfo
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	
+    2	#include <netdb.h>
+    3	struct addrinfo v;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_type netinet/in.h struct ipv6_mreq -D_DARWIN_C_SOURCE
+check_cc -D_DARWIN_C_SOURCE
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	
+    2	#include <netinet/in.h>
+    3	struct ipv6_mreq v;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -D_DARWIN_C_SOURCE -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_type netinet/in.h struct sockaddr_in6
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	
+    2	#include <netinet/in.h>
+    3	struct sockaddr_in6 v;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_type sys/types.h sys/socket.h struct sockaddr_storage
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	
+    2	#include <sys/types.h>
+    3	#include <sys/socket.h>
+    4	struct sockaddr_storage v;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_type sys/types.h sys/socket.h struct sockaddr sa_len
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	
+    2	#include <sys/types.h>
+    3	#include <sys/socket.h>
+    4	const void *p = &((struct sockaddr *)0)->sa_len;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:4: error: 'struct sockaddr' has no member named 'sa_len'
+check_header arpa/inet.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <arpa/inet.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_func closesocket
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int closesocket();
+    2	int main(void){ closesocket(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+/tmp/ffconf.X8XHPEsx.o: In function `main':
+ffconf.t8GLzA5g.c:(.text+0x4): undefined reference to `closesocket'
+collect2: ld returned 1 exit status
+check_func nanosleep
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int nanosleep();
+    2	int main(void){ nanosleep(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func fcntl
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int fcntl();
+    2	int main(void){ fcntl(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func fork
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int fork();
+    2	int main(void){ fork(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func getaddrinfo
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int getaddrinfo();
+    2	int main(void){ getaddrinfo(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func gethrtime
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int gethrtime();
+    2	int main(void){ gethrtime(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+/tmp/ffconf.X8XHPEsx.o: In function `main':
+ffconf.t8GLzA5g.c:(.text+0x4): undefined reference to `gethrtime'
+collect2: ld returned 1 exit status
+check_func getrusage
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int getrusage();
+    2	int main(void){ getrusage(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_type sys/time.h sys/resource.h struct rusage ru_maxrss
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	
+    2	#include <sys/time.h>
+    3	#include <sys/resource.h>
+    4	const void *p = &((struct rusage *)0)->ru_maxrss;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_func inet_aton
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int inet_aton();
+    2	int main(void){ inet_aton(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func isatty
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int isatty();
+    2	int main(void){ isatty(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func localtime_r
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int localtime_r();
+    2	int main(void){ localtime_r(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func memalign
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int memalign();
+    2	int main(void){ memalign(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func mkstemp
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int mkstemp();
+    2	int main(void){ mkstemp(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func mmap
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int mmap();
+    2	int main(void){ mmap(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func posix_memalign
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int posix_memalign();
+    2	int main(void){ posix_memalign(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func setrlimit
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int setrlimit();
+    2	int main(void){ setrlimit(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func strerror_r
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int strerror_r();
+    2	int main(void){ strerror_r(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func strtok_r
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int strtok_r();
+    2	int main(void){ strtok_r(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_func_headers conio.h kbhit
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <conio.h>
+    2	long check_kbhit(void) { return (long) kbhit; }
+    3	int main(void) { return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:19: error: conio.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c: In function 'check_kbhit':
+/tmp/ffconf.t8GLzA5g.c:2: error: 'kbhit' undeclared (first use in this function)
+/tmp/ffconf.t8GLzA5g.c:2: error: (Each undeclared identifier is reported only once
+/tmp/ffconf.t8GLzA5g.c:2: error: for each function it appears in.)
+check_func_headers io.h setmode
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <io.h>
+    2	long check_setmode(void) { return (long) setmode; }
+    3	int main(void) { return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:16: error: io.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c: In function 'check_setmode':
+/tmp/ffconf.t8GLzA5g.c:2: error: 'setmode' undeclared (first use in this function)
+/tmp/ffconf.t8GLzA5g.c:2: error: (Each undeclared identifier is reported only once
+/tmp/ffconf.t8GLzA5g.c:2: error: for each function it appears in.)
+check_func_headers lzo/lzo1x.h lzo1x_999_compress
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <lzo/lzo1x.h>
+    2	long check_lzo1x_999_compress(void) { return (long) lzo1x_999_compress; }
+    3	int main(void) { return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:23: error: lzo/lzo1x.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c: In function 'check_lzo1x_999_compress':
+/tmp/ffconf.t8GLzA5g.c:2: error: 'lzo1x_999_compress' undeclared (first use in this function)
+/tmp/ffconf.t8GLzA5g.c:2: error: (Each undeclared identifier is reported only once
+/tmp/ffconf.t8GLzA5g.c:2: error: for each function it appears in.)
+check_lib2 windows.h psapi.h GetProcessMemoryInfo -lpsapi
+check_func_headers windows.h psapi.h GetProcessMemoryInfo -lpsapi
+check_ld -lpsapi
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <windows.h>
+    2	#include <psapi.h>
+    3	long check_GetProcessMemoryInfo(void) { return (long) GetProcessMemoryInfo; }
+    4	int main(void) { return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:21: error: windows.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c:2:19: error: psapi.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c: In function 'check_GetProcessMemoryInfo':
+/tmp/ffconf.t8GLzA5g.c:3: error: 'GetProcessMemoryInfo' undeclared (first use in this function)
+/tmp/ffconf.t8GLzA5g.c:3: error: (Each undeclared identifier is reported only once
+/tmp/ffconf.t8GLzA5g.c:3: error: for each function it appears in.)
+check_func_headers windows.h GetProcessTimes
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <windows.h>
+    2	long check_GetProcessTimes(void) { return (long) GetProcessTimes; }
+    3	int main(void) { return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:21: error: windows.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c: In function 'check_GetProcessTimes':
+/tmp/ffconf.t8GLzA5g.c:2: error: 'GetProcessTimes' undeclared (first use in this function)
+/tmp/ffconf.t8GLzA5g.c:2: error: (Each undeclared identifier is reported only once
+/tmp/ffconf.t8GLzA5g.c:2: error: for each function it appears in.)
+check_func_headers windows.h MapViewOfFile
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <windows.h>
+    2	long check_MapViewOfFile(void) { return (long) MapViewOfFile; }
+    3	int main(void) { return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:21: error: windows.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c: In function 'check_MapViewOfFile':
+/tmp/ffconf.t8GLzA5g.c:2: error: 'MapViewOfFile' undeclared (first use in this function)
+/tmp/ffconf.t8GLzA5g.c:2: error: (Each undeclared identifier is reported only once
+/tmp/ffconf.t8GLzA5g.c:2: error: for each function it appears in.)
+check_func_headers windows.h VirtualAlloc
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <windows.h>
+    2	long check_VirtualAlloc(void) { return (long) VirtualAlloc; }
+    3	int main(void) { return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:21: error: windows.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c: In function 'check_VirtualAlloc':
+/tmp/ffconf.t8GLzA5g.c:2: error: 'VirtualAlloc' undeclared (first use in this function)
+/tmp/ffconf.t8GLzA5g.c:2: error: (Each undeclared identifier is reported only once
+/tmp/ffconf.t8GLzA5g.c:2: error: for each function it appears in.)
+check_header dlfcn.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <dlfcn.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_header dxva2api.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <dxva2api.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:22: error: dxva2api.h: No such file or directory
+check_header libcrystalhd/libcrystalhd_if.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <libcrystalhd/libcrystalhd_if.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:42: error: libcrystalhd/libcrystalhd_if.h: No such file or directory
+check_header malloc.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <malloc.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_header poll.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <poll.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_header sys/mman.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <sys/mman.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_header sys/resource.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <sys/resource.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_header sys/select.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <sys/select.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_header termios.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <termios.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_header vdpau/vdpau.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <vdpau/vdpau.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:25: error: vdpau/vdpau.h: No such file or directory
+check_header vdpau/vdpau_x11.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <vdpau/vdpau_x11.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:29: error: vdpau/vdpau_x11.h: No such file or directory
+check_header X11/extensions/XvMClib.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <X11/extensions/XvMClib.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:36: error: X11/extensions/XvMClib.h: No such file or directory
+check_type dxva2api.h DXVA_PictureParameters wDecodedPictureIndex
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	
+    2	#include <dxva2api.h>
+    3	const void *p = &((DXVA_PictureParameters *)0)->wDecodedPictureIndex;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:2:22: error: dxva2api.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c:3: error: 'DXVA_PictureParameters' undeclared here (not in a function)
+/tmp/ffconf.t8GLzA5g.c:3: error: expected expression before ')' token
+check_lib zlib.h zlibVersion -lz
+check_header zlib.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <zlib.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_func zlibVersion -lz
+check_ld -lz
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int zlibVersion();
+    2	int main(void){ zlibVersion(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lz
+/usr/local/arm/4.3.2/bin/../lib/gcc/arm-none-linux-gnueabi/4.3.2/../../../../arm-none-linux-gnueabi/bin/ld: cannot find -lz
+collect2: ld returned 1 exit status
+check_lib2 bzlib.h BZ2_bzlibVersion -lbz2
+check_func_headers bzlib.h BZ2_bzlibVersion -lbz2
+check_ld -lbz2
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <bzlib.h>
+    2	long check_BZ2_bzlibVersion(void) { return (long) BZ2_bzlibVersion; }
+    3	int main(void) { return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:19: error: bzlib.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c: In function 'check_BZ2_bzlibVersion':
+/tmp/ffconf.t8GLzA5g.c:2: error: 'BZ2_bzlibVersion' undeclared (first use in this function)
+/tmp/ffconf.t8GLzA5g.c:2: error: (Each undeclared identifier is reported only once
+/tmp/ffconf.t8GLzA5g.c:2: error: for each function it appears in.)
+check_func pthread_create
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int pthread_create();
+    2	int main(void){ pthread_create(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+/tmp/ffconf.X8XHPEsx.o: In function `main':
+ffconf.t8GLzA5g.c:(.text+0x4): undefined reference to `pthread_create'
+collect2: ld returned 1 exit status
+check_func pthread_create -pthread
+check_ld -pthread
+check_cc -pthread
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int pthread_create();
+    2	int main(void){ pthread_create(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -pthread -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o
+check_lib math.h sin -lm
+check_header math.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_func sin -lm
+check_ld -lm
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	extern int sin();
+    2	int main(void){ sin(); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1: warning: conflicting types for built-in function 'sin'
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_lib libcrystalhd/libcrystalhd_if.h DtsCrystalHDVersion -lcrystalhd
+check_header libcrystalhd/libcrystalhd_if.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <libcrystalhd/libcrystalhd_if.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:42: error: libcrystalhd/libcrystalhd_if.h: No such file or directory
+check_mathfunc exp2
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	float foo(float f) { return exp2(f); }
+    3	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_mathfunc exp2f
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	float foo(float f) { return exp2f(f); }
+    3	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_mathfunc llrint
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	float foo(float f) { return llrint(f); }
+    3	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_mathfunc llrintf
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	float foo(float f) { return llrintf(f); }
+    3	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_mathfunc log2
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	float foo(float f) { return log2(f); }
+    3	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_mathfunc log2f
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	float foo(float f) { return log2f(f); }
+    3	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_mathfunc lrint
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	float foo(float f) { return lrint(f); }
+    3	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_mathfunc lrintf
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	float foo(float f) { return lrintf(f); }
+    3	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_mathfunc round
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	float foo(float f) { return round(f); }
+    3	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_mathfunc roundf
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	float foo(float f) { return roundf(f); }
+    3	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_mathfunc trunc
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	float foo(float f) { return trunc(f); }
+    3	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_mathfunc truncf
+check_ld
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <math.h>
+    2	float foo(float f) { return truncf(f); }
+    3	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_pkg_config sdl SDL_version.h SDL_Linked_Version
+check_header linux/fb.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <linux/fb.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_header linux/videodev.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <linux/videodev.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_header linux/videodev2.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <linux/videodev2.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_header sys/videoio.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <sys/videoio.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:25: error: sys/videoio.h: No such file or directory
+check_func_headers windows.h vfw.h capCreateCaptureWindow -lavicap32
+check_ld -lavicap32
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <windows.h>
+    2	#include <vfw.h>
+    3	long check_capCreateCaptureWindow(void) { return (long) capCreateCaptureWindow; }
+    4	int main(void) { return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:21: error: windows.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c:2:17: error: vfw.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c: In function 'check_capCreateCaptureWindow':
+/tmp/ffconf.t8GLzA5g.c:3: error: 'capCreateCaptureWindow' undeclared (first use in this function)
+/tmp/ffconf.t8GLzA5g.c:3: error: (Each undeclared identifier is reported only once
+/tmp/ffconf.t8GLzA5g.c:3: error: for each function it appears in.)
+check_cpp_condition vfw.h WM_CAP_DRIVER_CONNECT > WM_USER
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <vfw.h>
+    2	#if !(WM_CAP_DRIVER_CONNECT > WM_USER)
+    3	#error "unsatisfied condition: WM_CAP_DRIVER_CONNECT > WM_USER"
+    4	#endif
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:17: error: vfw.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c:3:2: error: #error "unsatisfied condition: WM_CAP_DRIVER_CONNECT > WM_USER"
+check_type dshow.h IBaseFilter
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	
+    2	#include <dshow.h>
+    3	IBaseFilter v;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:2:19: error: dshow.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c:3: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'v'
+check_header dev/bktr/ioctl_meteor.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <dev/bktr/ioctl_meteor.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:35: error: dev/bktr/ioctl_meteor.h: No such file or directory
+check_header machine/ioctl_meteor.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <machine/ioctl_meteor.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:34: error: machine/ioctl_meteor.h: No such file or directory
+check_header dev/video/meteor/ioctl_meteor.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <dev/video/meteor/ioctl_meteor.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:43: error: dev/video/meteor/ioctl_meteor.h: No such file or directory
+check_header dev/ic/bt8xx.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <dev/ic/bt8xx.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:26: error: dev/ic/bt8xx.h: No such file or directory
+check_header sndio.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <sndio.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:19: error: sndio.h: No such file or directory
+check_type sys/soundcard.h audio_buf_info bytes
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	
+    2	#include <sys/soundcard.h>
+    3	const void *p = &((audio_buf_info *)0)->bytes;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_header soundcard.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <soundcard.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:23: error: soundcard.h: No such file or directory
+check_lib2 alsa/asoundlib.h snd_pcm_htimestamp -lasound
+check_func_headers alsa/asoundlib.h snd_pcm_htimestamp -lasound
+check_ld -lasound
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <alsa/asoundlib.h>
+    2	long check_snd_pcm_htimestamp(void) { return (long) snd_pcm_htimestamp; }
+    3	int main(void) { return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:28: error: alsa/asoundlib.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c: In function 'check_snd_pcm_htimestamp':
+/tmp/ffconf.t8GLzA5g.c:2: error: 'snd_pcm_htimestamp' undeclared (first use in this function)
+/tmp/ffconf.t8GLzA5g.c:2: error: (Each undeclared identifier is reported only once
+/tmp/ffconf.t8GLzA5g.c:2: error: for each function it appears in.)
+check_lib2 jack/jack.h jack_client_open -ljack
+check_func_headers jack/jack.h jack_client_open -ljack
+check_ld -ljack
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <jack/jack.h>
+    2	long check_jack_client_open(void) { return (long) jack_client_open; }
+    3	int main(void) { return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:23: error: jack/jack.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c: In function 'check_jack_client_open':
+/tmp/ffconf.t8GLzA5g.c:2: error: 'jack_client_open' undeclared (first use in this function)
+/tmp/ffconf.t8GLzA5g.c:2: error: (Each undeclared identifier is reported only once
+/tmp/ffconf.t8GLzA5g.c:2: error: for each function it appears in.)
+check_lib2 sndio.h sio_open -lsndio
+check_func_headers sndio.h sio_open -lsndio
+check_ld -lsndio
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <sndio.h>
+    2	long check_sio_open(void) { return (long) sio_open; }
+    3	int main(void) { return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:19: error: sndio.h: No such file or directory
+/tmp/ffconf.t8GLzA5g.c: In function 'check_sio_open':
+/tmp/ffconf.t8GLzA5g.c:2: error: 'sio_open' undeclared (first use in this function)
+/tmp/ffconf.t8GLzA5g.c:2: error: (Each undeclared identifier is reported only once
+/tmp/ffconf.t8GLzA5g.c:2: error: for each function it appears in.)
+check_lib va/va.h vaInitialize -lva
+check_header va/va.h
+check_cpp
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	#include <va/va.h>
+    2	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -E -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+/tmp/ffconf.t8GLzA5g.c:1:19: error: va/va.h: No such file or directory
+check_cflags -Wdeclaration-after-statement
+check_cc -Wdeclaration-after-statement
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cflags -Wall
+check_cc -Wall
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cflags -Wno-parentheses
+check_cc -Wno-parentheses
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cflags -Wno-switch
+check_cc -Wno-switch
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cflags -Wdisabled-optimization
+check_cc -Wdisabled-optimization
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+check_cflags -Wpointer-arith
+check_cc -Wpointer-arith
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+check_cflags -Wredundant-decls
+check_cc -Wredundant-decls
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+check_cflags -Wno-pointer-sign
+check_cc -Wno-pointer-sign
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+check_cflags -Wcast-qual
+check_cc -Wcast-qual
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+check_cflags -Wwrite-strings
+check_cc -Wwrite-strings
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+check_cflags -Wtype-limits
+check_cc -Wtype-limits
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+check_cflags -Wundef
+check_cc -Wundef
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+check_cflags -Wmissing-prototypes
+check_cc -Wmissing-prototypes
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+check_cflags -Wno-pointer-to-int-cast
+check_cc -Wno-pointer-to-int-cast
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+check_ldflags -Wl,--warn-common
+test_ldflags -Wl,--warn-common
+check_ld -Wl,--warn-common
+check_cc -Wl,--warn-common
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -Wl,--warn-common -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -Wl,--warn-common -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_ldflags -Wl,-rpath-link,libpostproc -Wl,-rpath-link,libswscale -Wl,-rpath-link,libavfilter -Wl,-rpath-link,libavdevice -Wl,-rpath-link,libavformat -Wl,-rpath-link,libavcodec -Wl,-rpath-link,libavutil
+test_ldflags -Wl,-rpath-link,libpostproc -Wl,-rpath-link,libswscale -Wl,-rpath-link,libavfilter -Wl,-rpath-link,libavdevice -Wl,-rpath-link,libavformat -Wl,-rpath-link,libavcodec -Wl,-rpath-link,libavutil
+check_ld -Wl,-rpath-link,libpostproc -Wl,-rpath-link,libswscale -Wl,-rpath-link,libavfilter -Wl,-rpath-link,libavdevice -Wl,-rpath-link,libavformat -Wl,-rpath-link,libavcodec -Wl,-rpath-link,libavutil
+check_cc -Wl,-rpath-link,libpostproc -Wl,-rpath-link,libswscale -Wl,-rpath-link,libavfilter -Wl,-rpath-link,libavdevice -Wl,-rpath-link,libavformat -Wl,-rpath-link,libavcodec -Wl,-rpath-link,libavutil
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -Wl,-rpath-link,libpostproc -Wl,-rpath-link,libswscale -Wl,-rpath-link,libavfilter -Wl,-rpath-link,libavdevice -Wl,-rpath-link,libavformat -Wl,-rpath-link,libavcodec -Wl,-rpath-link,libavutil -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -Wl,--warn-common -Wl,-rpath-link,libpostproc -Wl,-rpath-link,libswscale -Wl,-rpath-link,libavfilter -Wl,-rpath-link,libavdevice -Wl,-rpath-link,libavformat -Wl,-rpath-link,libavcodec -Wl,-rpath-link,libavutil -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+test_ldflags -Wl,-Bsymbolic
+check_ld -Wl,-Bsymbolic
+check_cc -Wl,-Bsymbolic
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -Wl,-Bsymbolic -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -Wl,--warn-common -Wl,-rpath-link,libpostproc -Wl,-rpath-link,libswscale -Wl,-rpath-link,libavfilter -Wl,-rpath-link,libavdevice -Wl,-rpath-link,libavformat -Wl,-rpath-link,libavcodec -Wl,-rpath-link,libavutil -Wl,-Bsymbolic -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+test_ldflags -Wl,--version-script,/tmp/ffconf.6i3drqvh.ver
+check_ld -Wl,--version-script,/tmp/ffconf.6i3drqvh.ver
+check_cc -Wl,--version-script,/tmp/ffconf.6i3drqvh.ver
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int main(void){ return 0; }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -Wl,--version-script,/tmp/ffconf.6i3drqvh.ver -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+arm-none-linux-gnueabi-gcc -Wl,--as-needed -Wl,--warn-common -Wl,-rpath-link,libpostproc -Wl,-rpath-link,libswscale -Wl,-rpath-link,libavfilter -Wl,-rpath-link,libavdevice -Wl,-rpath-link,libavformat -Wl,-rpath-link,libavcodec -Wl,-rpath-link,libavutil -Wl,--version-script,/tmp/ffconf.6i3drqvh.ver -o /tmp/ffconf.FTTIfDpO /tmp/ffconf.X8XHPEsx.o -lm -pthread
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	void ff_foo(void) __asm__ ("av_foo@VERSION");
+    2	void ff_foo(void) { __asm__(""); }
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+/tmp/cc5wnlTI.s: Assembler messages:
+/tmp/cc5wnlTI.s:22: Error: unrecognized symbol type ""
+/tmp/cc5wnlTI.s:23: Error: bad instruction `av_foo'
+/tmp/cc5wnlTI.s:33: Error: expected comma after name `av_foo' in .size directive
+check_cc
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	__asm__(".symver ff_foo,av_foo@VERSION");
+    2	void ff_foo(void) {}
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+cc1: warning: -funit-at-a-time is required for inlining of functions that are only called once
+/tmp/ffconf.t8GLzA5g.c:2: warning: no previous prototype for 'ff_foo'
+check_cflags -fno-math-errno
+check_cc -fno-math-errno
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -O3 -fno-math-errno -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cflags -fno-signed-zeros
+check_cc -fno-signed-zeros
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -O3 -fno-math-errno -fno-signed-zeros -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cflags -fno-tree-vectorize
+check_cc -fno-tree-vectorize
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -O3 -fno-math-errno -fno-signed-zeros -fno-tree-vectorize -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cflags -Werror=implicit-function-declaration
+check_cc -Werror=implicit-function-declaration
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -O3 -fno-math-errno -fno-signed-zeros -fno-tree-vectorize -Werror=implicit-function-declaration -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
+check_cflags -Werror=missing-prototypes
+check_cc -Werror=missing-prototypes
+BEGIN /tmp/ffconf.t8GLzA5g.c
+    1	int x;
+END /tmp/ffconf.t8GLzA5g.c
+arm-none-linux-gnueabi-gcc -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 -std=c99 -fomit-frame-pointer -marm -pthread -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -O3 -fno-math-errno -fno-signed-zeros -fno-tree-vectorize -Werror=implicit-function-declaration -Werror=missing-prototypes -c -o /tmp/ffconf.X8XHPEsx.o /tmp/ffconf.t8GLzA5g.c
diff --git a/amffmpeg/config.mak b/amffmpeg/config.mak
new file mode 100644
index 0000000..a3008ed
--- /dev/null
+++ b/amffmpeg/config.mak
@@ -0,0 +1,1112 @@
+# Automatically generated by configure - do not modify!
+ifndef FFMPEG_CONFIG_MAK
+FFMPEG_CONFIG_MAK=1
+FFMPEG_CONFIGURATION=--disable-yasm --disable-ffplay --cross-prefix=arm-none-linux-gnueabi- --enable-cross-compile --target-os=linux --arch=arm
+prefix=/usr/local
+LIBDIR=$(DESTDIR)${prefix}/lib
+SHLIBDIR=$(DESTDIR)${prefix}/lib
+INCDIR=$(DESTDIR)${prefix}/include
+BINDIR=$(DESTDIR)${prefix}/bin
+DATADIR=$(DESTDIR)${prefix}/share/ffmpeg
+MANDIR=$(DESTDIR)${prefix}/share/man
+SRC_PATH="/nishome/zhouzhi/android/android_rootfs_ref/packages/amlogic/LibPlayer/amffmpeg-0.8"
+SRC_PATH_BARE=/nishome/zhouzhi/android/android_rootfs_ref/packages/amlogic/LibPlayer/amffmpeg-0.8
+CC_IDENT=gcc 4.3.2 (Sourcery G++ Lite 2008q3-72)
+ARCH=arm
+CC=arm-none-linux-gnueabi-gcc
+AS=arm-none-linux-gnueabi-gcc
+LD=arm-none-linux-gnueabi-gcc
+DEPCC=arm-none-linux-gnueabi-gcc
+YASM=yasm
+YASMDEP=yasm
+AR=arm-none-linux-gnueabi-ar
+RANLIB=arm-none-linux-gnueabi-ranlib
+CP=cp -p
+LN_S=ln -sf
+STRIP=arm-none-linux-gnueabi-strip
+CPPFLAGS= -D_ISOC99_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600
+CFLAGS=   -std=c99 -fomit-frame-pointer -marm  -g -Wdeclaration-after-statement -Wall -Wno-parentheses -Wno-switch -Wdisabled-optimization -Wpointer-arith -Wredundant-decls -Wno-pointer-sign -Wcast-qual -Wwrite-strings -Wtype-limits -Wundef -Wmissing-prototypes -Wno-pointer-to-int-cast -O3 -fno-math-errno -fno-signed-zeros -fno-tree-vectorize -Werror=implicit-function-declaration -Werror=missing-prototypes
+ASFLAGS=   -g
+CC_O=-o $@
+LDFLAGS= -Wl,--as-needed -Wl,--warn-common -Wl,-rpath-link,libpostproc -Wl,-rpath-link,libswscale -Wl,-rpath-link,libavfilter -Wl,-rpath-link,libavdevice -Wl,-rpath-link,libavformat -Wl,-rpath-link,libavcodec -Wl,-rpath-link,libavutil
+FFSERVERLDFLAGS=-Wl,-E
+SHFLAGS=-shared -Wl,-soname,$$(@F) -Wl,-Bsymbolic -Wl,--version-script,$(SUBDIR)lib$(NAME).ver
+YASMFLAGS=
+BUILDSUF=
+FULLNAME=$(NAME)$(BUILDSUF)
+LIBPREF=lib
+LIBSUF=.a
+LIBNAME=$(LIBPREF)$(FULLNAME)$(LIBSUF)
+SLIBPREF=lib
+SLIBSUF=.so
+EXESUF=
+EXTRA_VERSION=
+DEPFLAGS=$(CPPFLAGS) $(CFLAGS) -MM
+CCDEP=
+ASDEP=
+CC_DEPFLAGS=-MMD -MF $(@:.o=.d) -MT $@
+AS_DEPFLAGS=-MMD -MF $(@:.o=.d) -MT $@
+HOSTCC=gcc
+HOSTCFLAGS=-D_ISOC99_SOURCE -O3 -g -std=c99 -Wall
+HOSTEXESUF=
+HOSTLDFLAGS=
+HOSTLIBS=-lm
+TARGET_EXEC=
+TARGET_PATH=$(CURDIR)
+SDL_LIBS=
+SDL_CFLAGS=
+LIB_INSTALL_EXTRA_CMD=$$(RANLIB) "$(LIBDIR)/$(LIBNAME)"
+EXTRALIBS=-ldl -lm -pthread 
+INSTALL=install
+LIBTARGET=
+SLIBNAME=$(SLIBPREF)$(FULLNAME)$(SLIBSUF)
+SLIBNAME_WITH_VERSION=$(SLIBNAME).$(LIBVERSION)
+SLIBNAME_WITH_MAJOR=$(SLIBNAME).$(LIBMAJOR)
+SLIB_CREATE_DEF_CMD=
+SLIB_EXTRA_CMD=
+SLIB_INSTALL_EXTRA_CMD=
+SLIB_UNINSTALL_EXTRA_CMD=
+SAMPLES:=$(FATE_SAMPLES)
+libswscale_VERSION=2.0.0
+libswscale_VERSION_MAJOR=2
+libpostproc_VERSION=51.2.0
+libpostproc_VERSION_MAJOR=51
+libavcodec_VERSION=53.7.0
+libavcodec_VERSION_MAJOR=53
+libavdevice_VERSION=53.1.1
+libavdevice_VERSION_MAJOR=53
+libavformat_VERSION=53.4.0
+libavformat_VERSION_MAJOR=53
+libavutil_VERSION=51.9.1
+libavutil_VERSION_MAJOR=51
+libavfilter_VERSION=2.23.0
+libavfilter_VERSION_MAJOR=2
+FFMPEG_VER=0.8
+
+!ARCH_ALPHA=yes
+ARCH_ARM=yes
+!ARCH_AVR32=yes
+!ARCH_AVR32_AP=yes
+!ARCH_AVR32_UC=yes
+!ARCH_BFIN=yes
+!ARCH_IA64=yes
+!ARCH_M68K=yes
+!ARCH_MIPS=yes
+!ARCH_MIPS64=yes
+!ARCH_PARISC=yes
+!ARCH_PPC=yes
+!ARCH_PPC64=yes
+!ARCH_S390=yes
+!ARCH_SH4=yes
+!ARCH_SPARC=yes
+!ARCH_SPARC64=yes
+!ARCH_TOMI=yes
+!ARCH_X86=yes
+!ARCH_X86_32=yes
+!ARCH_X86_64=yes
+!HAVE_ALTIVEC=yes
+!HAVE_AMD3DNOW=yes
+!HAVE_AMD3DNOWEXT=yes
+!HAVE_ARMV5TE=yes
+!HAVE_ARMV6=yes
+!HAVE_ARMV6T2=yes
+!HAVE_ARMVFP=yes
+!HAVE_AVX=yes
+!HAVE_IWMMXT=yes
+!HAVE_MMI=yes
+!HAVE_MMX=yes
+!HAVE_MMX2=yes
+HAVE_NEON=yes
+!HAVE_PPC4XX=yes
+!HAVE_SSE=yes
+!HAVE_SSSE3=yes
+!HAVE_VFPV3=yes
+!HAVE_VIS=yes
+!HAVE_BIGENDIAN=yes
+!HAVE_FAST_UNALIGNED=yes
+HAVE_PTHREADS=yes
+!HAVE_W32THREADS=yes
+!HAVE_ALIGNED_STACK=yes
+!HAVE_ALSA_ASOUNDLIB_H=yes
+!HAVE_ALTIVEC_H=yes
+HAVE_ARPA_INET_H=yes
+HAVE_ATTRIBUTE_MAY_ALIAS=yes
+HAVE_ATTRIBUTE_PACKED=yes
+!HAVE_BSWAP=yes
+!HAVE_CLOSESOCKET=yes
+!HAVE_CMOV=yes
+!HAVE_DCBZL=yes
+!HAVE_DEV_BKTR_IOCTL_BT848_H=yes
+!HAVE_DEV_BKTR_IOCTL_METEOR_H=yes
+!HAVE_DEV_IC_BT8XX_H=yes
+!HAVE_DEV_VIDEO_METEOR_IOCTL_METEOR_H=yes
+!HAVE_DEV_VIDEO_BKTR_IOCTL_BT848_H=yes
+HAVE_DLFCN_H=yes
+HAVE_DLOPEN=yes
+!HAVE_DOS_PATHS=yes
+!HAVE_EBP_AVAILABLE=yes
+!HAVE_EBX_AVAILABLE=yes
+HAVE_EXP2=yes
+HAVE_EXP2F=yes
+!HAVE_FAST_64BIT=yes
+!HAVE_FAST_CLZ=yes
+!HAVE_FAST_CMOV=yes
+HAVE_FCNTL=yes
+HAVE_FORK=yes
+HAVE_GETADDRINFO=yes
+!HAVE_GETHRTIME=yes
+!HAVE_GETPROCESSMEMORYINFO=yes
+!HAVE_GETPROCESSTIMES=yes
+HAVE_GETRUSAGE=yes
+HAVE_GNU_AS=yes
+HAVE_STRUCT_RUSAGE_RU_MAXRSS=yes
+!HAVE_IBM_ASM=yes
+HAVE_INET_ATON=yes
+HAVE_INLINE_ASM=yes
+HAVE_ISATTY=yes
+!HAVE_KBHIT=yes
+!HAVE_LDBRX=yes
+HAVE_LLRINT=yes
+HAVE_LLRINTF=yes
+!HAVE_LOCAL_ALIGNED_16=yes
+!HAVE_LOCAL_ALIGNED_8=yes
+HAVE_LOCALTIME_R=yes
+HAVE_LOG2=yes
+HAVE_LOG2F=yes
+!HAVE_LOONGSON=yes
+HAVE_LRINT=yes
+HAVE_LRINTF=yes
+!HAVE_LZO1X_999_COMPRESS=yes
+!HAVE_MACHINE_IOCTL_BT848_H=yes
+!HAVE_MACHINE_IOCTL_METEOR_H=yes
+HAVE_MALLOC_H=yes
+!HAVE_MAPVIEWOFFILE=yes
+HAVE_MEMALIGN=yes
+HAVE_MKSTEMP=yes
+HAVE_MMAP=yes
+!HAVE_PLD=yes
+HAVE_POSIX_MEMALIGN=yes
+HAVE_ROUND=yes
+HAVE_ROUNDF=yes
+!HAVE_SDL=yes
+!HAVE_SDL_VIDEO_SIZE=yes
+!HAVE_SETMODE=yes
+!HAVE_SNDIO_H=yes
+HAVE_SOCKLEN_T=yes
+!HAVE_SOUNDCARD_H=yes
+HAVE_POLL_H=yes
+HAVE_SETRLIMIT=yes
+HAVE_STRERROR_R=yes
+HAVE_STRTOK_R=yes
+HAVE_STRUCT_ADDRINFO=yes
+HAVE_STRUCT_IPV6_MREQ=yes
+HAVE_STRUCT_SOCKADDR_IN6=yes
+!HAVE_STRUCT_SOCKADDR_SA_LEN=yes
+HAVE_STRUCT_SOCKADDR_STORAGE=yes
+HAVE_SYMVER=yes
+HAVE_SYMVER_GNU_ASM=yes
+!HAVE_SYMVER_ASM_LABEL=yes
+HAVE_SYS_MMAN_H=yes
+HAVE_SYS_RESOURCE_H=yes
+HAVE_SYS_SELECT_H=yes
+HAVE_SYS_SOUNDCARD_H=yes
+!HAVE_SYS_VIDEOIO_H=yes
+!HAVE_TEN_OPERANDS=yes
+HAVE_TERMIOS_H=yes
+HAVE_THREADS=yes
+HAVE_TRUNC=yes
+HAVE_TRUNCF=yes
+!HAVE_VFP_ARGS=yes
+!HAVE_VIRTUALALLOC=yes
+!HAVE_WINSOCK2_H=yes
+!HAVE_XFORM_ASM=yes
+!HAVE_XMM_CLOBBERS=yes
+!HAVE_YASM=yes
+CONFIG_BSFS=yes
+CONFIG_DECODERS=yes
+CONFIG_DEMUXERS=yes
+CONFIG_FILTERS=yes
+!CONFIG_HWACCELS=yes
+CONFIG_INDEVS=yes
+CONFIG_MUXERS=yes
+CONFIG_OUTDEVS=yes
+CONFIG_PARSERS=yes
+CONFIG_PROTOCOLS=yes
+CONFIG_AANDCT=yes
+!CONFIG_AC3DSP=yes
+CONFIG_AVCODEC=yes
+CONFIG_AVDEVICE=yes
+CONFIG_AVFILTER=yes
+CONFIG_AVFORMAT=yes
+!CONFIG_AVISYNTH=yes
+!CONFIG_BZLIB=yes
+!CONFIG_CRYSTALHD=yes
+CONFIG_DCT=yes
+!CONFIG_DOC=yes
+CONFIG_DWT=yes
+!CONFIG_DXVA2=yes
+CONFIG_FASTDIV=yes
+CONFIG_FFMPEG=yes
+!CONFIG_FFPLAY=yes
+CONFIG_FFPROBE=yes
+CONFIG_FFSERVER=yes
+CONFIG_FFT=yes
+!CONFIG_FREI0R=yes
+CONFIG_GOLOMB=yes
+!CONFIG_GPL=yes
+!CONFIG_GRAY=yes
+CONFIG_H264DSP=yes
+CONFIG_H264PRED=yes
+!CONFIG_HARDCODED_TABLES=yes
+CONFIG_HUFFMAN=yes
+!CONFIG_LIBCELT=yes
+!CONFIG_LIBDC1394=yes
+!CONFIG_LIBDIRAC=yes
+!CONFIG_LIBFAAC=yes
+!CONFIG_LIBFREETYPE=yes
+!CONFIG_LIBGSM=yes
+!CONFIG_LIBMP3LAME=yes
+!CONFIG_LIBNUT=yes
+!CONFIG_LIBOPENCORE_AMRNB=yes
+!CONFIG_LIBOPENCORE_AMRWB=yes
+!CONFIG_LIBOPENCV=yes
+!CONFIG_LIBOPENJPEG=yes
+!CONFIG_LIBRTMP=yes
+!CONFIG_LIBSCHROEDINGER=yes
+!CONFIG_LIBSPEEX=yes
+!CONFIG_LIBTHEORA=yes
+!CONFIG_LIBVO_AACENC=yes
+!CONFIG_LIBVO_AMRWBENC=yes
+!CONFIG_LIBVORBIS=yes
+!CONFIG_LIBVPX=yes
+!CONFIG_LIBX264=yes
+!CONFIG_LIBXAVS=yes
+!CONFIG_LIBXVID=yes
+CONFIG_LPC=yes
+CONFIG_LSP=yes
+CONFIG_MDCT=yes
+!CONFIG_MEMALIGN_HACK=yes
+!CONFIG_MLIB=yes
+CONFIG_MPEGAUDIODSP=yes
+CONFIG_NETWORK=yes
+!CONFIG_NONFREE=yes
+!CONFIG_PIC=yes
+!CONFIG_POSTPROC=yes
+CONFIG_RDFT=yes
+CONFIG_RTPDEC=yes
+!CONFIG_RUNTIME_CPUDETECT=yes
+!CONFIG_SHARED=yes
+CONFIG_SINEWIN=yes
+!CONFIG_SMALL=yes
+!CONFIG_SRAM=yes
+CONFIG_STATIC=yes
+CONFIG_SWSCALE=yes
+CONFIG_SWSCALE_ALPHA=yes
+!CONFIG_VAAPI=yes
+!CONFIG_VDPAU=yes
+!CONFIG_VERSION3=yes
+!CONFIG_X11GRAB=yes
+!CONFIG_ZLIB=yes
+CONFIG_AVUTIL=yes
+!CONFIG_GPLV3=yes
+!CONFIG_LGPLV3=yes
+CONFIG_AASC_DECODER=yes
+CONFIG_AMV_DECODER=yes
+CONFIG_ANM_DECODER=yes
+CONFIG_ANSI_DECODER=yes
+CONFIG_ASV1_DECODER=yes
+CONFIG_ASV2_DECODER=yes
+CONFIG_AURA_DECODER=yes
+CONFIG_AURA2_DECODER=yes
+CONFIG_AVS_DECODER=yes
+CONFIG_BETHSOFTVID_DECODER=yes
+CONFIG_BFI_DECODER=yes
+CONFIG_BINK_DECODER=yes
+CONFIG_BMP_DECODER=yes
+CONFIG_C93_DECODER=yes
+CONFIG_CAVS_DECODER=yes
+CONFIG_CDGRAPHICS_DECODER=yes
+CONFIG_CINEPAK_DECODER=yes
+CONFIG_CLJR_DECODER=yes
+CONFIG_CSCD_DECODER=yes
+CONFIG_CYUV_DECODER=yes
+CONFIG_DFA_DECODER=yes
+CONFIG_DNXHD_DECODER=yes
+CONFIG_DPX_DECODER=yes
+CONFIG_DSICINVIDEO_DECODER=yes
+CONFIG_DVVIDEO_DECODER=yes
+!CONFIG_DXA_DECODER=yes
+CONFIG_EACMV_DECODER=yes
+CONFIG_EAMAD_DECODER=yes
+CONFIG_EATGQ_DECODER=yes
+CONFIG_EATGV_DECODER=yes
+CONFIG_EATQI_DECODER=yes
+CONFIG_EIGHTBPS_DECODER=yes
+CONFIG_EIGHTSVX_EXP_DECODER=yes
+CONFIG_EIGHTSVX_FIB_DECODER=yes
+CONFIG_EIGHTSVX_RAW_DECODER=yes
+CONFIG_ESCAPE124_DECODER=yes
+CONFIG_FFV1_DECODER=yes
+CONFIG_FFVHUFF_DECODER=yes
+!CONFIG_FLASHSV_DECODER=yes
+CONFIG_FLIC_DECODER=yes
+CONFIG_FLV_DECODER=yes
+CONFIG_FOURXM_DECODER=yes
+CONFIG_FRAPS_DECODER=yes
+CONFIG_FRWU_DECODER=yes
+CONFIG_GIF_DECODER=yes
+CONFIG_H261_DECODER=yes
+CONFIG_H263_DECODER=yes
+CONFIG_H263I_DECODER=yes
+CONFIG_H264_DECODER=yes
+!CONFIG_H264_CRYSTALHD_DECODER=yes
+!CONFIG_H264_VDPAU_DECODER=yes
+CONFIG_HUFFYUV_DECODER=yes
+CONFIG_IDCIN_DECODER=yes
+CONFIG_IFF_BYTERUN1_DECODER=yes
+CONFIG_IFF_ILBM_DECODER=yes
+CONFIG_INDEO2_DECODER=yes
+CONFIG_INDEO3_DECODER=yes
+CONFIG_INDEO5_DECODER=yes
+CONFIG_INTERPLAY_VIDEO_DECODER=yes
+CONFIG_JPEG2000_DECODER=yes
+CONFIG_JPEGLS_DECODER=yes
+CONFIG_JV_DECODER=yes
+CONFIG_KGV1_DECODER=yes
+CONFIG_KMVC_DECODER=yes
+CONFIG_LAGARITH_DECODER=yes
+CONFIG_LOCO_DECODER=yes
+CONFIG_MDEC_DECODER=yes
+CONFIG_MIMIC_DECODER=yes
+CONFIG_MJPEG_DECODER=yes
+CONFIG_MJPEGB_DECODER=yes
+CONFIG_MMVIDEO_DECODER=yes
+CONFIG_MOTIONPIXELS_DECODER=yes
+!CONFIG_MPEG_XVMC_DECODER=yes
+CONFIG_MPEG1VIDEO_DECODER=yes
+CONFIG_MPEG2VIDEO_DECODER=yes
+CONFIG_MPEG4_DECODER=yes
+!CONFIG_MPEG4_CRYSTALHD_DECODER=yes
+!CONFIG_MPEG4_VDPAU_DECODER=yes
+CONFIG_MPEGVIDEO_DECODER=yes
+!CONFIG_MPEG_VDPAU_DECODER=yes
+!CONFIG_MPEG1_VDPAU_DECODER=yes
+!CONFIG_MPEG2_CRYSTALHD_DECODER=yes
+!CONFIG_MSMPEG4_CRYSTALHD_DECODER=yes
+CONFIG_MSMPEG4V1_DECODER=yes
+CONFIG_MSMPEG4V2_DECODER=yes
+CONFIG_MSMPEG4V3_DECODER=yes
+CONFIG_MSRLE_DECODER=yes
+CONFIG_MSVIDEO1_DECODER=yes
+CONFIG_MSZH_DECODER=yes
+CONFIG_MXPEG_DECODER=yes
+CONFIG_NUV_DECODER=yes
+CONFIG_PAM_DECODER=yes
+CONFIG_PBM_DECODER=yes
+CONFIG_PCX_DECODER=yes
+CONFIG_PGM_DECODER=yes
+CONFIG_PGMYUV_DECODER=yes
+CONFIG_PICTOR_DECODER=yes
+!CONFIG_PNG_DECODER=yes
+CONFIG_PPM_DECODER=yes
+CONFIG_PTX_DECODER=yes
+CONFIG_QDRAW_DECODER=yes
+CONFIG_QPEG_DECODER=yes
+CONFIG_QTRLE_DECODER=yes
+CONFIG_R10K_DECODER=yes
+CONFIG_R210_DECODER=yes
+CONFIG_RAWVIDEO_DECODER=yes
+CONFIG_RL2_DECODER=yes
+CONFIG_ROQ_DECODER=yes
+CONFIG_RPZA_DECODER=yes
+CONFIG_RV10_DECODER=yes
+CONFIG_RV20_DECODER=yes
+CONFIG_RV30_DECODER=yes
+CONFIG_RV40_DECODER=yes
+CONFIG_S302M_DECODER=yes
+CONFIG_SGI_DECODER=yes
+CONFIG_SMACKER_DECODER=yes
+CONFIG_SMC_DECODER=yes
+CONFIG_SNOW_DECODER=yes
+CONFIG_SP5X_DECODER=yes
+CONFIG_SUNRAST_DECODER=yes
+CONFIG_SVQ1_DECODER=yes
+CONFIG_SVQ3_DECODER=yes
+CONFIG_TARGA_DECODER=yes
+CONFIG_THEORA_DECODER=yes
+CONFIG_THP_DECODER=yes
+CONFIG_TIERTEXSEQVIDEO_DECODER=yes
+CONFIG_TIFF_DECODER=yes
+CONFIG_TMV_DECODER=yes
+CONFIG_TRUEMOTION1_DECODER=yes
+CONFIG_TRUEMOTION2_DECODER=yes
+!CONFIG_TSCC_DECODER=yes
+CONFIG_TXD_DECODER=yes
+CONFIG_ULTI_DECODER=yes
+CONFIG_V210_DECODER=yes
+CONFIG_V210X_DECODER=yes
+CONFIG_VB_DECODER=yes
+CONFIG_VC1_DECODER=yes
+!CONFIG_VC1_CRYSTALHD_DECODER=yes
+!CONFIG_VC1_VDPAU_DECODER=yes
+CONFIG_VCR1_DECODER=yes
+CONFIG_VMDVIDEO_DECODER=yes
+CONFIG_VMNC_DECODER=yes
+CONFIG_VP3_DECODER=yes
+CONFIG_VP5_DECODER=yes
+CONFIG_VP6_DECODER=yes
+CONFIG_VP6A_DECODER=yes
+CONFIG_VP6F_DECODER=yes
+CONFIG_VP8_DECODER=yes
+CONFIG_VQA_DECODER=yes
+CONFIG_WMV1_DECODER=yes
+CONFIG_WMV2_DECODER=yes
+CONFIG_WMV3_DECODER=yes
+!CONFIG_WMV3_CRYSTALHD_DECODER=yes
+!CONFIG_WMV3_VDPAU_DECODER=yes
+CONFIG_WNV1_DECODER=yes
+CONFIG_XAN_WC3_DECODER=yes
+CONFIG_XAN_WC4_DECODER=yes
+CONFIG_XL_DECODER=yes
+CONFIG_YOP_DECODER=yes
+!CONFIG_ZLIB_DECODER=yes
+!CONFIG_ZMBV_DECODER=yes
+CONFIG_AAC_DECODER=yes
+CONFIG_AAC_LATM_DECODER=yes
+CONFIG_AC3_DECODER=yes
+CONFIG_ALAC_DECODER=yes
+CONFIG_ALS_DECODER=yes
+CONFIG_AMRNB_DECODER=yes
+CONFIG_AMRWB_DECODER=yes
+CONFIG_APE_DECODER=yes
+CONFIG_ATRAC1_DECODER=yes
+CONFIG_ATRAC3_DECODER=yes
+CONFIG_BINKAUDIO_DCT_DECODER=yes
+CONFIG_BINKAUDIO_RDFT_DECODER=yes
+CONFIG_COOK_DECODER=yes
+CONFIG_DCA_DECODER=yes
+CONFIG_DSICINAUDIO_DECODER=yes
+!CONFIG_EAC3_DECODER=yes
+CONFIG_FLAC_DECODER=yes
+CONFIG_GSM_DECODER=yes
+CONFIG_GSM_MS_DECODER=yes
+CONFIG_IMC_DECODER=yes
+CONFIG_MACE3_DECODER=yes
+CONFIG_MACE6_DECODER=yes
+!CONFIG_MLP_DECODER=yes
+CONFIG_MP1_DECODER=yes
+CONFIG_MP1FLOAT_DECODER=yes
+CONFIG_MP2_DECODER=yes
+CONFIG_MP2FLOAT_DECODER=yes
+CONFIG_MP3_DECODER=yes
+CONFIG_MP3FLOAT_DECODER=yes
+CONFIG_MP3ADU_DECODER=yes
+CONFIG_MP3ADUFLOAT_DECODER=yes
+CONFIG_MP3ON4_DECODER=yes
+CONFIG_MP3ON4FLOAT_DECODER=yes
+CONFIG_MPC7_DECODER=yes
+CONFIG_MPC8_DECODER=yes
+CONFIG_NELLYMOSER_DECODER=yes
+CONFIG_QCELP_DECODER=yes
+CONFIG_QDM2_DECODER=yes
+CONFIG_RA_144_DECODER=yes
+CONFIG_RA_288_DECODER=yes
+CONFIG_SHORTEN_DECODER=yes
+CONFIG_SIPR_DECODER=yes
+CONFIG_SMACKAUD_DECODER=yes
+CONFIG_SONIC_DECODER=yes
+CONFIG_TRUEHD_DECODER=yes
+CONFIG_TRUESPEECH_DECODER=yes
+CONFIG_TTA_DECODER=yes
+CONFIG_TWINVQ_DECODER=yes
+CONFIG_VMDAUDIO_DECODER=yes
+CONFIG_VORBIS_DECODER=yes
+CONFIG_WAVPACK_DECODER=yes
+CONFIG_WMAPRO_DECODER=yes
+CONFIG_WMAV1_DECODER=yes
+CONFIG_WMAV2_DECODER=yes
+CONFIG_WMAVOICE_DECODER=yes
+CONFIG_WS_SND1_DECODER=yes
+CONFIG_PCM_ALAW_DECODER=yes
+CONFIG_PCM_BLURAY_DECODER=yes
+CONFIG_PCM_DVD_DECODER=yes
+CONFIG_PCM_F32BE_DECODER=yes
+CONFIG_PCM_F32LE_DECODER=yes
+CONFIG_PCM_F64BE_DECODER=yes
+CONFIG_PCM_F64LE_DECODER=yes
+CONFIG_PCM_LXF_DECODER=yes
+CONFIG_PCM_MULAW_DECODER=yes
+CONFIG_PCM_S8_DECODER=yes
+CONFIG_PCM_S16BE_DECODER=yes
+CONFIG_PCM_S16LE_DECODER=yes
+CONFIG_PCM_S16LE_PLANAR_DECODER=yes
+CONFIG_PCM_S24BE_DECODER=yes
+CONFIG_PCM_S24DAUD_DECODER=yes
+CONFIG_PCM_S24LE_DECODER=yes
+CONFIG_PCM_S32BE_DECODER=yes
+CONFIG_PCM_S32LE_DECODER=yes
+CONFIG_PCM_U8_DECODER=yes
+CONFIG_PCM_U16BE_DECODER=yes
+CONFIG_PCM_U16LE_DECODER=yes
+CONFIG_PCM_U24BE_DECODER=yes
+CONFIG_PCM_U24LE_DECODER=yes
+CONFIG_PCM_U32BE_DECODER=yes
+CONFIG_PCM_U32LE_DECODER=yes
+CONFIG_PCM_ZORK_DECODER=yes
+CONFIG_INTERPLAY_DPCM_DECODER=yes
+CONFIG_ROQ_DPCM_DECODER=yes
+CONFIG_SOL_DPCM_DECODER=yes
+CONFIG_XAN_DPCM_DECODER=yes
+CONFIG_ADPCM_4XM_DECODER=yes
+CONFIG_ADPCM_ADX_DECODER=yes
+CONFIG_ADPCM_CT_DECODER=yes
+CONFIG_ADPCM_EA_DECODER=yes
+CONFIG_ADPCM_EA_MAXIS_XA_DECODER=yes
+CONFIG_ADPCM_EA_R1_DECODER=yes
+CONFIG_ADPCM_EA_R2_DECODER=yes
+CONFIG_ADPCM_EA_R3_DECODER=yes
+CONFIG_ADPCM_EA_XAS_DECODER=yes
+CONFIG_ADPCM_G722_DECODER=yes
+CONFIG_ADPCM_G726_DECODER=yes
+CONFIG_ADPCM_IMA_AMV_DECODER=yes
+CONFIG_ADPCM_IMA_DK3_DECODER=yes
+CONFIG_ADPCM_IMA_DK4_DECODER=yes
+CONFIG_ADPCM_IMA_EA_EACS_DECODER=yes
+CONFIG_ADPCM_IMA_EA_SEAD_DECODER=yes
+CONFIG_ADPCM_IMA_ISS_DECODER=yes
+CONFIG_ADPCM_IMA_QT_DECODER=yes
+CONFIG_ADPCM_IMA_SMJPEG_DECODER=yes
+CONFIG_ADPCM_IMA_WAV_DECODER=yes
+CONFIG_ADPCM_IMA_WS_DECODER=yes
+CONFIG_ADPCM_MS_DECODER=yes
+CONFIG_ADPCM_SBPRO_2_DECODER=yes
+CONFIG_ADPCM_SBPRO_3_DECODER=yes
+CONFIG_ADPCM_SBPRO_4_DECODER=yes
+CONFIG_ADPCM_SWF_DECODER=yes
+CONFIG_ADPCM_THP_DECODER=yes
+CONFIG_ADPCM_XA_DECODER=yes
+CONFIG_ADPCM_YAMAHA_DECODER=yes
+CONFIG_ASS_DECODER=yes
+CONFIG_DVBSUB_DECODER=yes
+CONFIG_DVDSUB_DECODER=yes
+CONFIG_PGSSUB_DECODER=yes
+CONFIG_SRT_DECODER=yes
+CONFIG_XSUB_DECODER=yes
+!CONFIG_LIBCELT_DECODER=yes
+!CONFIG_LIBDIRAC_DECODER=yes
+!CONFIG_LIBGSM_DECODER=yes
+!CONFIG_LIBGSM_MS_DECODER=yes
+!CONFIG_LIBOPENCORE_AMRNB_DECODER=yes
+!CONFIG_LIBOPENCORE_AMRWB_DECODER=yes
+!CONFIG_LIBOPENJPEG_DECODER=yes
+!CONFIG_LIBSCHROEDINGER_DECODER=yes
+!CONFIG_LIBSPEEX_DECODER=yes
+!CONFIG_LIBVPX_DECODER=yes
+!CONFIG_A64MULTI_ENCODER=yes
+!CONFIG_A64MULTI5_ENCODER=yes
+!CONFIG_ASV1_ENCODER=yes
+!CONFIG_ASV2_ENCODER=yes
+!CONFIG_BMP_ENCODER=yes
+!CONFIG_DNXHD_ENCODER=yes
+!CONFIG_DPX_ENCODER=yes
+!CONFIG_DVVIDEO_ENCODER=yes
+!CONFIG_FFV1_ENCODER=yes
+!CONFIG_FFVHUFF_ENCODER=yes
+!!CONFIG_FLASHSV_ENCODER=yes
+!!CONFIG_FLASHSV2_ENCODER=yes
+!CONFIG_FLV_ENCODER=yes
+!CONFIG_GIF_ENCODER=yes
+!CONFIG_H261_ENCODER=yes
+!CONFIG_H263_ENCODER=yes
+!CONFIG_H263P_ENCODER=yes
+!CONFIG_HUFFYUV_ENCODER=yes
+!CONFIG_JPEGLS_ENCODER=yes
+!CONFIG_LJPEG_ENCODER=yes
+!CONFIG_MJPEG_ENCODER=yes
+!CONFIG_MPEG1VIDEO_ENCODER=yes
+!CONFIG_MPEG2VIDEO_ENCODER=yes
+!CONFIG_MPEG4_ENCODER=yes
+!CONFIG_MSMPEG4V2_ENCODER=yes
+!CONFIG_MSMPEG4V3_ENCODER=yes
+!CONFIG_MSVIDEO1_ENCODER=yes
+!CONFIG_PAM_ENCODER=yes
+!CONFIG_PBM_ENCODER=yes
+!CONFIG_PCX_ENCODER=yes
+!CONFIG_PGM_ENCODER=yes
+!CONFIG_PGMYUV_ENCODER=yes
+!!CONFIG_PNG_ENCODER=yes
+!CONFIG_PPM_ENCODER=yes
+!CONFIG_QTRLE_ENCODER=yes
+!CONFIG_RAWVIDEO_ENCODER=yes
+!CONFIG_ROQ_ENCODER=yes
+!CONFIG_RV10_ENCODER=yes
+!CONFIG_RV20_ENCODER=yes
+!CONFIG_SGI_ENCODER=yes
+!CONFIG_SNOW_ENCODER=yes
+!CONFIG_SVQ1_ENCODER=yes
+!CONFIG_TARGA_ENCODER=yes
+!CONFIG_TIFF_ENCODER=yes
+!CONFIG_V210_ENCODER=yes
+!CONFIG_WMV1_ENCODER=yes
+!CONFIG_WMV2_ENCODER=yes
+!!CONFIG_ZLIB_ENCODER=yes
+!!CONFIG_ZMBV_ENCODER=yes
+!CONFIG_AAC_ENCODER=yes
+!CONFIG_AC3_ENCODER=yes
+!CONFIG_AC3_FIXED_ENCODER=yes
+!CONFIG_AC3_FLOAT_ENCODER=yes
+!CONFIG_ALAC_ENCODER=yes
+!CONFIG_DCA_ENCODER=yes
+!CONFIG_EAC3_ENCODER=yes
+!CONFIG_FLAC_ENCODER=yes
+!CONFIG_MP2_ENCODER=yes
+!CONFIG_NELLYMOSER_ENCODER=yes
+!CONFIG_RA_144_ENCODER=yes
+!CONFIG_SONIC_ENCODER=yes
+!CONFIG_SONIC_LS_ENCODER=yes
+!CONFIG_VORBIS_ENCODER=yes
+!CONFIG_WMAV1_ENCODER=yes
+!CONFIG_WMAV2_ENCODER=yes
+!CONFIG_PCM_ALAW_ENCODER=yes
+!CONFIG_PCM_F32BE_ENCODER=yes
+!CONFIG_PCM_F32LE_ENCODER=yes
+!CONFIG_PCM_F64BE_ENCODER=yes
+!CONFIG_PCM_F64LE_ENCODER=yes
+!CONFIG_PCM_MULAW_ENCODER=yes
+!CONFIG_PCM_S8_ENCODER=yes
+!CONFIG_PCM_S16BE_ENCODER=yes
+!CONFIG_PCM_S16LE_ENCODER=yes
+!CONFIG_PCM_S24BE_ENCODER=yes
+!CONFIG_PCM_S24DAUD_ENCODER=yes
+!CONFIG_PCM_S24LE_ENCODER=yes
+!CONFIG_PCM_S32BE_ENCODER=yes
+!CONFIG_PCM_S32LE_ENCODER=yes
+!CONFIG_PCM_U8_ENCODER=yes
+!CONFIG_PCM_U16BE_ENCODER=yes
+!CONFIG_PCM_U16LE_ENCODER=yes
+!CONFIG_PCM_U24BE_ENCODER=yes
+!CONFIG_PCM_U24LE_ENCODER=yes
+!CONFIG_PCM_U32BE_ENCODER=yes
+!CONFIG_PCM_U32LE_ENCODER=yes
+!CONFIG_PCM_ZORK_ENCODER=yes
+!CONFIG_ROQ_DPCM_ENCODER=yes
+!CONFIG_ADPCM_ADX_ENCODER=yes
+!CONFIG_ADPCM_G722_ENCODER=yes
+!CONFIG_ADPCM_G726_ENCODER=yes
+!CONFIG_ADPCM_IMA_QT_ENCODER=yes
+!CONFIG_ADPCM_IMA_WAV_ENCODER=yes
+!CONFIG_ADPCM_MS_ENCODER=yes
+!CONFIG_ADPCM_SWF_ENCODER=yes
+!CONFIG_ADPCM_YAMAHA_ENCODER=yes
+!CONFIG_ASS_ENCODER=yes
+!CONFIG_DVBSUB_ENCODER=yes
+!CONFIG_DVDSUB_ENCODER=yes
+!CONFIG_SRT_ENCODER=yes
+!CONFIG_XSUB_ENCODER=yes
+!CONFIG_LIBDIRAC_ENCODER=yes
+!CONFIG_LIBFAAC_ENCODER=yes
+!CONFIG_LIBGSM_ENCODER=yes
+!CONFIG_LIBGSM_MS_ENCODER=yes
+!CONFIG_LIBMP3LAME_ENCODER=yes
+!CONFIG_LIBOPENCORE_AMRNB_ENCODER=yes
+!CONFIG_LIBSCHROEDINGER_ENCODER=yes
+!CONFIG_LIBTHEORA_ENCODER=yes
+!CONFIG_LIBVO_AACENC_ENCODER=yes
+!CONFIG_LIBVO_AMRWBENC_ENCODER=yes
+!CONFIG_LIBVORBIS_ENCODER=yes
+!CONFIG_LIBVPX_ENCODER=yes
+!CONFIG_LIBX264_ENCODER=yes
+!CONFIG_LIBXAVS_ENCODER=yes
+!CONFIG_LIBXVID_ENCODER=yes
+!CONFIG_H263_VAAPI_HWACCEL=yes
+!CONFIG_H264_DXVA2_HWACCEL=yes
+!CONFIG_H264_VAAPI_HWACCEL=yes
+!CONFIG_MPEG1_VDPAU_HWACCEL=yes
+!CONFIG_MPEG2_DXVA2_HWACCEL=yes
+!CONFIG_MPEG2_VAAPI_HWACCEL=yes
+!CONFIG_MPEG2_VDPAU_HWACCEL=yes
+!CONFIG_MPEG4_VAAPI_HWACCEL=yes
+!CONFIG_VC1_DXVA2_HWACCEL=yes
+!CONFIG_VC1_VAAPI_HWACCEL=yes
+!CONFIG_WMV3_DXVA2_HWACCEL=yes
+!CONFIG_WMV3_VAAPI_HWACCEL=yes
+CONFIG_AAC_PARSER=yes
+CONFIG_AAC_LATM_PARSER=yes
+CONFIG_AC3_PARSER=yes
+CONFIG_CAVSVIDEO_PARSER=yes
+CONFIG_DCA_PARSER=yes
+CONFIG_DIRAC_PARSER=yes
+CONFIG_DNXHD_PARSER=yes
+CONFIG_DVBSUB_PARSER=yes
+CONFIG_DVDSUB_PARSER=yes
+CONFIG_FLAC_PARSER=yes
+CONFIG_H261_PARSER=yes
+CONFIG_H263_PARSER=yes
+CONFIG_H264_PARSER=yes
+CONFIG_MJPEG_PARSER=yes
+CONFIG_MLP_PARSER=yes
+CONFIG_MPEG4VIDEO_PARSER=yes
+CONFIG_MPEGAUDIO_PARSER=yes
+CONFIG_MPEGVIDEO_PARSER=yes
+CONFIG_PNM_PARSER=yes
+CONFIG_VC1_PARSER=yes
+CONFIG_VP3_PARSER=yes
+CONFIG_VP8_PARSER=yes
+CONFIG_AAC_ADTSTOASC_BSF=yes
+CONFIG_CHOMP_BSF=yes
+CONFIG_DUMP_EXTRADATA_BSF=yes
+CONFIG_H264_MP4TOANNEXB_BSF=yes
+CONFIG_IMX_DUMP_HEADER_BSF=yes
+CONFIG_MJPEG2JPEG_BSF=yes
+CONFIG_MJPEGA_DUMP_HEADER_BSF=yes
+CONFIG_MP3_HEADER_COMPRESS_BSF=yes
+CONFIG_MP3_HEADER_DECOMPRESS_BSF=yes
+CONFIG_MOV2TEXTSUB_BSF=yes
+CONFIG_NOISE_BSF=yes
+CONFIG_REMOVE_EXTRADATA_BSF=yes
+CONFIG_TEXT2MOVSUB_BSF=yes
+CONFIG_AAC_DEMUXER=yes
+CONFIG_AC3_DEMUXER=yes
+CONFIG_AEA_DEMUXER=yes
+CONFIG_AIFF_DEMUXER=yes
+CONFIG_AMR_DEMUXER=yes
+CONFIG_ANM_DEMUXER=yes
+CONFIG_APC_DEMUXER=yes
+CONFIG_APE_DEMUXER=yes
+CONFIG_APPLEHTTP_DEMUXER=yes
+CONFIG_ASF_DEMUXER=yes
+CONFIG_ASS_DEMUXER=yes
+CONFIG_AU_DEMUXER=yes
+CONFIG_AVI_DEMUXER=yes
+!CONFIG_AVISYNTH_DEMUXER=yes
+CONFIG_AVS_DEMUXER=yes
+CONFIG_BETHSOFTVID_DEMUXER=yes
+CONFIG_BFI_DEMUXER=yes
+CONFIG_BINK_DEMUXER=yes
+CONFIG_C93_DEMUXER=yes
+CONFIG_CAF_DEMUXER=yes
+CONFIG_CAVSVIDEO_DEMUXER=yes
+CONFIG_CDG_DEMUXER=yes
+CONFIG_DAUD_DEMUXER=yes
+CONFIG_DFA_DEMUXER=yes
+CONFIG_DIRAC_DEMUXER=yes
+CONFIG_DNXHD_DEMUXER=yes
+CONFIG_DSICIN_DEMUXER=yes
+CONFIG_DTS_DEMUXER=yes
+CONFIG_DV_DEMUXER=yes
+CONFIG_DXA_DEMUXER=yes
+CONFIG_EA_DEMUXER=yes
+CONFIG_EA_CDATA_DEMUXER=yes
+CONFIG_EAC3_DEMUXER=yes
+CONFIG_FFM_DEMUXER=yes
+CONFIG_FFMETADATA_DEMUXER=yes
+CONFIG_FILMSTRIP_DEMUXER=yes
+CONFIG_FLAC_DEMUXER=yes
+CONFIG_FLIC_DEMUXER=yes
+CONFIG_FLV_DEMUXER=yes
+CONFIG_FOURXM_DEMUXER=yes
+CONFIG_G722_DEMUXER=yes
+CONFIG_GSM_DEMUXER=yes
+CONFIG_GXF_DEMUXER=yes
+CONFIG_H261_DEMUXER=yes
+CONFIG_H263_DEMUXER=yes
+CONFIG_H264_DEMUXER=yes
+CONFIG_IDCIN_DEMUXER=yes
+CONFIG_IFF_DEMUXER=yes
+CONFIG_IMAGE2_DEMUXER=yes
+CONFIG_IMAGE2PIPE_DEMUXER=yes
+CONFIG_INGENIENT_DEMUXER=yes
+CONFIG_IPMOVIE_DEMUXER=yes
+CONFIG_ISS_DEMUXER=yes
+CONFIG_IV8_DEMUXER=yes
+CONFIG_IVF_DEMUXER=yes
+CONFIG_JV_DEMUXER=yes
+CONFIG_LMLM4_DEMUXER=yes
+CONFIG_LXF_DEMUXER=yes
+CONFIG_M4V_DEMUXER=yes
+CONFIG_MATROSKA_DEMUXER=yes
+CONFIG_MICRODVD_DEMUXER=yes
+CONFIG_MJPEG_DEMUXER=yes
+CONFIG_MLP_DEMUXER=yes
+CONFIG_MM_DEMUXER=yes
+CONFIG_MMF_DEMUXER=yes
+CONFIG_MOV_DEMUXER=yes
+CONFIG_MP3_DEMUXER=yes
+CONFIG_MPC_DEMUXER=yes
+CONFIG_MPC8_DEMUXER=yes
+CONFIG_MPEGPS_DEMUXER=yes
+CONFIG_MPEGTS_DEMUXER=yes
+CONFIG_MPEGTSRAW_DEMUXER=yes
+CONFIG_MPEGVIDEO_DEMUXER=yes
+CONFIG_MSNWC_TCP_DEMUXER=yes
+CONFIG_MTV_DEMUXER=yes
+CONFIG_MVI_DEMUXER=yes
+CONFIG_MXF_DEMUXER=yes
+CONFIG_MXG_DEMUXER=yes
+CONFIG_NC_DEMUXER=yes
+CONFIG_NSV_DEMUXER=yes
+CONFIG_NUT_DEMUXER=yes
+CONFIG_NUV_DEMUXER=yes
+CONFIG_OGG_DEMUXER=yes
+CONFIG_OMA_DEMUXER=yes
+CONFIG_PCM_ALAW_DEMUXER=yes
+CONFIG_PCM_MULAW_DEMUXER=yes
+CONFIG_PCM_F64BE_DEMUXER=yes
+CONFIG_PCM_F64LE_DEMUXER=yes
+CONFIG_PCM_F32BE_DEMUXER=yes
+CONFIG_PCM_F32LE_DEMUXER=yes
+CONFIG_PCM_S32BE_DEMUXER=yes
+CONFIG_PCM_S32LE_DEMUXER=yes
+CONFIG_PCM_S24BE_DEMUXER=yes
+CONFIG_PCM_S24LE_DEMUXER=yes
+CONFIG_PCM_S16BE_DEMUXER=yes
+CONFIG_PCM_S16LE_DEMUXER=yes
+CONFIG_PCM_S8_DEMUXER=yes
+CONFIG_PCM_U32BE_DEMUXER=yes
+CONFIG_PCM_U32LE_DEMUXER=yes
+CONFIG_PCM_U24BE_DEMUXER=yes
+CONFIG_PCM_U24LE_DEMUXER=yes
+CONFIG_PCM_U16BE_DEMUXER=yes
+CONFIG_PCM_U16LE_DEMUXER=yes
+CONFIG_PCM_U8_DEMUXER=yes
+CONFIG_PMP_DEMUXER=yes
+CONFIG_PVA_DEMUXER=yes
+CONFIG_QCP_DEMUXER=yes
+CONFIG_R3D_DEMUXER=yes
+CONFIG_RAWVIDEO_DEMUXER=yes
+CONFIG_RL2_DEMUXER=yes
+CONFIG_RM_DEMUXER=yes
+CONFIG_ROQ_DEMUXER=yes
+CONFIG_RPL_DEMUXER=yes
+CONFIG_RSO_DEMUXER=yes
+CONFIG_RTP_DEMUXER=yes
+CONFIG_RTSP_DEMUXER=yes
+CONFIG_SAP_DEMUXER=yes
+CONFIG_SDP_DEMUXER=yes
+CONFIG_SEGAFILM_DEMUXER=yes
+CONFIG_SHORTEN_DEMUXER=yes
+CONFIG_SIFF_DEMUXER=yes
+CONFIG_SMACKER_DEMUXER=yes
+CONFIG_SOL_DEMUXER=yes
+CONFIG_SOX_DEMUXER=yes
+CONFIG_SPDIF_DEMUXER=yes
+CONFIG_SRT_DEMUXER=yes
+CONFIG_STR_DEMUXER=yes
+CONFIG_SWF_DEMUXER=yes
+CONFIG_THP_DEMUXER=yes
+CONFIG_TIERTEXSEQ_DEMUXER=yes
+CONFIG_TMV_DEMUXER=yes
+CONFIG_TRUEHD_DEMUXER=yes
+CONFIG_TTA_DEMUXER=yes
+CONFIG_TXD_DEMUXER=yes
+CONFIG_TTY_DEMUXER=yes
+CONFIG_VC1_DEMUXER=yes
+CONFIG_VC1T_DEMUXER=yes
+CONFIG_VMD_DEMUXER=yes
+CONFIG_VOC_DEMUXER=yes
+CONFIG_VQF_DEMUXER=yes
+CONFIG_W64_DEMUXER=yes
+CONFIG_WAV_DEMUXER=yes
+CONFIG_WC3_DEMUXER=yes
+CONFIG_WSAUD_DEMUXER=yes
+CONFIG_WSVQA_DEMUXER=yes
+CONFIG_WTV_DEMUXER=yes
+CONFIG_WV_DEMUXER=yes
+CONFIG_XA_DEMUXER=yes
+CONFIG_XWMA_DEMUXER=yes
+CONFIG_YOP_DEMUXER=yes
+CONFIG_YUV4MPEGPIPE_DEMUXER=yes
+!CONFIG_LIBNUT_DEMUXER=yes
+CONFIG_A64_MUXER=yes
+CONFIG_AC3_MUXER=yes
+CONFIG_ADTS_MUXER=yes
+CONFIG_AIFF_MUXER=yes
+CONFIG_AMR_MUXER=yes
+CONFIG_ASF_MUXER=yes
+CONFIG_ASS_MUXER=yes
+CONFIG_ASF_STREAM_MUXER=yes
+CONFIG_AU_MUXER=yes
+CONFIG_AVI_MUXER=yes
+CONFIG_AVM2_MUXER=yes
+CONFIG_CAF_MUXER=yes
+CONFIG_CAVSVIDEO_MUXER=yes
+CONFIG_CRC_MUXER=yes
+CONFIG_DAUD_MUXER=yes
+CONFIG_DIRAC_MUXER=yes
+CONFIG_DNXHD_MUXER=yes
+CONFIG_DTS_MUXER=yes
+CONFIG_DV_MUXER=yes
+CONFIG_EAC3_MUXER=yes
+CONFIG_FFM_MUXER=yes
+CONFIG_FFMETADATA_MUXER=yes
+CONFIG_FILMSTRIP_MUXER=yes
+CONFIG_FLAC_MUXER=yes
+CONFIG_FLV_MUXER=yes
+CONFIG_FRAMECRC_MUXER=yes
+CONFIG_FRAMEMD5_MUXER=yes
+CONFIG_G722_MUXER=yes
+CONFIG_GIF_MUXER=yes
+CONFIG_GXF_MUXER=yes
+CONFIG_H261_MUXER=yes
+CONFIG_H263_MUXER=yes
+CONFIG_H264_MUXER=yes
+CONFIG_IMAGE2_MUXER=yes
+CONFIG_IMAGE2PIPE_MUXER=yes
+CONFIG_IPOD_MUXER=yes
+CONFIG_IVF_MUXER=yes
+CONFIG_M4V_MUXER=yes
+CONFIG_MD5_MUXER=yes
+CONFIG_MATROSKA_MUXER=yes
+CONFIG_MATROSKA_AUDIO_MUXER=yes
+CONFIG_MICRODVD_MUXER=yes
+CONFIG_MJPEG_MUXER=yes
+CONFIG_MLP_MUXER=yes
+CONFIG_MMF_MUXER=yes
+CONFIG_MOV_MUXER=yes
+CONFIG_MP2_MUXER=yes
+CONFIG_MP3_MUXER=yes
+CONFIG_MP4_MUXER=yes
+CONFIG_MPEG1SYSTEM_MUXER=yes
+CONFIG_MPEG1VCD_MUXER=yes
+CONFIG_MPEG1VIDEO_MUXER=yes
+CONFIG_MPEG2DVD_MUXER=yes
+CONFIG_MPEG2SVCD_MUXER=yes
+CONFIG_MPEG2VIDEO_MUXER=yes
+CONFIG_MPEG2VOB_MUXER=yes
+CONFIG_MPEGTS_MUXER=yes
+CONFIG_MPJPEG_MUXER=yes
+CONFIG_MXF_MUXER=yes
+CONFIG_MXF_D10_MUXER=yes
+CONFIG_NULL_MUXER=yes
+CONFIG_NUT_MUXER=yes
+CONFIG_OGG_MUXER=yes
+CONFIG_PCM_ALAW_MUXER=yes
+CONFIG_PCM_MULAW_MUXER=yes
+CONFIG_PCM_F64BE_MUXER=yes
+CONFIG_PCM_F64LE_MUXER=yes
+CONFIG_PCM_F32BE_MUXER=yes
+CONFIG_PCM_F32LE_MUXER=yes
+CONFIG_PCM_S32BE_MUXER=yes
+CONFIG_PCM_S32LE_MUXER=yes
+CONFIG_PCM_S24BE_MUXER=yes
+CONFIG_PCM_S24LE_MUXER=yes
+CONFIG_PCM_S16BE_MUXER=yes
+CONFIG_PCM_S16LE_MUXER=yes
+CONFIG_PCM_S8_MUXER=yes
+CONFIG_PCM_U32BE_MUXER=yes
+CONFIG_PCM_U32LE_MUXER=yes
+CONFIG_PCM_U24BE_MUXER=yes
+CONFIG_PCM_U24LE_MUXER=yes
+CONFIG_PCM_U16BE_MUXER=yes
+CONFIG_PCM_U16LE_MUXER=yes
+CONFIG_PCM_U8_MUXER=yes
+CONFIG_PSP_MUXER=yes
+CONFIG_RAWVIDEO_MUXER=yes
+CONFIG_RM_MUXER=yes
+CONFIG_ROQ_MUXER=yes
+CONFIG_RSO_MUXER=yes
+CONFIG_RTP_MUXER=yes
+CONFIG_RTSP_MUXER=yes
+CONFIG_SAP_MUXER=yes
+CONFIG_SOX_MUXER=yes
+CONFIG_SPDIF_MUXER=yes
+CONFIG_SRT_MUXER=yes
+CONFIG_SWF_MUXER=yes
+CONFIG_TG2_MUXER=yes
+CONFIG_TGP_MUXER=yes
+CONFIG_TRUEHD_MUXER=yes
+CONFIG_VC1T_MUXER=yes
+CONFIG_VOC_MUXER=yes
+CONFIG_WAV_MUXER=yes
+CONFIG_WEBM_MUXER=yes
+CONFIG_YUV4MPEGPIPE_MUXER=yes
+!CONFIG_LIBNUT_MUXER=yes
+CONFIG_ANULL_FILTER=yes
+CONFIG_ANULLSRC_FILTER=yes
+CONFIG_ANULLSINK_FILTER=yes
+!CONFIG_BLACKFRAME_FILTER=yes
+CONFIG_COPY_FILTER=yes
+CONFIG_CROP_FILTER=yes
+!CONFIG_CROPDETECT_FILTER=yes
+CONFIG_DRAWBOX_FILTER=yes
+!CONFIG_DRAWTEXT_FILTER=yes
+CONFIG_FADE_FILTER=yes
+CONFIG_FIELDORDER_FILTER=yes
+CONFIG_FIFO_FILTER=yes
+CONFIG_FORMAT_FILTER=yes
+!CONFIG_FREI0R_FILTER=yes
+CONFIG_GRADFUN_FILTER=yes
+CONFIG_HFLIP_FILTER=yes
+!CONFIG_HQDN3D_FILTER=yes
+CONFIG_LUT_FILTER=yes
+CONFIG_LUTRGB_FILTER=yes
+CONFIG_LUTYUV_FILTER=yes
+!CONFIG_MP_FILTER=yes
+CONFIG_NEGATE_FILTER=yes
+CONFIG_NOFORMAT_FILTER=yes
+CONFIG_NULL_FILTER=yes
+!CONFIG_OCV_FILTER=yes
+CONFIG_OVERLAY_FILTER=yes
+CONFIG_PAD_FILTER=yes
+CONFIG_PIXDESCTEST_FILTER=yes
+CONFIG_SCALE_FILTER=yes
+CONFIG_SELECT_FILTER=yes
+CONFIG_SETDAR_FILTER=yes
+CONFIG_SETPTS_FILTER=yes
+CONFIG_SETSAR_FILTER=yes
+CONFIG_SETTB_FILTER=yes
+CONFIG_SHOWINFO_FILTER=yes
+CONFIG_SLICIFY_FILTER=yes
+CONFIG_SPLIT_FILTER=yes
+CONFIG_TRANSPOSE_FILTER=yes
+CONFIG_UNSHARP_FILTER=yes
+CONFIG_VFLIP_FILTER=yes
+!CONFIG_YADIF_FILTER=yes
+CONFIG_BUFFER_FILTER=yes
+CONFIG_COLOR_FILTER=yes
+!CONFIG_FREI0R_SRC_FILTER=yes
+CONFIG_MOVIE_FILTER=yes
+CONFIG_NULLSRC_FILTER=yes
+CONFIG_BUFFERSINK_FILTER=yes
+CONFIG_NULLSINK_FILTER=yes
+CONFIG_APPLEHTTP_PROTOCOL=yes
+CONFIG_CONCAT_PROTOCOL=yes
+CONFIG_CRYPTO_PROTOCOL=yes
+CONFIG_FILE_PROTOCOL=yes
+CONFIG_GOPHER_PROTOCOL=yes
+CONFIG_HTTP_PROTOCOL=yes
+CONFIG_MMSH_PROTOCOL=yes
+CONFIG_MMST_PROTOCOL=yes
+CONFIG_MD5_PROTOCOL=yes
+CONFIG_PIPE_PROTOCOL=yes
+CONFIG_RTMP_PROTOCOL=yes
+CONFIG_RTMPT_PROTOCOL=yes
+CONFIG_RTMPE_PROTOCOL=yes
+CONFIG_RTMPTE_PROTOCOL=yes
+CONFIG_RTMPS_PROTOCOL=yes
+CONFIG_RTP_PROTOCOL=yes
+CONFIG_TCP_PROTOCOL=yes
+CONFIG_UDP_PROTOCOL=yes
+!CONFIG_ALSA_INDEV=yes
+!CONFIG_BKTR_INDEV=yes
+!CONFIG_DSHOW_INDEV=yes
+CONFIG_DV1394_INDEV=yes
+CONFIG_FBDEV_INDEV=yes
+!CONFIG_JACK_INDEV=yes
+CONFIG_OSS_INDEV=yes
+!CONFIG_SNDIO_INDEV=yes
+CONFIG_V4L2_INDEV=yes
+CONFIG_V4L_INDEV=yes
+!CONFIG_VFWCAP_INDEV=yes
+!CONFIG_X11_GRAB_DEVICE_INDEV=yes
+!CONFIG_LIBDC1394_INDEV=yes
+!CONFIG_ALSA_OUTDEV=yes
+CONFIG_OSS_OUTDEV=yes
+!CONFIG_SDL_OUTDEV=yes
+!CONFIG_SNDIO_OUTDEV=yes
+ACODEC_TESTS=ac3_fixed adpcm_ima_qt adpcm_ima_wav adpcm_ms adpcm_swf adpcm_yam alac aref flac g726 mp2 pcm wmav1 wmav2 
+VCODEC_TESTS=asv1 asv2 dnxhd_1080i dnxhd_720p dnxhd_720p_rd dv dv50 error ffv1 flashsv2 flv h261 h263 h263p huffyuv jpegls ljpeg mjpeg mpeg mpeg1b mpeg2 mpeg2thread mpeg4 mpeg4adv mpeg4nr mpeg4thread msmpeg4 msmpeg4v2 msvideo1 qtrle qtrlegray rc rgb roq rv10 rv20 snow snowll svq1 vref wmv1 wmv2 yuv 
+LAVF_TESTS=aiff alaw asf au avi bmp dv_fmt ffm flv_fmt gif gxf jpg mkv mmf mov mpg mulaw mxf nut ogg pbmpipe pcx pgm pgmpipe pixfmt ppm ppmpipe rm sgi swf tga tiff ts voc voc_s16 wav yuv4mpeg 
+LAVFI_TESTS=crop crop_scale crop_scale_vflip crop_vflip null pixdesc_le pixfmts_copy_le pixfmts_crop_le pixfmts_hflip_le pixfmts_null_le pixfmts_pad_le pixfmts_scale_le pixfmts_vflip_le scale200 scale500 vflip vflip_crop vflip_vflip 
+SEEK_TESTS=seek_ac3_rm seek_adpcm_ima_wav seek_adpcm_ms_wav seek_adpcm_qt_aiff seek_adpcm_swf_flv seek_adpcm_yam_wav seek_alac_m4a seek_asv1_avi seek_asv2_avi seek_dnxhd_1080i_mov seek_dnxhd_720p_dnxhd seek_dnxhd_720p_rd_dnxhd seek_dv411_dv seek_dv50_dv seek_dv_dv seek_error_mpeg4_adv_avi seek_ffv1_avi seek_flac_flac seek_flashsv_flv seek_flv_flv seek_g726_wav seek_h261_avi seek_h263_avi seek_h263p_avi seek_huffyuv_avi seek_image_bmp seek_image_jpg seek_image_pcx seek_image_pgm seek_image_ppm seek_image_sgi seek_image_tga seek_image_tiff seek_jpegls_avi seek_lavf_aif seek_lavf_al seek_lavf_asf seek_lavf_au seek_lavf_avi seek_lavf_dv seek_lavf_ffm seek_lavf_flv seek_lavf_gif seek_lavf_gxf seek_lavf_mkv seek_lavf_mmf seek_lavf_mov seek_lavf_mpg seek_lavf_mxf seek_lavf_mxf_d10 seek_lavf_nut seek_lavf_ogg seek_lavf_rm seek_lavf_swf seek_lavf_ts seek_lavf_ul seek_lavf_voc seek_lavf_wav seek_lavf_y4m seek_ljpeg_avi seek_mjpeg_avi seek_mp2_mp2 seek_mpeg1_mpg seek_mpeg1b_mpg seek_mpeg2_422_mpg seek_mpeg2_mpg seek_mpeg2i_mpg seek_mpeg2ivlc_qprd_mpg seek_mpeg2reuse_mpg seek_mpeg2thread_mpg seek_mpeg2threadivlc_mpg seek_mpeg4_adap_avi seek_mpeg4_adv_avi seek_mpeg4_nr_avi seek_mpeg4_qprd_avi seek_mpeg4_rc_avi seek_mpeg4_thread_avi seek_msmpeg4_avi seek_msmpeg4v2_avi seek_odivx_mp4 seek_pbmpipe_pbm seek_pcm_alaw_wav seek_pcm_f32be_au seek_pcm_f32le_wav seek_pcm_f64be_au seek_pcm_f64le_wav seek_pcm_mulaw_wav seek_pcm_s16be_mkv seek_pcm_s16be_mov seek_pcm_s16le_mkv seek_pcm_s16le_wav seek_pcm_s24be_mov seek_pcm_s24daud_302 seek_pcm_s24le_wav seek_pcm_s32be_mov seek_pcm_s32le_wav seek_pcm_s8_mov seek_pcm_u8_wav seek_pcm_zork_wav seek_pgmpipe_pgm seek_ppmpipe_ppm seek_rgb_avi seek_roqav_roq seek_rv10_rm seek_rv20_rm seek_snow53_avi seek_snow_avi seek_svq1_mov seek_wmav1_asf seek_wmav2_asf seek_wmv1_avi seek_wmv2_avi seek_yuv_avi 
+endif # FFMPEG_CONFIG_MAK
diff --git a/amffmpeg/libavcodec/Android.mk b/amffmpeg/libavcodec/Android.mk
new file mode 100755
index 0000000..858e2e8
--- /dev/null
+++ b/amffmpeg/libavcodec/Android.mk
@@ -0,0 +1,31 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+include $(LOCAL_PATH)/../common.mk
+LOCAL_SRC_FILES := $(FFFILES)
+LOCAL_C_INCLUDES :=		\
+	$(LOCAL_PATH)		\
+	$(LOCAL_PATH)/..	\
+	external/zlib
+LOCAL_CFLAGS += $(FFCFLAGS)
+LOCAL_LDLIBS := -lz
+LOCAL_STATIC_LIBRARIES := $(FFLIBS)
+LOCAL_MODULE := $(FFNAME)
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+
+include $(LOCAL_PATH)/../common.mk
+LOCAL_SRC_FILES := $(FFFILES)
+LOCAL_C_INCLUDES :=            \
+       $(LOCAL_PATH)           \
+       $(LOCAL_PATH)/..        \
+       external/zlib
+LOCAL_CFLAGS += $(FFCFLAGS)
+LOCAL_MODULE := $(FFNAME)
+LOCAL_SHARED_LIBRARIES += libutils libmedia libz libbinder libdl libcutils libc libavutil
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_TAGS := optional
+include $(BUILD_SHARED_LIBRARY)
+
+# Reset CC as it's overwritten by common.mk
+CC := $(HOST_CC)
diff --git a/amffmpeg/libavcodec/Makefile b/amffmpeg/libavcodec/Makefile
index b6103af..7f81e8d 100644
--- a/amffmpeg/libavcodec/Makefile
+++ b/amffmpeg/libavcodec/Makefile
@@ -1,4 +1,4 @@
-include $(SUBDIR)../config.mak
+####include $(SUBDIR)../config.mak
 
 NAME = avcodec
 FFLIBS = avutil
@@ -691,9 +691,11 @@ HOSTPROGS = aac_tablegen aacps_tablegen cbrt_tablegen cos_tablegen      \
 
 DIRS = alpha arm bfin mlib ppc ps2 sh4 sparc x86
 
+include $(LOCAL_PATH)/$(ARCH)/Makefile
+
 CLEANFILES = *_tables.c *_tables.h *_tablegen$(HOSTEXESUF)
 
-include $(SUBDIR)../subdir.mak
+###include $(SUBDIR)../subdir.mak
 
 $(SUBDIR)dct-test$(EXESUF): $(SUBDIR)dctref.o
 
diff --git a/amffmpeg/libavcodec/aacps.c b/amffmpeg/libavcodec/aacps.c
index fc124d1..df30994 100644
--- a/amffmpeg/libavcodec/aacps.c
+++ b/amffmpeg/libavcodec/aacps.c
@@ -28,6 +28,7 @@
 #include "aacps_tablegen.h"
 #include "aacpsdata.c"
 
+
 #define PS_BASELINE 0  //< Operate in Baseline PS mode
                        //< Baseline implies 10 or 20 stereo bands,
                        //< mixing mode A, and no ipd/opd
diff --git a/amffmpeg/libavcodec/aacsbr.c b/amffmpeg/libavcodec/aacsbr.c
old mode 100644
new mode 100755
index 82092b3..e0ecf70
--- a/amffmpeg/libavcodec/aacsbr.c
+++ b/amffmpeg/libavcodec/aacsbr.c
@@ -37,7 +37,7 @@
 #include <stdint.h>
 #include <float.h>
 #include <math.h>
-
+#define log2f(x) (x)
 #define ENVELOPE_ADJUSTMENT_OFFSET 2
 #define NOISE_FLOOR_OFFSET 6.0f
 
@@ -1058,10 +1058,14 @@ int ff_decode_sbr_extension(AACContext *ac, SpectralBandReplication *sbr,
 
     sbr->reset = 0;
 
+
+/*	CHANGED by zz ,ignore changed sample_rate for SBR;
+	
+*/
     if (!sbr->sample_rate)
-        sbr->sample_rate = 2 * ac->m4ac.sample_rate; //TODO use the nominal sample rate for arbitrary sample rate support
+        sbr->sample_rate = ac->m4ac.sample_rate; // 2 * ac->m4ac.sample_rate; //TODO use the nominal sample rate for arbitrary sample rate support
     if (!ac->m4ac.ext_sample_rate)
-        ac->m4ac.ext_sample_rate = 2 * ac->m4ac.sample_rate;
+        ac->m4ac.ext_sample_rate =ac->m4ac.sample_rate;// 2 * ac->m4ac.sample_rate;
 
     if (crc) {
         skip_bits(gb, 10); // bs_sbr_crc_bits; TODO - implement CRC check
diff --git a/amffmpeg/libavcodec/avcodec.h b/amffmpeg/libavcodec/avcodec.h
index 90c389b..963fae0 100644
--- a/amffmpeg/libavcodec/avcodec.h
+++ b/amffmpeg/libavcodec/avcodec.h
@@ -111,6 +111,7 @@ enum CodecID {
     CODEC_ID_QDRAW,
     CODEC_ID_VIXL,
     CODEC_ID_QPEG,
+    CODEC_ID_XVID,
     CODEC_ID_PNG,
     CODEC_ID_PPM,
     CODEC_ID_PBM,
@@ -206,6 +207,9 @@ enum CodecID {
     CODEC_ID_DFA,
     CODEC_ID_8SVX_RAW,
 
+    /* H264 MVC type */
+    CODEC_ID_H264MVC,
+
     /* various PCM "codecs" */
     CODEC_ID_PCM_S16LE= 0x10000,
     CODEC_ID_PCM_S16BE,
diff --git a/amffmpeg/libavcodec/ffv1.c b/amffmpeg/libavcodec/ffv1.c
index a0a4a1d..afebd88 100644
--- a/amffmpeg/libavcodec/ffv1.c
+++ b/amffmpeg/libavcodec/ffv1.c
@@ -31,8 +31,8 @@
 #include "dsputil.h"
 #include "rangecoder.h"
 #include "golomb.h"
-#include "mathops.h"
 #include "libavutil/avassert.h"
+#define log2(x) (x)
 
 #define MAX_PLANES 4
 #define CONTEXT_SIZE 32
diff --git a/amffmpeg/libavcodec/h264.c b/amffmpeg/libavcodec/h264.c
old mode 100644
new mode 100755
index 5170a55..49ea349
--- a/amffmpeg/libavcodec/h264.c
+++ b/amffmpeg/libavcodec/h264.c
@@ -1791,7 +1791,7 @@ static av_always_inline void hl_decode_mb_internal(H264Context *h, int simple, i
     int *block_offset = &h->block_offset[0];
     const int transform_bypass = !simple && (s->qscale == 0 && h->sps.transform_bypass);
     /* is_h264 should always be true if SVQ3 is disabled. */
-    const int is_h264 = !CONFIG_SVQ3_DECODER || simple || s->codec_id == CODEC_ID_H264;
+    const int is_h264 = !CONFIG_SVQ3_DECODER || simple || s->codec_id == CODEC_ID_H264  || s->codec_id == CODEC_ID_H264MVC;
     void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride);
 
     dest_y  = s->current_picture.data[0] + ((mb_x << pixel_shift) + mb_y * s->linesize  ) * 16;
@@ -3384,7 +3384,7 @@ static int decode_slice(struct AVCodecContext *avctx, void *arg){
 
     s->mb_skip_run= -1;
 
-    h->is_complex = FRAME_MBAFF || s->picture_structure != PICT_FRAME || s->codec_id != CODEC_ID_H264 ||
+    h->is_complex = FRAME_MBAFF || s->picture_structure != PICT_FRAME || s->codec_id != CODEC_ID_H264 || s->codec_id != CODEC_ID_H264MVC ||
                     (CONFIG_GRAY && (s->flags&CODEC_FLAG_GRAY));
 
     if( h->pps.cabac ) {
@@ -3820,6 +3820,12 @@ static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){
         case NAL_SPS_EXT:
         case NAL_AUXILIARY_SLICE:
             break;
+		case NAL_14:
+		case NAL_15:
+		case NAL_20:
+			av_log(avctx, AV_LOG_ERROR, "NAL type: %d for MVC\n", h->nal_unit_type);
+			avctx->codec_id == CODEC_ID_H264MVC;
+			break;			
         default:
             av_log(avctx, AV_LOG_DEBUG, "Unknown NAL code: %d (%d bits)\n", hx->nal_unit_type, bit_length);
         }
diff --git a/amffmpeg/libavcodec/h264.h b/amffmpeg/libavcodec/h264.h
index 7bad91b..d07f0ee 100644
--- a/amffmpeg/libavcodec/h264.h
+++ b/amffmpeg/libavcodec/h264.h
@@ -116,7 +116,10 @@ enum {
     NAL_END_STREAM,
     NAL_FILLER_DATA,
     NAL_SPS_EXT,
-    NAL_AUXILIARY_SLICE=19
+    NAL_14,
+    NAL_15,
+    NAL_AUXILIARY_SLICE=19,
+    NAL_20=20
 };
 
 /**
diff --git a/amffmpeg/libavcodec/libavcodec-uninstalled.pc b/amffmpeg/libavcodec/libavcodec-uninstalled.pc
new file mode 100644
index 0000000..c32d772
--- /dev/null
+++ b/amffmpeg/libavcodec/libavcodec-uninstalled.pc
@@ -0,0 +1,12 @@
+prefix=
+exec_prefix=
+libdir=${pcfiledir}
+includedir=/nishome/zhouzhi/android/android_rootfs_ref/packages/amlogic/LibPlayer/amffmpeg-0.8
+
+Name: libavcodec
+Description: FFmpeg codec library
+Version: 53.7.0
+Requires: libavutil = 51.9.1
+Conflicts:
+Libs: ${libdir}/libavcodec.a -ldl -lm -pthread 
+Cflags: -I${includedir}
diff --git a/amffmpeg/libavcodec/libavcodec.pc b/amffmpeg/libavcodec/libavcodec.pc
new file mode 100644
index 0000000..fdca3ab
--- /dev/null
+++ b/amffmpeg/libavcodec/libavcodec.pc
@@ -0,0 +1,14 @@
+prefix=/usr/local
+exec_prefix=${prefix}
+libdir=${prefix}/lib
+includedir=${prefix}/include
+
+Name: libavcodec
+Description: FFmpeg codec library
+Version: 53.7.0
+Requires: libavutil = 51.9.1
+Requires.private: 
+Conflicts:
+Libs: -L${libdir} -lavcodec -ldl -lm -pthread
+Libs.private: 
+Cflags: -I${includedir}
diff --git a/amffmpeg/libavcodec/srtdec.c b/amffmpeg/libavcodec/srtdec.c
index aa73f4c..c4ed545 100644
--- a/amffmpeg/libavcodec/srtdec.c
+++ b/amffmpeg/libavcodec/srtdec.c
@@ -109,7 +109,7 @@ static const char *srt_to_ass(AVCodecContext *avctx, char *out, char *out_end,
                                 if (stack[sptr-1].param[i][0])
                                     for (j=sptr-2; j>=0; j--)
                                         if (stack[j].param[i][0]) {
-                                            out += snprintf(out, out_end-out,
+                                            out += snprintf(out, out_end-out,"%s",
                                                             stack[j].param[i]);
                                             break;
                                         }
@@ -145,7 +145,7 @@ static const char *srt_to_ass(AVCodecContext *avctx, char *out, char *out_end,
                             }
                             for (i=0; i<PARAM_NUMBER; i++)
                                 if (stack[sptr].param[i][0])
-                                    out += snprintf(out, out_end-out,
+                                    out += snprintf(out, out_end-out,"%s",
                                                     stack[sptr].param[i]);
                         }
                     } else if (!buffer[1] && strspn(buffer, "bisu") == 1) {
diff --git a/amffmpeg/libavdevice/libavdevice-uninstalled.pc b/amffmpeg/libavdevice/libavdevice-uninstalled.pc
new file mode 100644
index 0000000..1895f67
--- /dev/null
+++ b/amffmpeg/libavdevice/libavdevice-uninstalled.pc
@@ -0,0 +1,12 @@
+prefix=
+exec_prefix=
+libdir=${pcfiledir}
+includedir=/nishome/zhouzhi/android/android_rootfs_ref/packages/amlogic/LibPlayer/amffmpeg-0.8
+
+Name: libavdevice
+Description: FFmpeg device handling library
+Version: 53.1.1
+Requires: libavformat = 53.4.0
+Conflicts:
+Libs: ${libdir}/libavdevice.a -ldl -lm -pthread 
+Cflags: -I${includedir}
diff --git a/amffmpeg/libavdevice/libavdevice.pc b/amffmpeg/libavdevice/libavdevice.pc
new file mode 100644
index 0000000..2925054
--- /dev/null
+++ b/amffmpeg/libavdevice/libavdevice.pc
@@ -0,0 +1,14 @@
+prefix=/usr/local
+exec_prefix=${prefix}
+libdir=${prefix}/lib
+includedir=${prefix}/include
+
+Name: libavdevice
+Description: FFmpeg device handling library
+Version: 53.1.1
+Requires: libavformat = 53.4.0
+Requires.private: 
+Conflicts:
+Libs: -L${libdir} -lavdevice -ldl -lm -pthread
+Libs.private: 
+Cflags: -I${includedir}
diff --git a/amffmpeg/libavfilter/libavfilter-uninstalled.pc b/amffmpeg/libavfilter/libavfilter-uninstalled.pc
new file mode 100644
index 0000000..44e4993
--- /dev/null
+++ b/amffmpeg/libavfilter/libavfilter-uninstalled.pc
@@ -0,0 +1,12 @@
+prefix=
+exec_prefix=
+libdir=${pcfiledir}
+includedir=/nishome/zhouzhi/android/android_rootfs_ref/packages/amlogic/LibPlayer/amffmpeg-0.8
+
+Name: libavfilter
+Description: FFmpeg video filtering library
+Version: 2.23.0
+Requires: 
+Conflicts:
+Libs: ${libdir}/libavfilter.a -ldl -lm -pthread 
+Cflags: -I${includedir}
diff --git a/amffmpeg/libavfilter/libavfilter.pc b/amffmpeg/libavfilter/libavfilter.pc
new file mode 100644
index 0000000..7092c5a
--- /dev/null
+++ b/amffmpeg/libavfilter/libavfilter.pc
@@ -0,0 +1,14 @@
+prefix=/usr/local
+exec_prefix=${prefix}
+libdir=${prefix}/lib
+includedir=${prefix}/include
+
+Name: libavfilter
+Description: FFmpeg video filtering library
+Version: 2.23.0
+Requires: 
+Requires.private: 
+Conflicts:
+Libs: -L${libdir} -lavfilter -ldl -lm -pthread
+Libs.private: 
+Cflags: -I${includedir}
diff --git a/amffmpeg/libavformat/Android.mk b/amffmpeg/libavformat/Android.mk
new file mode 100755
index 0000000..ca11ad6
--- /dev/null
+++ b/amffmpeg/libavformat/Android.mk
@@ -0,0 +1,28 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+include $(LOCAL_PATH)/../common.mk
+LOCAL_SRC_FILES := $(FFFILES)
+LOCAL_C_INCLUDES :=		\
+	$(LOCAL_PATH)		\
+	$(LOCAL_PATH)/..	\
+	external/zlib
+LOCAL_CFLAGS += $(FFCFLAGS)
+LOCAL_MODULE := $(FFNAME)
+include $(BUILD_STATIC_LIBRARY)
+
+include $(CLEAR_VARS)
+include $(LOCAL_PATH)/../common.mk
+LOCAL_SRC_FILES := $(FFFILES)
+LOCAL_C_INCLUDES :=		\
+	$(LOCAL_PATH)		\
+	$(LOCAL_PATH)/..	\
+	external/zlib
+LOCAL_CFLAGS += $(FFCFLAGS)
+LOCAL_MODULE := $(FFNAME)
+LOCAL_SHARED_LIBRARIES +=   libutils libmedia libz libbinder libdl libcutils libc libavutil libavcodec
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_TAGS := optional
+include $(BUILD_SHARED_LIBRARY)
+
+# Reset CC as it's overwritten by common.mk
+CC := $(HOST_CC)
diff --git a/amffmpeg/libavformat/Makefile b/amffmpeg/libavformat/Makefile
old mode 100644
new mode 100755
index e5ec44b..377fbe8
--- a/amffmpeg/libavformat/Makefile
+++ b/amffmpeg/libavformat/Makefile
@@ -1,4 +1,4 @@
-include $(SUBDIR)../config.mak
+###include $(SUBDIR)../config.mak
 
 NAME = avformat
 FFLIBS = avcodec avutil
@@ -18,7 +18,7 @@ OBJS = allformats.o         \
 
 # muxers/demuxers
 OBJS-$(CONFIG_A64_MUXER)                 += a64.o
-OBJS-$(CONFIG_AAC_DEMUXER)               += aacdec.o rawdec.o
+OBJS-$(CONFIG_AAC_DEMUXER)               += aacdec.o rawdec.o adif.o
 OBJS-$(CONFIG_AC3_DEMUXER)               += ac3dec.o rawdec.o
 OBJS-$(CONFIG_AC3_MUXER)                 += rawenc.o
 OBJS-$(CONFIG_ADTS_MUXER)                += adtsenc.o
@@ -339,7 +339,10 @@ OBJS-$(CONFIG_UDP_PROTOCOL)              += udp.o
 
 # libavdevice dependencies
 OBJS-$(CONFIG_JACK_INDEV)                += timefilter.o
-
 TESTPROGS = timefilter
 
-include $(SUBDIR)../subdir.mak
+OBJS                += file_list.o m3u.o
+
+OBJS                += aviolpbuf.o aviolpcache.o
+
+###include $(SUBDIR)../subdir.mak
diff --git a/amffmpeg/libavformat/aacdec.c b/amffmpeg/libavformat/aacdec.c
old mode 100644
new mode 100755
index 4ac2cad..4d021cf
--- a/amffmpeg/libavformat/aacdec.c
+++ b/amffmpeg/libavformat/aacdec.c
@@ -24,6 +24,8 @@
 #include "avformat.h"
 #include "rawdec.h"
 #include "id3v1.h"
+#include "id3v2.h"
+#include "adif.h"
 
 
 static int adts_aac_probe(AVProbeData *p)
@@ -35,6 +37,7 @@ static int adts_aac_probe(AVProbeData *p)
     uint8_t *buf;
     uint8_t *end = buf0 + p->buf_size - 7;
 
+
     buf = buf0;
 
     for(; buf < end; buf= buf2+1) {
@@ -64,7 +67,8 @@ static int adts_aac_read_header(AVFormatContext *s,
                                 AVFormatParameters *ap)
 {
     AVStream *st;
-
+	int err;
+    uint8_t *buf=s->pb->buffer;
     st = av_new_stream(s, 0);
     if (!st)
         return AVERROR(ENOMEM);
@@ -74,10 +78,24 @@ static int adts_aac_read_header(AVFormatContext *s,
     st->need_parsing = AVSTREAM_PARSE_FULL;
 
     ff_id3v1_read(s);
-
-    //LCM of all possible ADTS sample rates
-    av_set_pts_info(st, 64, 1, 28224000);
-
+	//LCM of all possible ADTS sample rates
+	av_set_pts_info(st, 64, 1, 28224000);
+    ff_id3v2_read(s,"ID3");
+    //add by xh,2010-08-24
+    if (buf[0]=='A' && buf[1]=='D' && buf[2]=='I' && buf[3]=='F')
+    {
+		err = adif_header_parse(st,s->pb);
+		if(err){
+			av_log(NULL, AV_LOG_INFO," adif parser header  failed\n");
+			return err;
+		}
+		else{
+			st->need_parsing = AVSTREAM_PARSE_NONE;
+			st->codec->codec_id = CODEC_ID_AAC;
+		}
+    }  
+    //end of add
+    
     return 0;
 }
 
diff --git a/amffmpeg/libavformat/adif.c b/amffmpeg/libavformat/adif.c
new file mode 100755
index 0000000..f332780
--- /dev/null
+++ b/amffmpeg/libavformat/adif.c
@@ -0,0 +1,220 @@
+
+#include "adif.h"
+
+
+/**************************************************************************************
+ * Function:    DecodeProgramConfigElement
+ *
+ * Description: decode one PCE
+ *
+ * Inputs:      BitStreamInfo struct pointing to start of PCE (14496-3, table 4.4.2) 
+ *
+ * Outputs:     filled-in ProgConfigElement struct
+ *              updated BitStreamInfo struct
+ *
+ * Return:      0 if successful, error code (< 0) if error
+ *
+ * Notes:       #define KEEP_PCE_COMMENTS to save the comment field of the PCE
+ *                (otherwise we just skip it in the bitstream, to save memory)
+ **************************************************************************************/
+static int DecodeProgramConfigElement(ProgConfigElement *pce, GetBitContext *bsi)
+{
+	int i;
+
+	pce->elemInstTag =   get_bits(bsi, 4);
+	pce->profile =       get_bits(bsi, 2);
+	pce->sampRateIdx =   get_bits(bsi, 4);
+	pce->numFCE =        get_bits(bsi, 4);
+	pce->numSCE =        get_bits(bsi, 4);
+	pce->numBCE =        get_bits(bsi, 4);
+	pce->numLCE =        get_bits(bsi, 2);
+	pce->numADE =        get_bits(bsi, 3);
+	pce->numCCE =        get_bits(bsi, 4);
+
+	pce->monoMixdown = get_bits(bsi, 1) << 4;	/* present flag */
+	if (pce->monoMixdown)
+		pce->monoMixdown |= get_bits(bsi, 4);	/* element number */
+
+	pce->stereoMixdown = get_bits(bsi, 1) << 4;	/* present flag */
+	if (pce->stereoMixdown)
+		pce->stereoMixdown  |= get_bits(bsi, 4);	/* element number */
+
+	pce->matrixMixdown = get_bits(bsi, 1) << 4;	/* present flag */
+	if (pce->matrixMixdown) {
+		pce->matrixMixdown  |= get_bits(bsi, 2) << 1;	/* index */
+		pce->matrixMixdown  |= get_bits(bsi, 1);			/* pseudo-surround enable */
+	}
+
+	for (i = 0; i < pce->numFCE; i++) {
+		pce->fce[i]  = get_bits(bsi, 1) << 4;	/* is_cpe flag */
+		pce->fce[i] |= get_bits(bsi, 4);			/* tag select */
+	}
+
+	for (i = 0; i < pce->numSCE; i++) {
+		pce->sce[i]  = get_bits(bsi, 1) << 4;	/* is_cpe flag */
+		pce->sce[i] |= get_bits(bsi, 4);			/* tag select */
+	}
+
+	for (i = 0; i < pce->numBCE; i++) {
+		pce->bce[i]  = get_bits(bsi, 1) << 4;	/* is_cpe flag */
+		pce->bce[i] |= get_bits(bsi, 4);			/* tag select */
+	}
+
+	for (i = 0; i < pce->numLCE; i++)
+		pce->lce[i] = get_bits(bsi, 4);			/* tag select */
+
+	for (i = 0; i < pce->numADE; i++)
+		pce->ade[i] = get_bits(bsi, 4);			/* tag select */
+
+	for (i = 0; i < pce->numCCE; i++) {
+		pce->cce[i]  = get_bits(bsi, 1) << 4;	/* independent/dependent flag */
+		pce->cce[i] |= get_bits(bsi, 4);			/* tag select */
+	}
+
+
+	align_get_bits(bsi);
+
+#if 0//def KEEP_PCE_COMMENTS
+	pce->commentBytes = get_bits(bsi, 8);
+	for (i = 0; i < pce->commentBytes; i++)
+		pce->commentField[i] = get_bits(bsi, 8);
+#else
+	/* eat comment bytes and throw away */
+	i = get_bits(bsi, 8);
+	while (i--)
+		get_bits(bsi, 8);
+#endif
+
+	return 0;
+}
+/**************************************************************************************
+ * Function:    GetNumChannelsADIF
+ *
+ * Description: get number of channels from program config elements in an ADIF file
+ *
+ * Inputs:      array of filled-in program config element structures
+ *              number of PCE's
+ *
+ * Outputs:     none
+ *
+ * Return:      total number of channels in file
+ *              -1 if error (invalid number of PCE's or unsupported mode)
+ **************************************************************************************/
+static int GetNumChannelsADIF(ProgConfigElement *fhPCE, int nPCE)
+{
+	int i, j, nChans;
+
+	if (nPCE < 1 || nPCE > MAX_NUM_PCE_ADIF)
+		return -1;
+
+	nChans = 0;
+	for (i = 0; i < nPCE; i++) {
+		/* for now: only support LC, no channel coupling */
+		if (fhPCE[i].profile != 1/*LC*/ || fhPCE[i].numCCE > 0)
+			return -1;
+
+		/* add up number of channels in all channel elements (assume all single-channel) */
+        nChans += fhPCE[i].numFCE;
+        nChans += fhPCE[i].numSCE;
+        nChans += fhPCE[i].numBCE;
+        nChans += fhPCE[i].numLCE;
+
+		/* add one more for every element which is a channel pair */
+        for (j = 0; j < fhPCE[i].numFCE; j++) {
+            if (CHAN_ELEM_IS_CPE(fhPCE[i].fce[j]))
+                nChans++;
+        }
+        for (j = 0; j < fhPCE[i].numSCE; j++) {
+            if (CHAN_ELEM_IS_CPE(fhPCE[i].sce[j]))
+                nChans++;
+        }
+        for (j = 0; j < fhPCE[i].numBCE; j++) {
+            if (CHAN_ELEM_IS_CPE(fhPCE[i].bce[j]))
+                nChans++;
+        }
+
+	}
+
+	return nChans;
+}
+/**************************************************************************************
+ * Function:    GetSampleRateIdxADIF
+ *
+ * Description: get sampling rate index from program config elements in an ADIF file
+ *
+ * Inputs:      array of filled-in program config element structures
+ *              number of PCE's
+ *
+ * Outputs:     none
+ *
+ * Return:      sample rate of file
+ *              -1 if error (invalid number of PCE's or sample rate mismatch)
+ **************************************************************************************/
+ static int GetSampleRateIdxADIF(ProgConfigElement *fhPCE, int nPCE)
+{
+	int i, idx;
+
+	if (nPCE < 1 || nPCE > MAX_NUM_PCE_ADIF)
+		return -1;
+
+	/* make sure all PCE's have the same sample rate */
+	idx = fhPCE[0].sampRateIdx;
+	for (i = 1; i < nPCE; i++) {
+		if (fhPCE[i].sampRateIdx != idx)
+			return -1;
+	}
+
+	return idx;
+}
+
+int adif_header_parse(AVStream *st,ByteIOContext *pb)
+{ 
+	GetBitContext gbc;
+	ADIFHeader hADIF;	
+	ADIFHeader *fhADIF = &hADIF;	
+	int ch,sr_index,i;
+	ProgConfigElement pce[MAX_NUM_PCE_ADIF];
+	const int aac_sample_rates[16] = {
+    	96000, 88200, 64000, 48000, 44100, 32000,
+    	24000, 22050, 16000, 12000, 11025, 8000, 7350
+	};
+	init_get_bits(&gbc, pb->buffer+4, pb->buffer_size-4);//skip adif tag
+	/* read ADIF header fields */
+	fhADIF->copyBit = get_bits(&gbc, 1);
+	if (fhADIF->copyBit) {
+	for (i = 0; i < ADIF_COPYID_SIZE; i++)
+		fhADIF->copyID[i] = get_bits(&gbc,8);
+	}
+	fhADIF->origCopy = get_bits(&gbc, 1);
+	fhADIF->home =     get_bits(&gbc, 1);
+	fhADIF->bsType =   get_bits(&gbc,1);
+	fhADIF->bitRate =  get_bits(&gbc,23);
+	fhADIF->numPCE =   get_bits(&gbc, 4) + 1;	/* add 1 (so range = [1, 16]) */
+	if (fhADIF->bsType == 0)
+		fhADIF->bufferFull = get_bits(&gbc, 20);
+
+	/* parse all program config elements */
+	for (i = 0; i < fhADIF->numPCE; i++)
+		DecodeProgramConfigElement(pce + i, &gbc);
+
+	/* byte align */
+	align_get_bits(&gbc);
+
+	/* update codec info */
+	ch = GetNumChannelsADIF(pce, fhADIF->numPCE);
+	sr_index = GetSampleRateIdxADIF(pce, fhADIF->numPCE);
+
+	//	/* check validity of header */
+	if (ch < 0 || sr_index < 0 || sr_index >= NUM_SAMPLE_RATES){
+		
+		return -1;
+	}	
+	st->codec->bit_rate = 	fhADIF->bitRate;
+	st->codec->channels = ch;
+	st->codec->sample_rate = aac_sample_rates[sr_index];
+	st->codec->profile = pce[0].profile;
+	av_log(st, AV_LOG_INFO," sr %d,ch %d,bitraete %d,profile %d",st->codec->sample_rate ,st->codec->channels,\
+		st->codec->bit_rate,st->codec->profile);
+	return 0;
+}
+
diff --git a/amffmpeg/libavformat/adif.h b/amffmpeg/libavformat/adif.h
new file mode 100755
index 0000000..f7e95fc
--- /dev/null
+++ b/amffmpeg/libavformat/adif.h
@@ -0,0 +1,59 @@
+#ifndef _ADIF_H_
+#define _ADIF_H_
+#include "libavcodec/get_bits.h"
+#include "libavcodec/bytestream.h"
+#include "avformat.h"
+
+
+/* sizeof(ProgConfigElement) = 82 bytes (if KEEP_PCE_COMMENTS not defined) */
+#define MAX_NUM_FCE                     15
+#define MAX_NUM_SCE                     15
+#define MAX_NUM_BCE                     15
+#define MAX_NUM_LCE                      3
+#define MAX_NUM_ADE                      7
+#define MAX_NUM_CCE                     15
+#define MAX_NUM_PCE_ADIF	16
+
+#define CHAN_ELEM_IS_CPE(x)             (((x) & 0x10) >> 4)  /* bit 4 = SCE/CPE flag */
+#define NUM_SAMPLE_RATES	12
+
+#define ADIF_COPYID_SIZE        9
+
+typedef struct _ADIFHeader {
+    unsigned char copyBit;                        /* 0 = no copyright ID, 1 = 72-bit copyright ID follows immediately */
+    unsigned char origCopy;                       /* 0 = copy, 1 = original */
+    unsigned char home;                           /* ignore */
+    unsigned char bsType;                         /* bitstream type: 0 = CBR, 1 = VBR */
+    int           bitRate;                        /* bitRate: CBR = bits/sec, VBR = peak bits/frame, 0 = unknown */
+    unsigned char numPCE;                         /* number of program config elements (max = 16) */
+    int           bufferFull;                     /* bits left in bit reservoir */
+    unsigned char copyID[ADIF_COPYID_SIZE];       /* optional 72-bit copyright ID */
+} ADIFHeader;
+
+
+
+typedef struct _ProgConfigElement {
+    unsigned char elemInstTag;                    /* element instance tag */
+    unsigned char profile;                        /* 0 = main, 1 = LC, 2 = SSR, 3 = reserved */
+    unsigned char sampRateIdx;                    /* sample rate index range = [0, 11] */
+    unsigned char numFCE;                         /* number of front channel elements (max = 15) */
+    unsigned char numSCE;                         /* number of side channel elements (max = 15) */
+    unsigned char numBCE;                         /* number of back channel elements (max = 15) */
+    unsigned char numLCE;                         /* number of LFE channel elements (max = 3) */
+    unsigned char numADE;                         /* number of associated data elements (max = 7) */
+    unsigned char numCCE;                         /* number of valid channel coupling elements (max = 15) */
+    unsigned char monoMixdown;                    /* mono mixdown: bit 4 = present flag, bits 3-0 = element number */
+    unsigned char stereoMixdown;                  /* stereo mixdown: bit 4 = present flag, bits 3-0 = element number */
+    unsigned char matrixMixdown;                  /* matrix mixdown: bit 4 = present flag, bit 3 = unused, bits 2-1 = index, bit 0 = pseudo-surround enable */
+    unsigned char fce[MAX_NUM_FCE];               /* front element channel pair: bit 4 = SCE/CPE flag, bits 3-0 = inst tag */
+    unsigned char sce[MAX_NUM_SCE];               /* side element channel pair: bit 4 = SCE/CPE flag, bits 3-0 = inst tag */
+    unsigned char bce[MAX_NUM_BCE];               /* back element channel pair: bit 4 = SCE/CPE flag, bits 3-0 = inst tag */
+    unsigned char lce[MAX_NUM_LCE];               /* instance tag for LFE elements */
+    unsigned char ade[MAX_NUM_ADE];               /* instance tag for ADE elements */
+    unsigned char cce[MAX_NUM_BCE];               /* channel coupling elements: bit 4 = switching flag, bits 3-0 = inst tag */
+} ProgConfigElement;
+
+extern  int adif_header_parse(AVStream *st,ByteIOContext *pb);
+
+
+#endif
diff --git a/amffmpeg/libavformat/allformats.c b/amffmpeg/libavformat/allformats.c
old mode 100644
new mode 100755
index a9fa117..54c3a62
--- a/amffmpeg/libavformat/allformats.c
+++ b/amffmpeg/libavformat/allformats.c
@@ -241,6 +241,7 @@ void av_register_all(void)
     REGISTER_PROTOCOL (FILE, file);
     REGISTER_PROTOCOL (GOPHER, gopher);
     REGISTER_PROTOCOL (HTTP, http);
+	REGISTER_PROTOCOL (HTTP, shttp);
     REGISTER_PROTOCOL (MMSH, mmsh);
     REGISTER_PROTOCOL (MMST, mmst);
     REGISTER_PROTOCOL (MD5,  md5);
@@ -255,4 +256,8 @@ void av_register_all(void)
     REGISTER_PROTOCOL (RTP, rtp);
     REGISTER_PROTOCOL (TCP, tcp);
     REGISTER_PROTOCOL (UDP, udp);
+
+
+extern int register_list_demux_all(void);
+	register_list_demux_all();
 }
diff --git a/amffmpeg/libavformat/asfdec.c b/amffmpeg/libavformat/asfdec.c
old mode 100644
new mode 100755
index db00964..23fa82e
--- a/amffmpeg/libavformat/asfdec.c
+++ b/amffmpeg/libavformat/asfdec.c
@@ -87,6 +87,10 @@ static const ff_asf_guid index_guid = {
 static const ff_asf_guid stream_bitrate_guid = { /* (http://get.to/sdp) */
     0xce, 0x75, 0xf8, 0x7b, 0x8d, 0x46, 0xd1, 0x11, 0x8d, 0x82, 0x00, 0x60, 0x97, 0xc9, 0xa2, 0xb2
 };
+
+static int video_stream_num = 0, audio_stream_num = 0;
+static uint64_t avg_frame_time[128];
+
 /**********************************/
 /* decoding */
 
@@ -296,6 +300,7 @@ static int asf_read_stream_properties(AVFormatContext *s, int64_t size)
         } else {
             st->need_parsing = AVSTREAM_PARSE_FULL;
         }
+        audio_stream_num = st->id;
         /* We have to init the frame size at some point .... */
         pos2 = avio_tell(pb);
         if (size >= (pos2 + 8 - pos1 + 24)) {
@@ -335,6 +340,7 @@ static int asf_read_stream_properties(AVFormatContext *s, int64_t size)
         }
     } else if (type == AVMEDIA_TYPE_VIDEO &&
             size - (avio_tell(pb) - pos1 + 24) >= 51) {
+        video_stream_num = st->id;
         avio_rl32(pb);
         avio_rl32(pb);
         avio_r8(pb);
@@ -413,7 +419,7 @@ static int asf_read_ext_stream_properties(AVFormatContext *s, int64_t size)
     if (stream_num < 128)
         asf->streams[stream_num].stream_language_index = stream_languageid_index;
 
-    avio_rl64(pb); // avg frametime in 100ns units
+    avg_frame_time[stream_num] = avio_rl64(pb); // avg frametime in 100ns units
     stream_ct = avio_rl16(pb); //stream-name-count
     payload_ext_ct = avio_rl16(pb); //payload-extension-system-count
 
@@ -658,6 +664,8 @@ static int asf_read_header(AVFormatContext *s, AVFormatParameters *ap)
     asf->data_offset = avio_tell(pb);
     asf->packet_size_left = 0;
 
+	s->video_avg_frame_time = avg_frame_time[video_stream_num];
+	s->audio_avg_frame_time = avg_frame_time[audio_stream_num];
 
     for(i=0; i<128; i++){
         int stream_num= asf->asfid2avid[i];
@@ -727,6 +735,8 @@ static int ff_asf_get_packet(AVFormatContext *s, AVIOContext *pb)
         e= avio_r8(pb);
         if(c == 0x82 && !d && !e)
             break;
+		if(url_interrupt_cb())
+			break;
     }
 
     if (c != 0x82) {
@@ -738,6 +748,8 @@ static int ff_asf_get_packet(AVFormatContext *s, AVIOContext *pb)
          */
         if (pb->error == AVERROR(EAGAIN))
             return AVERROR(EAGAIN);
+		if(url_interrupt_cb())
+			return AVERROR_EXIT;
         if (!url_feof(pb))
             av_log(s, AV_LOG_ERROR, "ff asf bad header %x  at:%"PRId64"\n", c, avio_tell(pb));
     }
@@ -894,6 +906,8 @@ static int ff_asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pk
         int ret;
         if(url_feof(pb))
             return AVERROR_EOF;
+		if(url_interrupt_cb())
+            return AVERROR_EXIT;
         if (asf->packet_size_left < FRAME_HEADER_SIZE
             || asf->packet_segments < 1) {
             //asf->packet_size_left <= asf->packet_padsize) {
diff --git a/amffmpeg/libavformat/avformat.h b/amffmpeg/libavformat/avformat.h
old mode 100644
new mode 100755
index 1734649..ff09cb6
--- a/amffmpeg/libavformat/avformat.h
+++ b/amffmpeg/libavformat/avformat.h
@@ -42,6 +42,8 @@ const char *avformat_license(void);
 #include "libavcodec/avcodec.h"
 #include "libavutil/dict.h"
 
+#include "divxdrm.h"
+
 #include "avio.h"
 #include "libavformat/version.h"
 
@@ -634,6 +636,13 @@ typedef struct AVStream {
      * NOT PART OF PUBLIC API
      */
     int request_probe;
+    /**
+     * added by Chen.Zhang
+     * Add this member to mark the offset of the stream in the file
+     */
+     unsigned int stream_offset;
+     int no_extra_offset;
+     float special_fps;  // for some special stream	
 } AVStream;
 
 #define AV_PROGRAM_RUNNING 1
@@ -667,6 +676,8 @@ typedef struct AVChapter {
     AVDictionary *metadata;
 } AVChapter;
 
+#define MAX_STREAMS 30
+
 /**
  * Format I/O context.
  * New fields can be added to the end with minor version bumps.
@@ -695,7 +706,7 @@ typedef struct AVFormatContext {
      * streams.
      */
     struct AVPacketList *packet_buffer;
-
+	
     /**
      * Decoding: position of the first frame of the component, in
      * AV_TIME_BASE fractional seconds. NEVER set this value directly:
@@ -860,6 +871,25 @@ typedef struct AVFormatContext {
      * This will be moved into demuxer private options. Thus no API/ABI compatibility
      */
     int ts_id;
+    /* added by Z.C for m2ts files */
+    int orig_packet_size;
+
+    /* added by Z.C for index building */
+    int index_builded;
+
+    /* added by Z.C for some ps/ts file seeking */
+    int64_t valid_offset;
+    int valid_offset_done;
+
+    /* added by Z.C for avi or some other files seekable */
+    int seekable;	
+
+	uint64_t video_avg_frame_time, audio_avg_frame_time;
+
+	//--***********************************************
+    /* added by C.S for divx drm certification:drm information */
+    drm_t       drm;
+//--***********************************************  
 } AVFormatContext;
 
 typedef struct AVPacketList {
@@ -1084,6 +1114,12 @@ attribute_deprecated int av_open_input_file(AVFormatContext **ic_ptr, const char
                        AVInputFormat *fmt,
                        int buf_size,
                        AVFormatParameters *ap);
+attribute_deprecated int av_open_input_file_header(AVFormatContext **ic_ptr, const char *filename,
+                       AVInputFormat *fmt,
+                       int buf_size,
+                       AVFormatParameters *ap,
+                       const char *headers);
+
 #endif
 
 /**
@@ -1106,6 +1142,7 @@ attribute_deprecated int av_open_input_file(AVFormatContext **ic_ptr, const char
  * @note If you want to use custom IO, preallocate the format context and set its pb field.
  */
 int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options);
+int avformat_open_input_header(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options,const char * headers);
 
 int av_demuxer_open(AVFormatContext *ic, AVFormatParameters *ap);
 
diff --git a/amffmpeg/libavformat/avidec.c b/amffmpeg/libavformat/avidec.c
old mode 100644
new mode 100755
index 80620da..9c495a5
--- a/amffmpeg/libavformat/avidec.c
+++ b/amffmpeg/libavformat/avidec.c
@@ -55,6 +55,9 @@ typedef struct AVIStream {
     uint8_t *sub_buffer;
 
     int64_t seek_pos;
+    int sequence_head_size;
+    unsigned int sequence_head_offset;
+    char *sequence_head;
 } AVIStream;
 
 typedef struct {
@@ -97,6 +100,8 @@ static const char avi_headers[][8] = {
     { 0 }
 };
 
+#define VALID_VIDEO_4CC(a) (((a)==0x6264)||((a)==0x6364)||((a)==0x6464))
+      
 static int avi_load_index(AVFormatContext *s);
 static int guess_ni_flag(AVFormatContext *s);
 
@@ -230,6 +235,12 @@ static int read_braindead_odml_indx(AVFormatContext *s, int frame_num){
         }
     }
     avi->index_loaded=1;
+	
+	//add by X.H.
+	//av_log(NULL, AV_LOG_INFO, "[%s:%d]nb_frames=%x nb_index_entries=%d\n",__FUNCTION__, __LINE__, st->nb_frames, st->nb_index_entries);
+	if((st->nb_frames>>3) < st->nb_index_entries){
+		s->seekable = 1;
+	}
     return 0;
 }
 
@@ -906,7 +917,10 @@ static int avi_read_packet(AVFormatContext *s, AVPacket *pkt)
             }
         }
         if(!best_st)
-            return -1;
+        {                      
+            //return -1;
+            return AVERROR_EOF; 
+        }
 
         best_ast = best_st->priv_data;
         best_ts = av_rescale_q(best_ts, (AVRational){FFMAX(1, best_ast->sample_size), AV_TIME_BASE}, best_st->time_base);
@@ -1045,6 +1059,10 @@ resync:
     for(i=sync=avio_tell(pb); !url_feof(pb); i++) {
         int j;
 
+        // if exceed valid data, return EOF
+        if (s->valid_offset_done && (i >= s->valid_offset))
+            return AVERROR_EOF;
+        
         for(j=0; j<7; j++)
             d[j]= d[j+1];
         d[7]= avio_r8(pb);
@@ -1169,6 +1187,7 @@ static int avi_read_idx1(AVFormatContext *s, int size)
     AVIStream *ast;
     unsigned int index, tag, flags, pos, len;
     unsigned last_pos= -1;
+    int first_key_frame = 1;
 
     nb_index_entries = size / 16;
     if (nb_index_entries <= 0)
@@ -1204,6 +1223,12 @@ static int avi_read_idx1(AVFormatContext *s, int size)
         else if(len || !ast->sample_size)
             av_add_index_entry(st, pos, ast->cum_len, len, 0, (flags&AVIIF_INDEX) ? AVINDEX_KEYFRAME : 0);
         ast->cum_len += get_duration(ast, len);
+        if ((VALID_VIDEO_4CC(tag>>16)) && (flags&AVIIF_INDEX) && first_key_frame)
+        {
+            first_key_frame = 0;
+            ast->sequence_head_offset = pos;
+        }
+        
         last_pos= pos;
     }
     return 0;
@@ -1240,6 +1265,56 @@ static int guess_ni_flag(AVFormatContext *s){
     return last_start > first_end;
 }
 
+static int avi_save_sequence_head(AVFormatContext *s, AVIStream *avi_stream)
+{
+    unsigned int pos = avi_stream->sequence_head_offset;
+    unsigned char *first_key_chunk = NULL;
+    int i, sequence_head_pos = -1;
+    
+    first_key_chunk = av_malloc(2048);
+    if (first_key_chunk == NULL)
+        return -1;
+    
+    avio_seek(s->pb, pos, SEEK_SET);
+    avio_read(s->pb, first_key_chunk, 2048);
+
+    for (i=8;i<2045;i++)
+    {
+        if (sequence_head_pos < 0)
+        {
+            if ((first_key_chunk[i]==0x00)
+                && (first_key_chunk[i+1]==0x00)
+                && (first_key_chunk[i+2]==0x01)
+                && ((first_key_chunk[i+3]&0xe0)==0x20))
+            {
+                sequence_head_pos = i;
+            }
+        }
+        else 
+        {
+            if ((first_key_chunk[i]==0x00)
+                && (first_key_chunk[i+1]==0x00)
+                && (first_key_chunk[i+2]==0x01))
+            {
+                avi_stream->sequence_head = av_malloc(i - sequence_head_pos);
+                if (avi_stream->sequence_head)
+                {
+                    avi_stream->sequence_head_size = i - sequence_head_pos;
+                    memcpy(avi_stream->sequence_head, first_key_chunk + sequence_head_pos, i - sequence_head_pos);
+                    break;
+                }
+            }
+        }
+    }
+
+    av_free(first_key_chunk);
+
+    if (avi_stream->sequence_head)
+        return 0;
+    else
+        return -1;
+}
+
 static int avi_load_index(AVFormatContext *s)
 {
     AVIContext *avi = s->priv_data;
@@ -1247,7 +1322,10 @@ static int avi_load_index(AVFormatContext *s)
     uint32_t tag, size;
     int64_t pos= avio_tell(pb);
     int ret = -1;
+    unsigned int i;
+    AVIStream *avi_stream = NULL;
 
+    s->seekable = 0;
     if (avio_seek(pb, avi->movi_end, SEEK_SET) < 0)
         goto the_end; // maybe truncated file
     av_dlog(s, "movi_end=0x%"PRIx64"\n", avi->movi_end);
@@ -1267,6 +1345,7 @@ static int avi_load_index(AVFormatContext *s)
             if (avi_read_idx1(s, size) < 0)
                 goto skip;
             ret = 0;
+            s->seekable = 1;
                 goto the_end;
             break;
         default:
@@ -1278,6 +1357,13 @@ static int avi_load_index(AVFormatContext *s)
         }
     }
  the_end:
+    for (i=0; i<s->nb_streams; i++) {        
+        avi_stream = (AVIStream *)s->streams[i]->priv_data;        
+        if (avi_stream->sequence_head_offset) {
+            av_log(NULL, AV_LOG_INFO, "[%s]stream %d sequence head 0x%x\n", __FUNCTION__, i, avi_stream->sequence_head_offset);
+            avi_save_sequence_head(s, avi_stream);
+        }    
+    }
     avio_seek(pb, pos, SEEK_SET);
     return ret;
 }
diff --git a/amffmpeg/libavformat/avio.c b/amffmpeg/libavformat/avio.c
old mode 100644
new mode 100755
index b2926c0..19aee83
--- a/amffmpeg/libavformat/avio.c
+++ b/amffmpeg/libavformat/avio.c
@@ -83,6 +83,10 @@ int ffurl_register_protocol(URLProtocol *protocol, int size)
     return 0;
 }
 
+int av_register_protocol(URLProtocol *protocol){
+	return ffurl_register_protocol(protocol,sizeof(*protocol));
+}
+
 static int url_alloc_for_protocol (URLContext **puc, struct URLProtocol *up,
                                    const char *filename, int flags)
 {
@@ -257,6 +261,23 @@ int ffurl_open(URLContext **puc, const char *filename, int flags)
     *puc = NULL;
     return ret;
 }
+int ffurl_open_h(URLContext **puc, const char *filename, int flags,const char *headers)
+{
+    int ret = ffurl_alloc(puc, filename, flags);
+    if (ret)
+        return ret;
+	if(headers){
+		(*puc)->headers=av_strdup(headers);
+	}
+    ret = ffurl_connect(*puc);
+    if (!ret)
+        return 0;
+    ffurl_close(*puc);
+    *puc = NULL;
+    return ret;
+}
+
+
 
 static inline int retry_transfer_wrapper(URLContext *h, unsigned char *buf, int size, int size_min,
                                          int (*transfer_func)(URLContext *h, unsigned char *buf, int size))
@@ -277,6 +298,7 @@ static inline int retry_transfer_wrapper(URLContext *h, unsigned char *buf, int
                 fast_retries--;
             else
                 usleep(1000);
+			av_log(NULL,AV_LOG_INFO,"read/write time out,retry=%d\n",fast_retries);
         } else if (ret < 1)
             return ret < 0 ? ret : len;
         if (ret)
@@ -335,6 +357,7 @@ int ffurl_close(URLContext *h)
 #endif
     if (h->prot->priv_data_size)
         av_free(h->priv_data);
+	if(h->headers) av_free(h->headers);
     av_free(h);
     return ret;
 }
diff --git a/amffmpeg/libavformat/avio.h b/amffmpeg/libavformat/avio.h
old mode 100644
new mode 100755
index bf1ea30..3b0b7af
--- a/amffmpeg/libavformat/avio.h
+++ b/amffmpeg/libavformat/avio.h
@@ -33,6 +33,7 @@
 #include "libavformat/version.h"
 
 
+
 #define AVIO_SEEKABLE_NORMAL 0x0001 /**< Seeking works like for a local file */
 
 /**
@@ -66,6 +67,7 @@ typedef struct {
     int write_flag;         /**< true if open for writing */
 #if FF_API_OLD_AVIO
     attribute_deprecated int is_streamed;
+	int is_slowmedia;
 #endif
     int max_packet_size;
     unsigned long checksum;
@@ -83,10 +85,15 @@ typedef struct {
      */
     int64_t (*read_seek)(void *opaque, int stream_index,
                          int64_t timestamp, int flags);
+	int64_t (*exseek)(void *opaque,int64_t offset, int whence);
+	char * reallocation;
     /**
      * A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.
      */
+    unsigned char *filename;  /**< Start of the buffer. */
     int seekable;
+	int enabled_lp_buffer;
+	int support_time_seek;
 } AVIOContext;
 
 /* unbuffered I/O */
@@ -100,15 +107,21 @@ typedef struct {
  * sizeof(URLContext) must not be used outside libav*.
  * @deprecated This struct will be made private
  */
+ struct  url_lpbuf;
 typedef struct URLContext {
     const AVClass *av_class; ///< information for av_log(). Set by url_open().
     struct URLProtocol *prot;
+	struct  url_lpbuf  *lpbuf;
     int flags;
     int is_streamed;  /**< true if streamed (no seek possible), default = false */
     int max_packet_size;  /**< if non zero, the stream is packetized with this max packet size */
     void *priv_data;
     char *filename; /**< specified URL */
+	char *headers; /**< specified URL */
     int is_connected;
+	int is_slowmedia;
+	int support_time_seek;
+	char *location;
 } URLContext;
 
 #define URL_PROTOCOL_FLAG_NESTED_SCHEME 1 /*< The protocol name can be the first part of a nested protocol scheme */
@@ -121,8 +134,9 @@ typedef struct URLProtocol {
     const char *name;
     int (*url_open)(URLContext *h, const char *url, int flags);
     int (*url_read)(URLContext *h, unsigned char *buf, int size);
-    int (*url_write)(URLContext *h, const unsigned char *buf, int size);
+    int (*url_write)(URLContext *h,  unsigned char *buf, int size);
     int64_t (*url_seek)(URLContext *h, int64_t pos, int whence);
+	int64_t (*url_exseek)(URLContext *h, int64_t pos, int whence);
     int (*url_close)(URLContext *h);
     struct URLProtocol *next;
     int (*url_read_pause)(URLContext *h, int pause);
@@ -153,6 +167,11 @@ attribute_deprecated int url_poll(URLPollEntry *poll_table, int n, int timeout);
 #define URL_RDONLY 1  /**< read-only */
 #define URL_WRONLY 2  /**< write-only */
 #define URL_RDWR   (URL_RDONLY|URL_WRONLY)  /**< read-write */
+
+
+#define URL_MINI_BUFFER	0x20000000
+#define URL_NO_LP_BUFFER	0x40000000
+
 /**
  * @}
  */
@@ -433,6 +452,13 @@ int avio_put_str16le(AVIOContext *s, const char *str);
  * fseek() equivalent for AVIOContext.
  * @return new position or AVERROR.
  */
+
+
+#define AVSEEK_TO_TIME 			0x30000
+#define AVSEEK_BUFFERED_TIME 	0x40000
+#define AVSEEK_FULLTIME 		0x50000
+
+
 int64_t avio_seek(AVIOContext *s, int64_t offset, int whence);
 
 /**
@@ -570,6 +596,15 @@ int avio_open(AVIOContext **s, const char *url, int flags);
  *
  * @return 0 on success, an AVERROR < 0 on error.
  */
+int avio_open_h(AVIOContext **s, const char *filename, int flags,const char * headers);
+
+/**
+ * Close the resource accessed by the AVIOContext s and free it.
+ * This function can only be used if s was opened by avio_open().
+ *
+ * @return 0 on success, an AVERROR < 0 on error.
+ */
+ 
 int avio_close(AVIOContext *s);
 
 /**
@@ -632,4 +667,21 @@ int     avio_pause(AVIOContext *h, int pause);
 int64_t avio_seek_time(AVIOContext *h, int stream_index,
                        int64_t timestamp, int flags);
 
+static inline int url_support_time_seek(AVIOContext *s)
+{
+    return s->support_time_seek;
+}
+ int64_t url_fseektotime(AVIOContext *s,int totime_s,int flags);
+ int url_buffering_data(AVIOContext *s,int size);
+ int64_t url_ffulltime(ByteIOContext *s);
+ int64_t url_buffed_pos(ByteIOContext *s);
+ int64_t url_fbuffered_time(ByteIOContext *s);
+#define av_read_frame_flush(s) ff_read_frame_flush(s)
+
+
+#include "libavformat/url.h"
+#include "libavformat/aviolpbuf.h"
+
+
+
 #endif /* AVFORMAT_AVIO_H */
diff --git a/amffmpeg/libavformat/aviobuf.c b/amffmpeg/libavformat/aviobuf.c
old mode 100644
new mode 100755
index aad0240..9aac7e0
--- a/amffmpeg/libavformat/aviobuf.c
+++ b/amffmpeg/libavformat/aviobuf.c
@@ -28,6 +28,7 @@
 #include "url.h"
 #include <stdarg.h>
 
+
 #define IO_BUFFER_SIZE 32768
 
 /**
@@ -293,6 +294,59 @@ int url_ferror(AVIOContext *s)
     return s->error;
 }
 #endif
+int64_t url_ffulltime(AVIOContext *s)
+{
+	int64_t size;
+	if (!s->exseek)
+        return AVERROR(EPIPE);
+	size = s->exseek(s->opaque, 0, AVSEEK_FULLTIME);
+	return size;
+}
+
+int64_t url_fseektotime(AVIOContext *s,int totime_s,int flags)
+{
+	int64_t offset1;
+	if(s->exseek){
+		if((offset1=s->exseek(s->opaque, totime_s, AVSEEK_TO_TIME))>=0)
+		{
+			if (!s->write_flag)
+				s->buf_end = s->buffer;
+			s->buf_ptr = s->buffer;
+			s->pos = 0;/*I think it is the first,pos now*/
+			s->eof_reached=0;/*clear eof error*/
+			return offset1;
+		}
+	}
+	return AVERROR(EPIPE);
+}
+
+int64_t url_fbuffered_time(AVIOContext *s)
+{
+	int64_t bufferedtime;
+	if (!s->exseek)
+        return AVERROR(EPIPE);
+	bufferedtime = s->exseek(s->opaque,0,AVSEEK_BUFFERED_TIME);
+	return bufferedtime;
+}
+int64_t url_buffed_pos(AVIOContext *s)
+{
+	if(!s)
+		return 0;
+	if(s->enabled_lp_buffer)
+		return url_lp_get_buffed_pos(s->opaque);
+	else
+		return s->pos;
+}
+int url_buffering_data(AVIOContext *s,int size)
+{
+	if(s->enabled_lp_buffer)
+		return url_lp_intelligent_buffering(s->opaque,size);
+	else
+		return -1;
+}
+
+
+
 
 void avio_wl32(AVIOContext *s, unsigned int val)
 {
@@ -349,6 +403,9 @@ PUT(32, unsigned int)
 PUT(64, uint64_t)
 #undef PUT
 
+
+
+
 int get_byte(AVIOContext *s)
 {
    return avio_r8(s);
@@ -836,7 +893,7 @@ int ffio_fdopen(AVIOContext **s, URLContext *h)
 {
     uint8_t *buffer;
     int buffer_size, max_packet_size;
-
+	int lpbuffer_size=(h->flags & URL_MINI_BUFFER)?IO_LP_BUFFER_MINI_SIZE:IO_LP_BUFFER_SIZE;
     max_packet_size = h->max_packet_size;
     if (max_packet_size) {
         buffer_size = max_packet_size; /* no need to bufferize more than one packet */
@@ -852,17 +909,37 @@ int ffio_fdopen(AVIOContext **s, URLContext *h)
         av_free(buffer);
         return AVERROR(ENOMEM);
     }
-
-    if (ffio_init_context(*s, buffer, buffer_size,
-                      h->flags & AVIO_FLAG_WRITE, h,
-                      (void*)ffurl_read, (void*)ffurl_write, (void*)ffurl_seek) < 0) {
-        av_free(buffer);
-        av_freep(s);
-        return AVERROR(EIO);
-    }
+	av_log(NULL, AV_LOG_INFO, "ffio_fdopen (h->is_slowmedia=%d,flags=%x\n",h->is_slowmedia,h->flags);
+	 if((h->is_slowmedia) && 
+		!(h->flags & URL_NO_LP_BUFFER)	&&		/*no lp buffer*/	
+		!(h->flags & URL_WRONLY)  && /*no write support*/
+		!url_lpopen(h,lpbuffer_size)){
+		av_log(NULL, AV_LOG_INFO, "ffio_fdopen Register lpbuf");
+		 if (ffio_init_context(*s, buffer, buffer_size,
+	                      h->flags & AVIO_FLAG_WRITE, h,
+	                      (void*)url_lpread, (void*)NULL, (void*)url_lpseek) < 0) {
+	        av_free(buffer);
+	        av_freep(s);
+	        return AVERROR(EIO);
+	    }
+		(*s)->exseek=url_lpexseek;
+	
+	}else{
+	    if (ffio_init_context(*s, buffer, buffer_size,
+	                      h->flags & AVIO_FLAG_WRITE, h,
+	                      (void*)ffurl_read, (void*)ffurl_write, (void*)ffurl_seek) < 0) {
+	        av_free(buffer);
+	        av_freep(s);
+	        return AVERROR(EIO);
+	    }
+	}
 #if FF_API_OLD_AVIO
     (*s)->is_streamed = h->is_streamed;
+	(*s)->is_slowmedia = h->is_slowmedia;
+
 #endif
+	(*s)->support_time_seek = h->support_time_seek;
+	(*s)->reallocation=h->location;
     (*s)->seekable = h->is_streamed ? 0 : AVIO_SEEKABLE_NORMAL;
     (*s)->max_packet_size = max_packet_size;
     if(h->prot) {
@@ -955,13 +1032,33 @@ int avio_open(AVIOContext **s, const char *filename, int flags)
     }
     return 0;
 }
+int avio_open_h(AVIOContext **s, const char *filename, int flags,const char * headers)
+{
+    URLContext *h;
+    int err;
+
+    err = ffurl_open_h(&h, filename, flags,headers);
+    if (err < 0)
+        return err;
+    err = ffio_fdopen(s, h);
+    if (err < 0) {
+        ffurl_close(h);
+        return err;
+    }
+    return 0;
+}
+
 
 int avio_close(AVIOContext *s)
 {
     URLContext *h = s->opaque;
-
+	if(s->filename) av_free(s->filename);
     av_free(s->buffer);
     av_free(s);
+	if(h && h->lpbuf)	
+	{
+		url_lpfree(h);
+	}
     return ffurl_close(h);
 }
 
diff --git a/amffmpeg/libavformat/aviolpbuf.c b/amffmpeg/libavformat/aviolpbuf.c
new file mode 100755
index 0000000..3defa40
--- /dev/null
+++ b/amffmpeg/libavformat/aviolpbuf.c
@@ -0,0 +1,505 @@
+
+/*
+ * Buffered I/O for ffmpeg system
+ * Copyright (c) 2000,2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * 	LOOPBUF READ
+ * 	Write By zhi.zhou@amlogic.com
+ *
+ */
+
+#include "libavutil/crc.h"
+#include "libavutil/intreadwrite.h"
+#include "avformat.h"
+#include "avio.h"
+#include <stdarg.h>
+#include "aviolpcache.h"
+#include "aviolpbuf.h"
+
+/*
+										Pos		
+buffer    rp                         wp                   buffer_end 
+|           |                           |                           |
+================================
+|                                                                     |
+|<--------------buffer_size-------------->|
+
+
+valid_data_too_read:
+	if wp>=rp
+		wp-rp
+	else
+	    buffer_size-(rp-wp)
+
+valid_data_size:for seek;
+
+alway ++,utill seek to empte the buff;
+
+Can seek back size:
+	min(valid_data_size-valid_data_too_read,data between buffe,rp)
+
+*/
+//#define LP_BUFFER_DEBUG
+#define LP_SK_DEBUG
+//#define LP_RD_DEBUG
+#ifdef LP_SK_DEBUG
+#define lp_sprint(level,fmt...) av_log(NULL,level,##fmt)
+#else
+#define lp_sprint(level,fmt...)
+#endif
+
+#ifdef LP_RD_DEBUG
+#define lp_rprint(level,fmt...) av_log(NULL,level,##fmt)
+#else
+#define lp_rprint(level,fmt...)
+#endif
+
+#ifdef LP_BUFFER_DEBUG
+#define lp_bprint(level,fmt...) av_log(NULL,level,##fmt)
+#else
+#define lp_bprint(level,fmt...)
+#endif
+
+
+#define LP_ASSERT(x)	 do{if(!(x)) av_log(NULL,AV_LOG_INFO,"****\t\tERROR at line file%s=%d\n\n\n",__FILE__,__LINE__);}while(0)
+
+int url_lpopen(URLContext *s,int size)
+{
+	url_lpbuf_t *lp;
+	lp_bprint( AV_LOG_INFO,"url_lpopen=%d\n",size);
+	if(!s)
+		return -1;
+		lp_bprint( AV_LOG_INFO,"url_lpopen2=%d\n",size);
+	lp=av_mallocz(sizeof(url_lpbuf_t));
+	if(!lp)
+		return AVERROR(ENOMEM);
+	lp->buffer=av_malloc(size);
+	if(!lp->buffer)
+	{
+		av_free(lp->buffer);
+		return AVERROR(ENOMEM);
+	}
+		lp_bprint( AV_LOG_INFO,"url_lpopen3=%d\n",size);
+	s->lpbuf=lp;
+	lp->buffer_size=size;
+	lp->rp=lp->buffer;
+	lp->wp=lp->buffer;
+	lp->buffer_end=lp->buffer+size;
+	lp->valid_data_size=0;
+	lp->pos=0;
+	lp->block_read_size=FFMIN(32*1024,size>>4);
+	lp_lock_init(&lp->mutex,NULL);
+	lp->file_size=url_lpseek(s,0,AVSEEK_SIZE);
+	lp->cache_enable=0;
+	lp->cache_id=aviolp_cache_open(s->filename,url_filesize(s));
+	if(lp->cache_id!=0)
+		lp->cache_enable=1;
+		lp_bprint( AV_LOG_INFO,"url_lpopen4%d\n",size);
+	return 0;
+}
+
+
+int url_lpfillbuffer(URLContext *s,int size)
+{
+	url_lpbuf_t *lp;
+	int rlen=0;
+	int ssread;
+	int cache_read_len=0;
+	
+	
+	if(!s || !s->lpbuf)
+		return AVERROR(EINVAL);
+
+	lp=s->lpbuf;
+	lp_lock(&lp->mutex);
+	
+	if(lp->wp>=lp->rp)
+	{
+		if(lp->rp!=lp->buffer)
+			ssread=FFMIN(size,lp->buffer_end-lp->wp);
+		else
+			ssread=FFMIN(size,lp->buffer_end-lp->wp-32);
+	}
+	else
+		ssread=FFMIN(size,lp->rp-lp->wp-32);/*reversed 32bytes;*/
+	lp_bprint( AV_LOG_INFO,"fill buffer %d,buffer=%x,rp=%x,wp=%x,buffer_end=%x,size=%d\n",ssread,lp->buffer,lp->rp,lp->wp,lp->buffer_end,size);
+	if(ssread<=0)
+	{
+		rlen=0;
+		goto release;
+	}
+	if(lp->cache_enable){
+		/*do read on cache first*/
+		rlen=aviolp_cache_read(lp->cache_id,lp->pos,lp->wp,ssread);
+		cache_read_len=rlen;
+		lp_bprint(AV_LOG_INFO,"filled buffer from cache=%d\n",cache_read_len);
+	}
+	if(rlen<=0){
+		if(lp->file_size>0 && lp->pos>=lp->file_size){
+			rlen=0;/*file read end*/
+			goto release;
+		}else if(lp->cache_enable && s->prot->url_seek(s,0,SEEK_CUR)!=lp->pos){/*maybe do read from cache file before,so seek it now*/
+			int ret=s->prot->url_seek(s,lp->pos,SEEK_SET);
+			if(ret!=lp->pos){
+				rlen=-1;/*error*/
+				goto release;
+			}	
+		}	
+		rlen=s->prot->url_read(s,lp->wp,ssread);
+		lp_bprint(AV_LOG_INFO,"filled buffer from remote=%d\n",rlen);
+		
+	}	
+	if(rlen>0)
+	{
+		if(lp->cache_enable&& cache_read_len<=0)/*not read from cache itself*/
+			aviolp_cache_write(lp->cache_id,lp->pos,lp->wp,rlen);
+		lp->valid_data_size+=rlen;
+		lp->pos+=rlen;
+		lp->wp+=rlen;
+		if(lp->wp>=lp->buffer_end)
+			lp->wp=lp->buffer;
+		
+	}
+release:
+	lp_unlock(&lp->mutex);
+	lp_bprint( AV_LOG_INFO,"lpfilld=%d\n",rlen);
+	return rlen;
+}
+
+int url_lpread(URLContext *s,unsigned char * buf,int size)
+{
+	url_lpbuf_t *lp;
+	int len=size;
+	int valid_data_can_read;
+	unsigned char *tbuf=buf;
+
+	if(!s || !s->lpbuf)
+		return -1;
+	lp=s->lpbuf;
+	lp_lock(&lp->mutex);
+	lp_rprint(AV_LOG_INFO, "url_lpread:buffer=%x,rp=%x,wp=%x,end=%x,lp->valid_data_size=%d,pos=%lld\n",
+		lp->buffer,lp->rp,lp->wp,lp->buffer_end,lp->valid_data_size,lp->pos);
+	while(len>0)
+	{
+		if(lp->wp>=lp->rp)
+			valid_data_can_read=lp->wp-lp->rp;
+		else
+			valid_data_can_read=lp->buffer_end-lp->rp;
+		valid_data_can_read=FFMIN(len,valid_data_can_read);
+		LP_ASSERT(valid_data_can_read>=0);
+		if(valid_data_can_read==0)
+		{
+			int rlen;
+			lp_unlock(&lp->mutex);
+			rlen=url_lpfillbuffer(s,lp->block_read_size);
+			if(rlen<=0)
+				{
+				lp_unlock(&lp->mutex);
+				return ((size-len)>0)?(size-len):rlen;
+				}
+			lp_lock(&lp->mutex);
+		}
+		lp_rprint( AV_LOG_INFO, "url_lpread:buffer=%x,rp=%x,wp=%x,end=%x,tbuf=%x,valid_data_can_read=%x(%d)\n",
+			lp->buffer,lp->rp,lp->wp,lp->buffer_end,tbuf,valid_data_can_read,valid_data_can_read);
+		if(valid_data_can_read>0)
+		{
+			if(tbuf!=NULL)
+			{
+				memcpy(tbuf,lp->rp,valid_data_can_read);
+				tbuf+=valid_data_can_read;
+			}
+			lp->rp+=valid_data_can_read;
+			if(lp->rp>=lp->buffer_end)
+				lp->rp=lp->buffer;
+			len-=valid_data_can_read;
+		}
+		LP_ASSERT(lp->rp>=lp->buffer);
+		LP_ASSERT(lp->rp<lp->buffer_end);
+	}
+	lp_unlock(&lp->mutex);
+	return (tbuf-buf);
+}
+
+int64_t url_lpseek(URLContext *s, int64_t offset, int whence)
+{
+	int64_t pos_on_read;
+	url_lpbuf_t *lp;
+	int valid_data_can_seek_forward;
+	int valid_data_can_seek_back;
+	int64_t offset1;
+	int ret;
+
+	if(!s || !s->lpbuf)
+		return AVERROR(EINVAL);
+
+	lp=s->lpbuf;
+	lp_lock(&lp->mutex);
+	lp_sprint( AV_LOG_INFO, "url_lpseek:offset=%lld whence=%d,buffer=%x,rp=%x,wp=%x,end=%x,pos=%lld\n",
+		offset,whence,lp->buffer,lp->rp,lp->wp,lp->buffer_end,lp->pos);
+	if (whence == AVSEEK_SIZE)
+	{
+		int64_t size;
+		size = s->prot->url_seek(s, 0, AVSEEK_SIZE);
+		if(size<0){
+			if ((size = s->prot->url_seek(s, -1, SEEK_END)) < 0)
+			{
+				lp_unlock(&lp->mutex);
+				return size;
+			}
+			size++;
+			s->prot->url_seek(s,lp->pos, SEEK_SET);
+		}
+		lp_sprint(AV_LOG_INFO,"get file size=%lld\n",size);
+		lp_unlock(&lp->mutex);
+		return size;
+	}
+	else if(whence == SEEK_END)
+	{
+		if ((offset1=s->prot->url_seek(s, offset, SEEK_END)) < 0)
+		{
+			lp_unlock(&lp->mutex);
+			return offset1;
+		}
+		lp->rp=lp->buffer;
+		lp->wp=lp->buffer;
+		lp->valid_data_size=0;
+		lp->pos=offset1;
+		lp_unlock(&lp->mutex);
+		return offset1;
+	}
+    if (whence != SEEK_CUR && whence != SEEK_SET)
+    {
+      		lp_unlock(&lp->mutex);
+        	return AVERROR(EINVAL);
+    }
+
+	if(lp->wp>=lp->rp)
+		valid_data_can_seek_forward=lp->wp-lp->rp;
+	else
+		valid_data_can_seek_forward=lp->buffer_size-(lp->rp-lp->wp);
+	pos_on_read = lp->pos-valid_data_can_seek_forward;
+ 	
+	if(whence == SEEK_CUR)
+	{
+		offset1 = pos_on_read;
+		if (offset == 0)
+		{
+			lp_unlock(&lp->mutex);
+			return offset1;
+		}
+		offset += offset1;
+	}
+	valid_data_can_seek_back=FFMIN(lp->valid_data_size-valid_data_can_seek_forward,
+						lp->buffer_size-valid_data_can_seek_forward-64);
+	if(valid_data_can_seek_back<0) 
+		valid_data_can_seek_back=0;
+	offset1 = offset - pos_on_read;/*seek forword or back*/
+	lp_sprint( AV_LOG_INFO, "url_lpseek:pos_on_read=%lld,can seek forwart=%d,can seek bacd=%d,offset1=%lld\n",
+		pos_on_read,valid_data_can_seek_forward,valid_data_can_seek_back,offset1);
+	if(offset1>=0 && offset1<=valid_data_can_seek_forward)
+	{/*seek forward in lp buffer*/
+		lp_sprint( AV_LOG_INFO, "url_lpseek:buffer seek forword offset=%lld offset1=%lld whence=%d\n",offset,offset1,whence);
+		lp->rp+=(int)offset1;
+		if(lp->rp>=lp->buffer_end)
+			lp->rp-=lp->buffer_size;
+	}else if(offset1<0 && (-offset1)<=valid_data_can_seek_back)
+	{/*seek back in lp buffer*/
+		lp_sprint( AV_LOG_INFO, "url_lpseek:buffer seek back offset=%lld offset1=%lld whence=%d,(int)offset1=%d\n",offset,offset1,whence,(int)offset1);
+		lp->rp+=(int)offset1;
+		if(lp->rp<lp->buffer)
+			lp->rp+=lp->buffer_size;
+		
+	}else if(offset1>0 && (s->is_streamed || s->is_slowmedia) && 
+			(offset1<lp->buffer_size-lp->block_read_size) && 
+			(lp->file_size<=0 || (lp->file_size>0 && offset1<lp->file_size/2)))/*if offset1>filesize/2,thendo first seek end,don't buffer*/
+	{/*seek to buffer end,but buffer is not full,do read seek*/
+		int read_offset,ret;
+		lp_sprint( AV_LOG_INFO, "url_lpseek:buffer read seek forward offset=%lld offset1=%lld  whence=%d\n",offset,offset1,whence);
+		lp->rp+=valid_data_can_seek_forward;
+		if(lp->rp>=lp->buffer_end)
+			lp->rp-=lp->buffer_size;
+		lp_unlock(&lp->mutex);
+		read_offset=offset1-valid_data_can_seek_forward;
+		while(read_offset>0){
+			ret=url_lpread(s,NULL,read_offset);/*do read seek*/
+			if(ret>0)
+				read_offset-=ret;
+			else if(ret!=AVERROR(EAGAIN)){
+				offset=ret;/*get error,exit now*/
+				break;
+			}
+		}
+		lp_lock(&lp->mutex);
+	}else
+	{/*not support in buffer seek,do low level seek now*/
+		lp_sprint( AV_LOG_INFO, "url_lpseek:buffer lowlevel seek  offset=%lld  offset1=%lld whence=%d\n",offset,offset1,whence);
+		if(lp->cache_enable && offset<lp->file_size){
+			/*if cache enable not need to seek here,seek  on cache missed*/
+			;/*do't do seek here*/
+		}else if ((offset1=s->prot->url_seek(s, offset, SEEK_SET)) < 0)
+		{
+			lp->valid_data_size=0;/*seek failed clear all old datas*/
+			s->prot->url_seek(s, lp->pos, SEEK_SET);/*clear the lowlevel errors*/
+			lp_unlock(&lp->mutex);
+			return  offset1;
+		}
+		lp->rp=lp->buffer;
+		lp->wp=lp->buffer;
+		lp->valid_data_size=0;
+		lp->pos=offset;
+	}
+	lp_sprint( AV_LOG_INFO, "url_lpseekend:offset=%lld whence=%d,buffer=%x,rp=%x,wp=%x,end=%x,pos=%lld\n",
+		offset,whence,lp->buffer,lp->rp,lp->wp,lp->buffer_end,lp->pos);
+	LP_ASSERT(lp->rp>=lp->buffer);
+	LP_ASSERT(lp->rp<lp->buffer_end);
+	lp_unlock(&lp->mutex);
+	return offset;
+}
+
+int64_t url_lpexseek(URLContext *s, int64_t offset, int whence)
+{
+	url_lpbuf_t *lp;
+	int64_t ret;
+
+	if(!s || !s->lpbuf || !s->prot->url_exseek)
+		return AVERROR(EINVAL);
+
+	lp=s->lpbuf;
+	lp_lock(&lp->mutex);
+	if (whence == AVSEEK_FULLTIME)
+	{
+		ret=s->prot->url_exseek(s,0, AVSEEK_FULLTIME);/*clear the lowlevel errors*/
+	}
+	else if (whence == AVSEEK_BUFFERED_TIME)
+	{
+		ret=s->prot->url_exseek(s,0, AVSEEK_BUFFERED_TIME);/*clear the lowlevel errors*/
+	}
+	else if(whence == AVSEEK_TO_TIME ){
+	 	if(s->prot->url_exseek){
+			if((ret=s->prot->url_exseek(s, offset, AVSEEK_TO_TIME))>=0)
+			{
+				lp->rp=lp->buffer;
+				lp->wp=lp->buffer;
+				lp->valid_data_size=0;
+				lp->pos=0; 
+				goto seek_end;
+			}
+	 	}
+		ret= AVERROR(EPIPE);
+	}
+seek_end:
+	lp_unlock(&lp->mutex);
+	return ret;
+}
+
+int url_lp_getbuffering_size(URLContext *s,int *forward_data,int *back_data)
+{
+	url_lpbuf_t *lp;
+	int valid_data_can_seek_forward;
+	int valid_data_can_seek_back;
+	int ret;
+
+	if(!s || !s->lpbuf)
+		return AVERROR(EINVAL);
+
+	lp=s->lpbuf;
+	lp_lock(&lp->mutex);
+	if(lp->wp>=lp->rp)
+		valid_data_can_seek_forward=lp->wp-lp->rp;
+	else
+		valid_data_can_seek_forward=lp->buffer_size-(lp->rp-lp->wp);
+
+	valid_data_can_seek_back=FFMIN(lp->valid_data_size-valid_data_can_seek_forward,
+						lp->buffer_size-valid_data_can_seek_forward-64);
+	if(valid_data_can_seek_back<0) 
+		valid_data_can_seek_back=0;
+	lp_unlock(&lp->mutex);
+
+	if(forward_data)	
+		*forward_data=valid_data_can_seek_forward;
+	if(back_data)	
+		*back_data=valid_data_can_seek_back;
+	return (valid_data_can_seek_back+valid_data_can_seek_forward);
+}
+
+
+int64_t url_lp_get_buffed_pos(URLContext *s)
+{
+	url_lpbuf_t *lp;
+	int64_t pos;
+	int buffer_in_cache=0;
+	if(!s || !s->lpbuf)
+			return AVERROR(EINVAL);
+	lp=s->lpbuf;
+	lp_lock(&lp->mutex);
+	pos=lp->pos;
+	if(lp->cache_enable){
+		buffer_in_cache=aviolp_cache_next_valid_bytes(lp->cache_id,pos,INT_MAX);
+		if(buffer_in_cache>0)
+			pos+=buffer_in_cache;
+	}
+	lp_unlock(&lp->mutex);
+	/*lp_sprint(AV_LOG_INFO,"buffered pos=%lld,file_size=%lld,percent=%d.%02d%%,buffer_in_cache=%d\n",
+		pos,lp->file_size,(int)(pos*100/lp->file_size),(int)((pos*10000/lp->file_size)%100),buffer_in_cache);*/
+	return pos;
+}
+
+int url_lp_intelligent_buffering(URLContext *s,int size)
+{
+	int forward_data,back_data;
+	int datalen;
+	url_lpbuf_t *lp;
+	int ret=0;
+	
+	if(!s || !s->lpbuf)
+		return AVERROR(EINVAL);
+
+	
+	lp=s->lpbuf;
+	if(size <=0)
+		size=lp->block_read_size; 
+	datalen= url_lp_getbuffering_size(s,&forward_data,&back_data);
+	lp_bprint( AV_LOG_INFO, "url_lp buffering:datalen=%d,forward_datad=%d,back_data=%d,lp->buffer_size=%d,size=%d\n",
+		datalen,forward_data,back_data,lp->buffer_size,size);
+	if(datalen>=0 && ((datalen <lp->buffer_size-1024) || (back_data>(forward_data/2+1))))
+		ret=url_lpfillbuffer(s,size);
+
+	return ret;
+}
+
+int url_lpfree(URLContext *s)
+{
+	if(s->lpbuf)
+	{
+		lp_lock(&s->lpbuf->mutex);
+		if(s->lpbuf->cache_enable)
+			aviolp_cache_close(s->lpbuf->cache_id);
+		/*release other threadlater...*/
+		lp_unlock(&s->lpbuf->mutex);
+		if(s->lpbuf->buffer)
+			av_free(s->lpbuf->buffer);
+		av_free(s->lpbuf);
+		s->lpbuf=NULL;
+	}
+	return 0;
+}
+
+
+
+
diff --git a/amffmpeg/libavformat/aviolpbuf.h b/amffmpeg/libavformat/aviolpbuf.h
new file mode 100755
index 0000000..dcdde9b
--- /dev/null
+++ b/amffmpeg/libavformat/aviolpbuf.h
@@ -0,0 +1,41 @@
+#ifndef AVIO_LPBUF_HEADER
+#define AVIO_LPBUF_HEADER
+#include <libavformat/avio.h>
+
+#include <pthread.h>
+
+#define lock_t			pthread_mutex_t
+#define lp_lock_init(x,v) 	pthread_mutex_init(x,v)
+#define lp_lock(x)		pthread_mutex_lock(x)
+#define lp_unlock(x)   	pthread_mutex_unlock(x)
+
+
+typedef struct  url_lpbuf{
+	unsigned char *buffer;
+	unsigned char *buffer_end;
+	int buffer_size;
+	unsigned char *rp,*wp;
+	int valid_data_size;
+	int64_t pos;
+	int block_read_size;
+	int64_t file_size;
+	lock_t mutex;
+	int cache_enable;
+	unsigned long cache_id;
+}url_lpbuf_t;
+#define IO_LP_BUFFER_SIZE (1024*1024*6)
+#define IO_LP_BUFFER_MINI_SIZE (1024*64)
+
+
+int url_lpopen(URLContext *s,int size);
+int url_lpfillbuffer(URLContext *s,int size);
+int64_t url_lpexseek(URLContext *s, int64_t offset, int whence); 
+int url_lpread(URLContext *s,unsigned char * buf,int size);
+int64_t url_lpseek(URLContext *s, int64_t offset, int whence);
+int url_lpfree(URLContext *s);
+int url_lp_intelligent_buffering(URLContext *s,int size);
+int url_lp_getbuffering_size(URLContext *s,int *forward_data,int *back_data);
+int64_t url_lp_get_buffed_pos(URLContext *s);
+
+#endif
+
diff --git a/amffmpeg/libavformat/aviolpcache.c b/amffmpeg/libavformat/aviolpcache.c
new file mode 100755
index 0000000..6fcad66
--- /dev/null
+++ b/amffmpeg/libavformat/aviolpcache.c
@@ -0,0 +1,102 @@
+/*
+ * Buffered I/O for ffmpeg system
+ * Copyright (c) 2000,2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ *  LOOPBUF READ
+ *  Write By zhi.zhou@amlogic.com
+ *
+ */
+
+#include "libavutil/crc.h"
+#include "libavutil/intreadwrite.h"
+#include "avformat.h"
+#include "avio.h"
+#include <stdarg.h>
+#include "aviolpcache.h"
+
+static struct cache_client *default_cache_client = NULL;
+
+
+int aviolp_register_cache_system(struct cache_client *cache)
+{
+    if (default_cache_client == NULL) { /*only alow first  register*/
+        default_cache_client = cache;
+    } else {
+        return -1;
+    }
+    return 0;
+}
+static inline struct cache_client   *get_default_cache_client(void) {
+    return default_cache_client;
+}
+
+int aviolp_cache_read(int id, int64_t offset, char *buf, int size)
+{
+    struct cache_client *client = get_default_cache_client();
+    if (client && client->cache_read) {
+        return client->cache_read(id, offset, buf, size);
+    } else {
+        return -1;
+    }
+}
+int aviolp_cache_write(int id, int64_t offset, char *buf, int size)
+{
+    struct cache_client *client = get_default_cache_client();
+    if (client && client->cache_write) {
+        return client->cache_write(id, offset, buf, size);
+    } else {
+        return -1;
+    }
+
+}
+
+unsigned long aviolp_cache_open(const char * url, int64_t file_size)
+{
+    struct cache_client *client = get_default_cache_client();
+    if (client && client->cache_open) {
+        return client->cache_open(url, file_size);
+    } else {
+        return 0;
+    }
+}
+int aviolp_cache_next_valid_bytes(int id, int64_t offset, int maxsize)
+{
+    struct cache_client *client = get_default_cache_client();
+    if (client && client->cache_next_valid_bytes) {
+        return client->cache_next_valid_bytes(id, offset, maxsize);
+    } else {
+        return 0;
+    }
+}
+
+
+
+int aviolp_cache_close(int cache_id)
+{
+    struct cache_client *client = get_default_cache_client();
+    if (client && client->cache_close) {
+        return client->cache_close(cache_id);
+    } else {
+        return -1;
+    }
+}
+
+
+
+
diff --git a/amffmpeg/libavformat/aviolpcache.h b/amffmpeg/libavformat/aviolpcache.h
new file mode 100755
index 0000000..7ff62aa
--- /dev/null
+++ b/amffmpeg/libavformat/aviolpcache.h
@@ -0,0 +1,22 @@
+#ifndef AVIOLP_CACHE_HEADER_
+#define AVIOLP_CACHE_HEADER_
+
+struct cache_client {
+    int (*cache_read)(unsigned long id, int64_t off, char *buf, int size);
+    int (*cache_write)(unsigned long id, int64_t off, char *buf, int size);
+    int (*cache_next_valid_bytes)(unsigned long id, int64_t off, int size);
+    unsigned long(*cache_open)(char *url, int64_t filesize);/**/
+    int (*cache_close)(unsigned long id);
+};
+
+
+int aviolp_register_cache_system(struct cache_client *cache);
+int aviolp_cache_read(int id, int64_t offset, char *buf, int size);
+int aviolp_cache_next_valid_bytes(int id, int64_t offset, int maxsize);
+int aviolp_cache_write(int id, int64_t offset, char *buf, int size);
+unsigned long aviolp_cache_open(const char * url, int64_t file_size);
+int aviolp_cache_close(int cache_id);
+
+
+#endif
+
diff --git a/amffmpeg/libavformat/divxdrm.h b/amffmpeg/libavformat/divxdrm.h
new file mode 100644
index 0000000..cb50232
--- /dev/null
+++ b/amffmpeg/libavformat/divxdrm.h
@@ -0,0 +1,335 @@
+/********************************************************
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ * ********************************************************/
+
+#ifndef DIVXDRM_H
+#define DIVXDRM_H
+
+/************************************************************************************
+ *************************************************************************************
+ **
+ **  SYSTEM DEFINES  - DO NOT MODIFY
+ **
+ *************************************************************************************
+ *************************************************************************************/
+
+/* Sizes */
+#define OWNER_GUARD_FILE_BYTES              3
+#define OWNER_GUARD_DMEM_BYTES              4
+#define OWNER_USER_ID_BYTES             5
+#define SLOT_USE_DATA_BYTES             1
+#define SLOT_SERIAL_NUMBER_BYTES        2
+#define USE_LIMITS                      8
+#define TRANSACTION_ID_BYTES            46
+#define MODEL_ID_BYTES                  2   /* Model id only uses 12 of the bits. */
+#define KEY_SIZE_BYTES                  16
+#define KEY_SIZE_BITS                   128
+#define DRM_BASE_KEY_ID_LENGTH          44
+#define DRM_RESERVED                    2
+#define DRM_OTHER_RESERVED              12
+#define DRM_RENTAL_RESERVED_BYTES       3
+#define CGMSA_BITS                      2
+#define ACPTB_BITS                      2
+#define DIGITAL_PROTECTION_BITS         1
+#define ICT_BITS                        1
+#define OUTPUT_SIGNAL_RESERVED_BITS     2
+#define SHA256_SIZE_BYTES               32
+#define RSA_SIZE_PLAIN_BYTES            255
+#define MAX_MESSAGE_SIZE_BYTES          12
+#define VIDEO_KEY_COUNT                 128
+#define VIDEO_KEY_COUNT_SIGNED          111
+#define SET_RANDOM_SAMPLE_SEED_MIN      4
+
+
+/* DRM Modes */
+#define DRM_TYPE_BASE                   0xF0F0
+#define DRM_TYPE_ACTIVATION_PURCHASE    0xC3C3
+#define DRM_TYPE_ACTIVATION_RENTAL      0x3C3C
+#define DRM_TYPE_PURCHASE               0x5555
+#define DRM_TYPE_RENTAL                 0xAAAA
+#define DRM_TYPE_PROTECTED_AUDIO        0x9797
+
+/* Use Limits.*/
+#define USE_LIMIT_ID_UNLIMITED          0x0707
+#define USE_LIMIT_ID_ONE                0x1001
+#define USE_LIMIT_ID_THREE              0x3003
+#define USE_LIMIT_ID_FIVE               0x5005
+#define USE_LIMIT_ID_SEVEN              0x7007
+#define USE_LIMIT_ID_TEN                0xAAAA
+#define USE_LIMIT_ID_TWENTY             0x5555
+#define USE_LIMIT_ID_THIRTY             0xF0F0
+
+/* Option masks. */
+#define OUTPUT_PROTECTION_MASK          0x01
+#define SIGNED_ACTIVATION_MASK          0x02
+#define PROTECTED_AUDIO_MASK            0x04
+#define VARIABLE_FRAME_KEY_COUNT_MASK   0x08
+
+#define SIZEOF_BASE_KEY_SIZE_BYTES          32
+#define SIZEOF_BASE_KEY_SIZE_BITS           256
+#define SIZEOF_BASE_KEY_ID_SIZE_BYTES       44
+#define SIZEOF_MESSAGE_KEY_SIZE_BYTES       20
+#define SIZEOF_TARGET_HEADER_BYTES          64
+#define SIZEOF_TRANSACTION_HEADER_BYTES     64
+#define SIZEOF_ACTIVATION_MSG_BASE64        352
+#define SIZEOF_ACTIVATION_HEADER            24
+#define ACTIVATION_HEADER_CRYTO_BYTES       16
+#define SIZEOF_DIGEST                       52
+#define SIZEOF_PUBLIC_KEY_E_BYTES           2
+#define SIZEOF_PUBLIC_KEY_N_BYTES           256
+#define SIZEOF_PUBLIC_KEY_N_HEX             1024
+
+#define DRM_ACTIVATION_MESSAGE_VERSION      (1)
+#define DRM_ACTIVATION_MESSAGE_FLAG         (0x01)
+#define DRM_DEACTIVATION_MESSAGE_FLAG       (0x02)
+
+#define TOTAL_PLAY_SLOTS                    (8)
+#define OFFSET_TO_USERID_DRMMEM_48BYTE         (20)
+#define OFFSET_TO_USERID_DRMMEM_80BYTE         (30)
+
+#if DRM_OTHER_SECURE_PLATFORM == 1
+#define PACKED_ALLOCATION_BYTES             (48)
+#else
+#define PACKED_ALLOCATION_BYTES             (80)
+#endif
+
+#define VIDEO_KEY_SIZE_BYTES                16
+#define VIDEO_KEY_COUNT_MAX                 128
+
+/* Sizes. */
+#define DRM_CONTEXT_SIZE_BYTES          3032
+#define DRM_REGISTRATION_CODE_BYTES     11
+#define DRM_STRD_SIZE_BYTES             2224
+#define DRM_FRAME_DRM_INFO_SIZE               10
+#define DRM_ACTIVATION_MSG_PAYLOAD_BYTES      (256)
+#define DRM_DIGEST_RESERVED_BYTES               4
+#define DRM_SIGNATURE_RESERVED_BYTES    12
+
+#define DRM_RSA_KEY_SIZE_BYTES          256 // If you change this size, you need to change the number of frame keys in VideoDecryptTypes
+
+#define DRM_SIGNATURE_CRYPTO_BLOCKS     1
+#define DRM_SIGNATURE_SUB_CRYPTO_BYTES  8
+#define DRM_HEADER_BYTES                1952
+#define DRM_SIGNATURE_BYTES             272
+
+#define DRM_DIVX_PROFILE_QMOBILE          0
+#define DRM_DIVX_PROFILE_MOBILE           1
+#define DRM_DIVX_PROFILE_HOMETHEATER      2
+#define DRM_DIVX_PROFILE_HIGHDEF          3
+
+#define DRM_DEVICE_IS_ACTIVATED           101
+#define DRM_DEVICE_NOT_ACTIVATED          100
+
+#define DRM_ERROR_NO_SIGNATURE              29  // from: drmInitCommitPlayback
+
+#define DRM_ERROR_GUARD_MISMATCH            30  // from: drmInitCommitPlayback
+
+#define DRM_ERROR_MODEL_MISMATCH            31  // from: drmInitCommitPlayback
+
+typedef struct drmUseLimitIdInfo
+{
+    uint16_t id;
+    uint8_t uses;
+} drmUseLimitIdInfo_t;
+
+typedef struct drmVideoDDChunk
+{
+    uint16_t keyIndex;
+    uint32_t offset;
+    uint32_t size;
+} drmVideoDDChunk_t;
+
+typedef struct drmFrameKeys
+{
+    uint8_t frameKeys[128][16];
+} drmFrameKeys_t;
+
+typedef struct drmActivateRecord
+{
+    uint8_t memoryGuard[OWNER_GUARD_FILE_BYTES];
+    uint8_t modelId[MODEL_ID_BYTES];
+    uint8_t userKey[KEY_SIZE_BYTES];
+    uint8_t explicitGuard[OWNER_GUARD_FILE_BYTES];
+} drmActivateRecord_t;
+
+typedef struct drmGuardExtention
+
+{
+
+     uint8_t memoryGuardExt;
+
+     uint8_t explicitGuardExt;
+
+}drmGuardExt_t;
+
+typedef struct drmRentalRecord
+{
+    uint16_t useLimitId;
+    uint8_t serialNumber[SLOT_SERIAL_NUMBER_BYTES];
+    uint8_t slotNumber;
+    uint8_t reserved[DRM_RENTAL_RESERVED_BYTES];
+} drmRentalRecord_t;
+
+typedef struct drmTargetHeader_t
+{
+    uint16_t drmMode;
+    uint8_t userId[OWNER_USER_ID_BYTES];
+    uint8_t optionFlags;
+    drmRentalRecord_t rentalRecord;
+    uint8_t sessionKey[KEY_SIZE_BYTES];
+    drmActivateRecord_t activateRecord;
+    uint8_t outputProtectionFlags;
+    uint8_t protectedAudioOffset;
+    uint8_t protectedAudioCryptoSize;
+    uint8_t frameKeyCount;
+    uint16_t drmSubMode;
+    drmGuardExt_t guardExt;    
+} drmTargetHeader_t;
+
+typedef struct drmTransactionInfoHeaderStruct_t
+{
+    uint8_t transactionId[TRANSACTION_ID_BYTES];
+    uint16_t transactionAuthorityId;
+    uint32_t contentId;
+    uint8_t reserved[DRM_OTHER_RESERVED];
+} drmTransactionInfoHeader_t;
+
+typedef struct DrmHeaderSignatureStruct
+
+{
+
+    uint32_t signerId;
+
+    uint8_t reserved[DRM_SIGNATURE_RESERVED_BYTES];
+
+    uint8_t signedData[DRM_RSA_KEY_SIZE_BYTES];
+
+} drmHeaderSignature_t;
+
+
+typedef struct drmHeader
+{
+    uint32_t reservedFlags;
+    uint8_t baseKeyId[DRM_BASE_KEY_ID_LENGTH];
+    drmTargetHeader_t targetHeader;
+    drmTransactionInfoHeader_t transaction;
+    uint8_t frameKeys[VIDEO_KEY_COUNT_SIGNED][VIDEO_KEY_SIZE_BYTES];
+} drmHeader_t;
+
+typedef struct DrmDigestStruct
+
+{
+
+    uint8_t hash[SHA256_SIZE_BYTES];
+
+    uint8_t key[KEY_SIZE_BYTES];
+
+    uint8_t reserved[DRM_DIGEST_RESERVED_BYTES];
+
+} drmDigest_t;
+
+typedef struct drmOwnerSlot
+{
+      uint8_t guard[OWNER_GUARD_DMEM_BYTES];
+#if DRM_OTHER_SECURE_PLATFORM == 0
+      uint8_t randomPad1;
+#endif
+      uint8_t key[KEY_SIZE_BYTES];
+#if DRM_OTHER_SECURE_PLATFORM == 0
+      uint8_t randomPad2;
+#endif
+      uint8_t userId[OWNER_USER_ID_BYTES];
+#if DRM_OTHER_SECURE_PLATFORM == 0    
+      uint8_t randomPad3;
+#endif
+} drmOwnerSlot_t;
+
+typedef struct drmPlaySlot
+{
+      uint8_t serialNumber[SLOT_SERIAL_NUMBER_BYTES];
+      uint8_t counter;
+#if DRM_OTHER_SECURE_PLATFORM == 0
+      uint8_t randomPad;
+#endif
+} drmPlaySlot_t;
+
+typedef struct drmMemory
+{
+#if DRM_OTHER_SECURE_PLATFORM == 0
+      uint8_t prefixPad[4];
+      uint8_t randomPad1[4];
+#endif
+      drmOwnerSlot_t owner;
+      drmPlaySlot_t slots[TOTAL_PLAY_SLOTS];
+#if DRM_OTHER_SECURE_PLATFORM == 0
+      uint32_t activationFailureCnt;
+      uint8_t randomPad2[4];
+      uint8_t postfixPad[4];
+#endif
+} drmMemory_t;
+
+typedef struct drmPackedMemory
+{
+      uint8_t packed[PACKED_ALLOCATION_BYTES];
+} drmPackedMemory_t;
+
+typedef struct drmMessagePacked
+{
+      uint8_t message[MAX_MESSAGE_SIZE_BYTES];
+      uint8_t sizeInBits;
+} drmMessagePacked_t;
+
+typedef struct drmRegistrationRequest
+{
+      uint8_t userIdGuard[OWNER_GUARD_DMEM_BYTES];
+      uint8_t modelId[MODEL_ID_BYTES];
+      uint8_t flag;//only 2 bits are used here 
+} drmRegistrationRequest_t;
+
+/*NOTE: too many magic numbers, fixme*/
+typedef struct drmActivationMessageStruct
+{
+      uint8_t         a1Padding[60];
+      uint8_t         flags[4];
+      uint8_t         reserved[32];
+      int8_t          registrationCode[8];
+      uint8_t         guardHash[32];
+} drmActivationMessage_t;
+
+typedef struct drmActivationProtectedMessageStruct
+{
+      uint32_t       version;
+      uint32_t       reserved;
+      uint8_t        protectedPayload[256];
+} drmActivationProtectedMessage_t;
+
+typedef struct {
+      unsigned   drm_offset;                              /* offset of encrypted video data */
+      unsigned   drm_size;                                /* size of encrypted video data */
+      unsigned   drm_check_value;                         /* check return value */
+      unsigned   drm_rental_value;                      /* still can play count */
+      drmHeader_t *drm_header;                              /* const key informations */
+      char      drm_reg_code[11];                 /* registrationCodeString*/
+      
+} drm_t;
+
+typedef enum drmErrorCodes 
+{
+      DRM_SUCCESS = 0,
+      DRM_NOT_AUTHORIZED,
+      DRM_NOT_REGISTERED,
+      DRM_RENTAL_EXPIRED,
+      DRM_GENERAL_ERROR,
+} drmErrorCodes_t;
+
+void drm_set_info(drm_t*);
+static drm_t*  drm_get_info(){return NULL;};
+
+#endif
+
diff --git a/amffmpeg/libavformat/file_list.c b/amffmpeg/libavformat/file_list.c
new file mode 100755
index 0000000..d5bd3a0
--- /dev/null
+++ b/amffmpeg/libavformat/file_list.c
@@ -0,0 +1,429 @@
+/*
+ * filelist io for ffmpeg system
+ * Copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/avstring.h"
+#include "avformat.h"
+#include <fcntl.h>
+#if HAVE_SETMODE
+#include <io.h>
+#endif
+#include <unistd.h>
+#include <sys/time.h>
+#include <stdlib.h>
+#include "os_support.h"
+#include "file_list.h"
+static struct list_demux *list_demux_list=NULL;
+#define unused(x)	(x=x)
+
+int register_list_demux(struct list_demux *demux)
+{
+	list_demux_t **list=&list_demux_list;
+    while (*list != NULL) list = &(*list)->next;
+    *list = demux;
+    demux->next = NULL;
+	return 0;
+}
+
+struct list_demux * probe_demux(ByteIOContext  *s,const char *filename)
+{
+	int ret;
+	int max=0;
+	list_demux_t *demux;
+	list_demux_t *best_demux=NULL;
+	demux=list_demux_list;
+	while(demux)
+	{
+		ret=demux->probe(s,filename);
+		if(ret>max)
+		{
+			max=ret;
+			best_demux=demux;
+			if(ret>=100)
+			{
+				return best_demux;
+			}
+		}
+		demux=demux->next;
+	}
+	return best_demux;
+}
+
+int list_add_item(struct list_mgt *mgt,struct list_item*item)
+{
+	struct list_item**list;
+	struct list_item*prev;
+	list=&mgt->item_list;
+	prev=NULL;
+	 while (*list != NULL) 
+	 {
+	 	prev=*list;
+	 	list = &(*list)->next;
+	 }
+	*list = item;
+	item->prev=prev;
+    item->next = NULL;
+	mgt->item_num++;
+	return 0;
+}
+static int list_del_item(struct list_mgt *mgt,struct list_item*item)
+{
+	struct list_item*tmp;
+	if(!item || !mgt)
+		return -1;
+	if(mgt->item_list==item){
+		mgt->item_list=item->next;
+		if(mgt->item_list)
+			mgt->item_list->prev=NULL;
+	}
+	else {
+		tmp=item->prev;
+		tmp->next=item->next;
+		if(item->next) 
+			item->next->prev=tmp;
+	}
+	mgt->item_num--;
+	av_free(item);
+	return 0;		
+}
+
+/*=======================================================================================*/
+int url_is_file_list(ByteIOContext *s,const char *filename)
+{
+	int ret;
+	list_demux_t *demux;
+	ByteIOContext *lio=s;
+	int64_t	   *oldpos=0;
+	if(!lio)
+	{
+		ret=url_fopen(&lio,filename,AVIO_FLAG_READ);
+		if(ret!=0)
+		{ 
+		return AVERROR(EIO); 
+		}
+	}
+	else{
+		oldpos=url_ftell(lio);
+	}
+	demux=probe_demux(lio,filename);
+	if(lio!=s)
+	{
+		url_fclose(lio);
+	}
+	else
+	{
+		url_fseek(lio, oldpos, SEEK_SET);
+	}
+	return demux!=NULL?1:0;
+}
+
+static int list_open_internet(ByteIOContext **pbio,struct list_mgt *mgt,const char *filename, int flags)
+{
+	list_demux_t *demux;
+	int ret;
+	ByteIOContext *bio;
+	ret=url_fopen(&bio,filename,flags);
+	if(ret!=0)
+		{
+			return AVERROR(EIO); 
+		}
+	mgt->location=bio->reallocation;
+	demux=probe_demux(bio,filename);
+	if(!demux)
+	{
+		ret=-1;
+		goto error;
+	}
+	ret=demux->parser(mgt,bio);
+	if(ret<=0)
+	{
+		ret=-1;
+		goto error;
+	}
+	*pbio=bio;
+	return 0;
+error:
+	if(bio)
+		url_fclose(bio);
+	return ret;
+}
+
+static int list_open(URLContext *h, const char *filename, int flags)
+{
+	struct list_mgt *mgt;
+	int ret;
+	ByteIOContext *bio;
+	mgt=av_malloc(sizeof(struct list_mgt));
+	if(!mgt)
+		return AVERROR(ENOMEM);
+	memset(mgt,0,sizeof(*mgt));
+	mgt->filename=filename+5;
+	mgt->flags=flags;
+	if((ret=list_open_internet(&bio,mgt,mgt->filename,flags| URL_MINI_BUFFER | URL_NO_LP_BUFFER))!=0)
+	{
+		av_free(mgt);
+		return ret;
+	}
+	lp_lock_init(&mgt->mutex,NULL);
+	mgt->current_item=mgt->item_list;
+	mgt->cur_uio=NULL;
+ 	h->is_streamed=1;
+	h->is_slowmedia=1;
+	if(mgt->full_time>0 && mgt->have_list_end)
+		h->support_time_seek=1;
+	h->priv_data = mgt;
+	
+	url_fclose(bio);
+	return 0;
+}
+
+static struct list_item * switchto_next_item(struct list_mgt *mgt)
+{
+	struct list_item *next=NULL;
+	struct list_item *current;
+	if(!mgt)
+		return NULL;
+	if(mgt->current_item==NULL || mgt->current_item->next==NULL){
+			/*new refresh this mgtlist now*/
+			ByteIOContext *bio;
+			
+			int ret;
+			if((ret=list_open_internet(&bio,mgt,mgt->filename,mgt->flags| URL_MINI_BUFFER | URL_NO_LP_BUFFER))!=0)
+			{
+				goto switchnext;
+			}
+			url_fclose(bio);
+			if(mgt->current_item && mgt->current_item->file){/*current item,switch to next*/
+				current=mgt->current_item;
+				next=mgt->current_item->next;
+				for(;next!=NULL;next=next->next){
+					if(next->file && strcmp(current->file,next->file)==0){
+						/*found the same item,switch to the next*/	
+						current=next;
+						break;
+					}
+				}
+				while(current!=mgt->item_list){
+					/*del the old item,lest current,and then play current->next*/
+					list_del_item(mgt,mgt->item_list);
+				}
+				mgt->current_item=current;/*switch to new current;*/
+			}
+	}
+switchnext:
+	if(mgt->current_item)
+		next=mgt->current_item->next;
+	else
+		next=mgt->item_list;
+	if(next)
+		av_log(NULL, AV_LOG_INFO, "switch to new file=%s,total=%d,start=%d,duration=%d\n",
+			next->file,mgt->item_num,next->start_time,next->duration);
+	else
+		av_log(NULL, AV_LOG_INFO, "switch to new file=NULL,total=%d\n",mgt->item_num);
+	return next;
+}
+
+static int list_read(URLContext *h, unsigned char *buf, int size)
+{   
+	struct list_mgt *mgt = h->priv_data;
+    int len=AVERROR(EIO);
+	struct list_item *item=mgt->current_item;
+	
+retry:	
+	if (url_interrupt_cb())       
+            return AVERROR(EINTR); 
+	//av_log(NULL, AV_LOG_INFO, "list_read start buf=%x,size=%d\n",buf,size);
+	if(!mgt->cur_uio )
+	{
+		if(item && item->file)
+		{
+			ByteIOContext *bio;
+			av_log(NULL, AV_LOG_INFO, "list_read switch to new file=%s\n",item->file);
+			len=url_fopen(&bio,item->file,AVIO_FLAG_READ | URL_MINI_BUFFER | URL_NO_LP_BUFFER);
+			if(len!=0)
+			{
+				av_log(NULL, AV_LOG_INFO, "list url_fopen failed =%d\n",len);
+				return len;
+			}
+			if(url_is_file_list(bio,item->file))
+			{
+				/*have 32 bytes space at the end..*/
+				memmove(item->file+5,item->file,strlen(item->file)+1);
+				memcpy(item->file,"list:",5);
+				url_fclose(bio);
+				len=url_fopen(&bio,item->file,mgt->flags | URL_MINI_BUFFER | URL_NO_LP_BUFFER);
+				if(len!=0)
+				{
+					av_log(NULL, AV_LOG_INFO, "file list url_fopen failed =%d\n",len);
+					return len;
+				}
+			}
+			mgt->cur_uio=bio;
+		}
+	}
+	if(mgt->cur_uio){
+		len=get_buffer(mgt->cur_uio,buf,size);
+		//av_log(NULL, AV_LOG_INFO, "list_read get_buffer=%d\n",len);
+	}
+	if(len==AVERROR(EAGAIN))
+		 return AVERROR(EAGAIN);/*not end,bug need to*/
+	else if((len<=0)&& mgt->current_item!=NULL)
+	{/*end of the file*/
+		av_log(NULL, AV_LOG_INFO, "try switchto_next_item buf=%x,size=%d,len=%d\n",buf,size,len);
+
+		if(item && (item->flags & ENDLIST_FLAG))
+			return 0;
+		item=switchto_next_item(mgt);
+		if(!item){
+			 return AVERROR(EAGAIN);/*not end,but need to refresh the list later*/
+		}
+		if(mgt->cur_uio)
+			url_fclose(mgt->cur_uio);
+		mgt->cur_uio=NULL;
+		mgt->current_item=item;
+		if(item->flags & ENDLIST_FLAG){
+			av_log(NULL, AV_LOG_INFO, "reach list end now!,item=%x\n",item);
+			return 0;/*endof file*/
+		}
+		else if(item->flags & DISCONTINUE_FLAG){
+			av_log(NULL, AV_LOG_INFO, "Discontiue item \n");
+			//1 TODO:need to notify uper level stream is changed
+			goto retry;
+		}
+		else{	
+			goto retry;
+		}
+	}
+	av_log(NULL, AV_LOG_INFO, "list_read end buf=%x,size=%d\n",buf,size);
+    return len;
+}
+
+static int list_write(URLContext *h, unsigned char *buf, int size)
+{    
+	unused(h);
+	unused(buf);
+	unused(size);
+	return -1;
+}
+/* XXX: use llseek */
+static int64_t list_seek(URLContext *h, int64_t pos, int whence)
+{
+	struct list_mgt *mgt = h->priv_data;
+	struct list_item *item,*item1;
+	if (whence == AVSEEK_BUFFERED_TIME)
+	{
+		int64_t buffed_time=0;
+		if(mgt->current_item && mgt->current_item->duration>0){
+			//av_log(NULL, AV_LOG_INFO, "list_seek uui=%ld,size=%lld\n",mgt->cur_uio,url_fsize(mgt->cur_uio));
+			if(mgt->cur_uio && url_fsize(mgt->cur_uio)>0){
+				//av_log(NULL, AV_LOG_INFO, "list_seek start_time=%ld,pos=%lld\n",mgt->current_item->start_time,url_buffed_pos(mgt->cur_uio));
+				buffed_time=mgt->current_item->start_time+url_buffed_pos(mgt->cur_uio)*mgt->current_item->duration/url_fsize(mgt->cur_uio);
+			}
+			else{
+				buffed_time=mgt->current_item->start_time;
+				if(mgt->current_item && (mgt->current_item->flags & ENDLIST_FLAG) && mgt->current_item->prev!=NULL)
+					buffed_time=mgt->current_item->prev->start_time+mgt->current_item->prev->duration;/*read to end list*/
+				}
+		}
+		//av_log(NULL, AV_LOG_INFO, "list current buffed_time=%lld\n",buffed_time);
+		return buffed_time;
+	}
+	
+	av_log(NULL, AV_LOG_INFO, "list_seek pos=%lld,whence=%x\n",pos,whence);
+	if (whence == AVSEEK_SIZE)
+        return mgt->file_size;
+	if (whence == AVSEEK_FULLTIME)
+	{
+		if(mgt->have_list_end)
+			return mgt->full_time;
+		else
+			return -1;
+	}
+	
+	if(whence == AVSEEK_TO_TIME && pos>=0 && pos<mgt->full_time)
+	{
+		av_log(NULL, AV_LOG_INFO, "list_seek to Time =%lld,whence=%x\n",pos,whence);
+		for(item=mgt->item_list;item;item=item->next)
+		{
+			if(item->start_time<=pos && pos <item->start_time+item->duration)
+			{	
+				if(mgt->cur_uio)
+					url_fclose(mgt->cur_uio);
+				mgt->cur_uio=NULL;
+				mgt->current_item=item;
+				av_log(NULL, AV_LOG_INFO, "list_seek to item->file =%s\n",item->file);
+				return item->start_time;/*pos=0;*/
+			}
+		}
+	}
+	av_log(NULL, AV_LOG_INFO, "list_seek failed\n");
+	return -1;
+}
+static int list_close(URLContext *h)
+{
+	struct list_mgt *mgt = h->priv_data;
+	struct list_item *item,*item1;
+	if(!mgt)return 0;
+	item=mgt->item_list;
+	if(mgt->cur_uio!=NULL)
+		url_fclose(mgt->cur_uio);
+	while(item!=NULL)
+		{
+		item1=item;
+		item=item->next;
+		av_free(item1);
+	
+		}
+	av_free(mgt);
+	unused(h);
+	return 0;
+}
+static int list_get_handle(URLContext *h)	
+{    
+return (intptr_t) h->priv_data;
+}
+
+URLProtocol file_list_protocol = {
+    "list",
+    list_open,
+    list_read,
+    list_write,
+    list_seek,
+    list_close,
+    .url_exseek=list_seek,/*same as seek is ok*/ 
+    .url_get_file_handle = list_get_handle,
+};
+
+URLProtocol *get_file_list_protocol(void)
+{
+	return &file_list_protocol;
+}
+int register_list_demux_all(void)
+{
+	static int registered_all=0;
+	if(registered_all)	
+		return;
+	registered_all++;
+	extern struct list_demux m3u_demux;
+	av_register_protocol(&file_list_protocol); 
+	register_list_demux(&m3u_demux); 
+	return 0;
+}
+
diff --git a/amffmpeg/libavformat/file_list.h b/amffmpeg/libavformat/file_list.h
new file mode 100755
index 0000000..367adbb
--- /dev/null
+++ b/amffmpeg/libavformat/file_list.h
@@ -0,0 +1,91 @@
+/*
+ * File list 
+ * Copyright (C) 2009 Justin Ruggles
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_FILE_LIST_H
+#define AVFORMAT_FILE_LIST_H
+
+#include <libavformat/avio.h>
+
+#include <pthread.h>
+
+#define lock_t			pthread_mutex_t
+#define lp_lock_init(x,v) 	pthread_mutex_init(x,v)
+#define lp_lock(x)		pthread_mutex_lock(x)
+#define lp_unlock(x)   	pthread_mutex_unlock(x)
+
+
+
+#define DISCONTINUE_FLAG			(1<<0)
+#define DURATION_FLAG				(1<<1)
+#define SEEK_SUPPORT_FLAG			(1<<2)
+#define ENDLIST_FLAG				(1<<3)
+#define KEY_FLAG					(1<<4)
+#define EXT_INFO					(1<<5)
+#define READ_END_FLAG				(1<<6)
+#define ALLOW_CACHE_FLAG			(1<<7)
+
+
+struct list_mgt;
+struct list_demux;
+
+typedef struct list_item
+{
+	const char *file;
+	int 	   flags;	  
+	int 		start_time;
+	int 		duration;
+	struct list_item * prev;
+	struct list_item * next;
+}list_item_t;
+
+typedef struct list_mgt
+{
+	char *filename;
+	char *location;
+	int flags;
+	lock_t mutex;
+	struct list_item *item_list;
+	int item_num;
+	struct list_item *current_item;
+	int64_t file_size;
+	int 	full_time;
+	int 	have_list_end;
+	ByteIOContext	*cur_uio;
+	struct list_demux *demux;
+}list_mgt_t;
+
+typedef struct list_demux
+{
+	const char * name;
+	int (*probe)(ByteIOContext *s,const char *file);
+	int (*parser)(struct list_mgt *mgt,ByteIOContext *s);
+	struct list_demux *next;
+}list_demux_t;
+URLProtocol *get_file_list_protocol(void);
+int register_list_demux_all(void);
+int register_list_demux(struct list_demux *demux);
+struct list_demux * probe_demux(ByteIOContext  *s,const char *filename);
+int list_add_item(struct list_mgt *mgt,struct list_item*item);
+int url_is_file_list(ByteIOContext *s,const char *filename);
+
+
+#endif /* AVFORMAT_FILE_LIST_H */
+
diff --git a/amffmpeg/libavformat/flvdec.c b/amffmpeg/libavformat/flvdec.c
old mode 100644
new mode 100755
index 4fb562f..5bd70dc
--- a/amffmpeg/libavformat/flvdec.c
+++ b/amffmpeg/libavformat/flvdec.c
@@ -269,6 +269,8 @@ static int amf_parse_object(AVFormatContext *s, AVStream *astream, AVStream *vst
                 vcodec->bit_rate = num_val * 1024.0;
             else if(!strcmp(key, "audiodatarate") && acodec && 0 <= (int)(num_val * 1024.0))
                 acodec->bit_rate = num_val * 1024.0;
+            else if(!strcmp(key, "framerate")) 
+                vstream->special_fps = (float)num_val;
         } else if (amf_type == AMF_DATA_TYPE_STRING)
             av_dict_set(&s->metadata, key, str_val, 0);
     }
diff --git a/amffmpeg/libavformat/http.c b/amffmpeg/libavformat/http.c
old mode 100644
new mode 100755
index 95ba456..7445e3f
--- a/amffmpeg/libavformat/http.c
+++ b/amffmpeg/libavformat/http.c
@@ -34,6 +34,9 @@
 /* XXX: POST protocol is not completely implemented because ffmpeg uses
    only a subset of it. */
 
+
+#define IPAD_IDENT	"AppleCoreMedia/1.0.0.8C148 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh_cn)"
+
 /* used for protocol handling */
 #define BUFFER_SIZE 1024
 #define MAX_REDIRECTS 8
@@ -50,6 +53,7 @@ typedef struct {
     HTTPAuthState auth_state;
     unsigned char headers[BUFFER_SIZE];
     int willclose;          /**< Set if the server correctly handles Connection: close and will close the connection after feeding us the content. */
+	int is_seek;
 } HTTPContext;
 
 #define OFFSET(x) offsetof(HTTPContext, x)
@@ -63,6 +67,13 @@ static const AVClass httpcontext_class = {
     .option         = options,
     .version        = LIBAVUTIL_VERSION_INT,
 };
+static const AVClass shttpcontext_class = {
+    .class_name     = "SHTTP",
+    .item_name      = av_default_item_name,
+    .option         = options,
+    .version        = LIBAVUTIL_VERSION_INT,
+};
+
 
 static int http_connect(URLContext *h, const char *path, const char *hoststr,
                         const char *auth, int *new_location);
@@ -128,8 +139,10 @@ static int http_open_cnx(URLContext *h)
 
     ff_url_join(buf, sizeof(buf), "tcp", NULL, hostname, port, NULL);
     err = ffurl_open(&hd, buf, AVIO_FLAG_READ_WRITE);
-    if (err < 0)
+    if (err < 0){
+		av_log(h, AV_LOG_INFO, "http_open_cnx:ffurl_open failed ,%d\n",err);
         goto fail;
+    }	
 
     s->hd = hd;
     cur_auth_type = s->auth_state.auth_type;
@@ -146,9 +159,12 @@ static int http_open_cnx(URLContext *h)
         && location_changed == 1) {
         /* url moved, get next */
         ffurl_close(hd);
-        if (redirects++ >= MAX_REDIRECTS)
+        if (redirects++ >= MAX_REDIRECTS){
+			av_log(h, AV_LOG_ERROR, "HTTP open reach MAX_REDIRECTS\n");
             return AVERROR(EIO);
+        }
         location_changed = 0;
+		h->location=s->location;
         goto redo;
     }
     return 0;
@@ -156,6 +172,7 @@ static int http_open_cnx(URLContext *h)
     if (hd)
         ffurl_close(hd);
     s->hd = NULL;
+	av_log(h, AV_LOG_ERROR, "HTTP open Failed\n");
     return AVERROR(EIO);
 }
 
@@ -164,18 +181,36 @@ static int http_open(URLContext *h, const char *uri, int flags)
     HTTPContext *s = h->priv_data;
 
     h->is_streamed = 1;
-
+	
     s->filesize = -1;
+	s->is_seek=0;
     av_strlcpy(s->location, uri, sizeof(s->location));
 
     return http_open_cnx(h);
 }
+static int shttp_open(URLContext *h, const char *uri, int flags)
+{
+    HTTPContext *s = h->priv_data;
+	int ret;
+    h->is_streamed = 1;
+
+    s->filesize = -1;
+	s->is_seek=0;
+    av_strlcpy(s->location, uri+1, sizeof(s->location));
+
+    ret= http_open_cnx(h);
+	h->is_slowmedia=1;
+	return ret;
+}
+
+
 static int http_getc(HTTPContext *s)
 {
     int len;
     if (s->buf_ptr >= s->buf_end) {
         len = ffurl_read(s->hd, s->buffer, BUFFER_SIZE);
         if (len < 0) {
+			av_log(NULL, AV_LOG_ERROR, "http_getc failed\n");
             return AVERROR(EIO);
         } else if (len == 0) {
             return -1;
@@ -306,11 +341,19 @@ static int http_connect(URLContext *h, const char *path, const char *hoststr,
     /* set default headers if needed */
     if (!has_header(s->headers, "\r\nUser-Agent: "))
        len += av_strlcatf(headers + len, sizeof(headers) - len,
-                          "User-Agent: %s\r\n", LIBAVFORMAT_IDENT);
+                          "User-Agent: %s\r\n", IPAD_IDENT);
+
+	if (h->headers) {
+		len += av_strlcatf(headers + len, sizeof(headers) - len,
+                           "%s\r\n", h->headers);
+
+    }
+
+	
     if (!has_header(s->headers, "\r\nAccept: "))
         len += av_strlcpy(headers + len, "Accept: */*\r\n",
                           sizeof(headers) - len);
-    if (!has_header(s->headers, "\r\nRange: "))
+    if (!has_header(s->headers, "\r\nRange: ") && (s->off>0 || s->is_seek))
         len += av_strlcatf(headers + len, sizeof(headers) - len,
                            "Range: bytes=%"PRId64"-\r\n", s->off);
     if (!has_header(s->headers, "\r\nConnection: "))
@@ -336,8 +379,10 @@ static int http_connect(URLContext *h, const char *path, const char *hoststr,
              authstr ? authstr : "");
 
     av_freep(&authstr);
-    if (ffurl_write(s->hd, s->buffer, strlen(s->buffer)) < 0)
+    if ((err=ffurl_write(s->hd, s->buffer, strlen(s->buffer)) )< 0){
+		av_log(h, AV_LOG_INFO, "process_line:ffurl_write failed,%d\n",err);
         return AVERROR(EIO);
+    }	
 
     /* init input buffer */
     s->buf_ptr = s->buffer;
@@ -361,8 +406,8 @@ static int http_connect(URLContext *h, const char *path, const char *hoststr,
             return AVERROR(EIO);
 
         av_dlog(NULL, "header='%s'\n", line);
-
         err = process_line(h, line, s->line_count, new_location);
+		av_log(h, AV_LOG_INFO, "process_line:%s(ret=%d)\n",line,err );
         if (err < 0)
             return err;
         if (err == 0)
@@ -378,23 +423,26 @@ static int http_read(URLContext *h, uint8_t *buf, int size)
 {
     HTTPContext *s = h->priv_data;
     int len;
-
     if (s->chunksize >= 0) {
         if (!s->chunksize) {
             char line[32];
 
             for(;;) {
                 do {
-                    if (http_get_line(s, line, sizeof(line)) < 0)
+                    if (http_get_line(s, line, sizeof(line)) < 0){
+						av_log(h, AV_LOG_ERROR, "http_read failed\n");
                         return AVERROR(EIO);
+                    }	
                 } while (!*line);    /* skip CR LF from last chunk */
 
                 s->chunksize = strtoll(line, NULL, 16);
 
                 av_dlog(NULL, "Chunked encoding data size: %"PRId64"'\n", s->chunksize);
 
-                if (!s->chunksize)
+                if (!s->chunksize){
+					av_log(h, AV_LOG_ERROR, "http_read s->chunksize failed\n");
                     return 0;
+                }	
                 break;
             }
         }
@@ -408,15 +456,19 @@ static int http_read(URLContext *h, uint8_t *buf, int size)
         memcpy(buf, s->buf_ptr, len);
         s->buf_ptr += len;
     } else {
-        if (!s->willclose && s->filesize >= 0 && s->off >= s->filesize)
+        if (!s->willclose && s->filesize >= 0 && s->off >= s->filesize){
+			av_log(h, AV_LOG_ERROR, "http_read error %d\n",AVERROR_EOF);
             return AVERROR_EOF;
+        }
         len = ffurl_read(s->hd, buf, size);
+		//av_log(h, AV_LOG_ERROR, "ffurl_read %d\n",len);
     }
     if (len > 0) {
         s->off += len;
         if (s->chunksize > 0)
             s->chunksize -= len;
     }
+	//av_log(h, AV_LOG_ERROR, "http_read %d\n",len);
     return len;
 }
 
@@ -486,7 +538,7 @@ static int64_t http_seek(URLContext *h, int64_t off, int whence)
     else if (whence == SEEK_END)
         off += s->filesize;
     s->off = off;
-
+	s->is_seek=1;
     /* if it fails, continue on old connection */
     if (http_open_cnx(h) < 0) {
         memcpy(s->buffer, old_buf, old_buf_size);
@@ -496,6 +548,7 @@ static int64_t http_seek(URLContext *h, int64_t off, int whence)
         s->off = old_off;
         return -1;
     }
+	s->is_seek=0;
     ffurl_close(old_hd);
     return off;
 }
@@ -518,3 +571,15 @@ URLProtocol ff_http_protocol = {
     .priv_data_size      = sizeof(HTTPContext),
     .priv_data_class     = &httpcontext_class,
 };
+URLProtocol ff_shttp_protocol = {
+    .name                = "shttp",
+    .url_open            = shttp_open,
+    .url_read            = http_read,
+    .url_write           = http_write,
+    .url_seek            = http_seek,
+    .url_close           = http_close,
+    .url_get_file_handle = http_get_file_handle,
+    .priv_data_size      = sizeof(HTTPContext),
+    .priv_data_class     = &shttpcontext_class,
+};
+
diff --git a/amffmpeg/libavformat/internal.h b/amffmpeg/libavformat/internal.h
index e0d04db..1ea44a2 100644
--- a/amffmpeg/libavformat/internal.h
+++ b/amffmpeg/libavformat/internal.h
@@ -76,7 +76,6 @@ void ff_interleave_add_packet(AVFormatContext *s, AVPacket *pkt,
                               int (*compare)(AVFormatContext *, AVPacket *, AVPacket *));
 
 void ff_read_frame_flush(AVFormatContext *s);
-
 #define NTP_OFFSET 2208988800ULL
 #define NTP_OFFSET_US (NTP_OFFSET * 1000000ULL)
 
diff --git a/amffmpeg/libavformat/libavformat-uninstalled.pc b/amffmpeg/libavformat/libavformat-uninstalled.pc
new file mode 100644
index 0000000..6f0c7ac
--- /dev/null
+++ b/amffmpeg/libavformat/libavformat-uninstalled.pc
@@ -0,0 +1,12 @@
+prefix=
+exec_prefix=
+libdir=${pcfiledir}
+includedir=/nishome/zhouzhi/android/android_rootfs_ref/packages/amlogic/LibPlayer/amffmpeg-0.8
+
+Name: libavformat
+Description: FFmpeg container format library
+Version: 53.4.0
+Requires: libavcodec = 53.7.0
+Conflicts:
+Libs: ${libdir}/libavformat.a -ldl -lm -pthread 
+Cflags: -I${includedir}
diff --git a/amffmpeg/libavformat/libavformat.pc b/amffmpeg/libavformat/libavformat.pc
new file mode 100644
index 0000000..3917ea4
--- /dev/null
+++ b/amffmpeg/libavformat/libavformat.pc
@@ -0,0 +1,14 @@
+prefix=/usr/local
+exec_prefix=${prefix}
+libdir=${prefix}/lib
+includedir=${prefix}/include
+
+Name: libavformat
+Description: FFmpeg container format library
+Version: 53.4.0
+Requires: libavcodec = 53.7.0
+Requires.private: 
+Conflicts:
+Libs: -L${libdir} -lavformat -ldl -lm -pthread
+Libs.private: 
+Cflags: -I${includedir}
diff --git a/amffmpeg/libavformat/m3u.c b/amffmpeg/libavformat/m3u.c
new file mode 100755
index 0000000..b189adc
--- /dev/null
+++ b/amffmpeg/libavformat/m3u.c
@@ -0,0 +1,276 @@
+/*
+ *m3u for ffmpeg system
+ * Copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include "libavutil/avstring.h"
+#include "avformat.h"
+#include <fcntl.h>
+#if HAVE_SETMODE
+#include <io.h>
+#endif
+#include <unistd.h>
+#include <sys/time.h>
+#include <stdlib.h>
+#include "os_support.h"
+#include "file_list.h"
+
+#define EXTM3U						"#EXTM3U"
+#define EXTINF						"#EXTINF"
+#define EXT_X_TARGETDURATION		"#EXT-X-TARGETDURATION"
+
+#define EXT_X_MEDIA_SEQUENCE		"#EXT-X-MEDIA-SEQUENCE"
+#define EXT_X_KEY					"#EXT-X-KEY"
+#define EXT_X_PROGRAM_DATE_TIME	"#EXT-X-PROGRAM-DATE-TIME"
+#define EXT_X_ALLOW_CACHE			"#EXT-X-ALLOW-CACHE"
+#define EXT_X_ENDLIST				"#EXT-X-ENDLIST"
+#define EXT_X_STREAM_INF			"#EXT-X-STREAM-INF"
+
+#define EXT_X_DISCONTINUITY		"#EXT-X-DISCONTINUITY"
+
+#define is_TAG(l,tag)	(!strncmp(l,tag,strlen(tag)))
+#define is_NET_URL(url)		(!strncmp(url,"http://",7) || !strncmp(url,"shttp://",8))
+
+struct m3u_info{
+	int duration;
+	int sequence;
+	int allow_cache;
+	int endlist;
+	char *key;
+	char *data_time;
+	char *streaminfo;
+	char *file;
+};
+
+static int m3u_format_get_line(ByteIOContext *s,char *line,int line_size)
+{
+    int ch;
+    char *q;
+	if(s->eof_reached || s->error)
+		return -1;
+    q = line;
+    for(;;) {
+        ch = get_byte(s);
+        if (ch < 0)
+            return AVERROR(EIO);
+        if (ch == '\n' || ch == '\0') {
+            /* process line */
+            if (q > line && q[-1] == '\r')
+                q--;
+            *q = '\0';
+			av_log(NULL, AV_LOG_INFO, "m3u_format_get_line line %d=%s\n",sizeof(line),line);
+            return q-line;
+        } else {
+            if ((q - line) < line_size - 1)
+                *q++ = ch;
+        }
+    }
+	return 0;
+}
+
+static int m3u_parser_line(struct list_mgt *mgt,unsigned char *line,struct list_item*item)
+{
+	unsigned char *p=line; 
+	int enditem=0;
+		
+	p=line;
+	while(*p==' ' && p!='\0' && p-line<1024) p++;
+	if(*p!='#' && strlen(p)>0)
+	{
+
+		item->file=p; 
+		enditem=1;
+	}else if(is_TAG(p,EXT_X_ENDLIST)){
+		item->flags=ENDLIST_FLAG;
+		enditem=1;
+	}else if(is_TAG(p,EXTINF)){
+		int duration=0;
+		sscanf(p+8,"%d",&duration);//skip strlen("#EXTINF:")
+		if(duration>0){
+			item->flags|=DURATION_FLAG;
+			item->duration=duration;
+			
+		}
+	}else if(is_TAG(p,EXT_X_ALLOW_CACHE)){
+		item->flags|=ALLOW_CACHE_FLAG;
+	}else{
+		return 0;
+	}
+	return enditem;
+}
+
+
+static int m3u_format_parser(struct list_mgt *mgt,ByteIOContext *s)
+{ 
+	unsigned  char line[1024];
+	int ret;
+	unsigned char *p; 
+	int getnum=0;
+	struct list_item tmpitem;
+ 	char prefix[1024]="";
+	char prefixex[1024]="";
+	int prefix_len=0,prefixex_len=0;
+	int start_time=mgt->full_time;
+	char *oprefix=mgt->location!=NULL?mgt->location:mgt->filename;
+	
+	
+	if(oprefix){
+		char *tail,*tailex;
+		if(is_NET_URL(oprefix))
+			tail=strchr(oprefix+9,'/');/*skip Http:// and shttp:*/
+		else
+			tail=strchr(oprefix,'/');
+		if(is_NET_URL(oprefix))
+			tailex=strrchr(oprefix+9,'/');/*skip Http:// and shttp:*/
+		else
+			tailex=strrchr(oprefix,'/');
+		
+		if(tail!=NULL){
+			prefix_len=tail-oprefix+1;/*left '/'..*/
+			memcpy(prefix,oprefix,prefix_len);
+			prefix[prefix_len]='\0';
+		}
+
+		if(tailex!=NULL){
+			prefixex_len=tailex-oprefix+1;/*left '/'..*/
+			memcpy(prefixex,oprefix,prefixex_len);
+			prefixex[prefixex_len]='\0';
+		}
+	}
+	memset(&tmpitem,0,sizeof(tmpitem));
+	av_log(NULL, AV_LOG_INFO, "m3u_format_parser get prefix=%s\n",prefix);
+	while(m3u_format_get_line(s,line,1024)>=0)
+	{
+		if(m3u_parser_line(mgt,line,&tmpitem))
+		{
+			struct list_item*item;
+			int need_prefix=0;
+			int size_file=tmpitem.file?(strlen(tmpitem.file)+32):4;
+			tmpitem.start_time=start_time;
+			start_time+=tmpitem.duration;
+			if(tmpitem.file && 
+				(is_NET_URL(prefix)) && /*net protocal*/
+				!(is_NET_URL(tmpitem.file)))/*if item is not net protocal*/
+			{/*if m3u is http,item is not http,add prefix*/
+				need_prefix=1;
+				size_file+=prefixex_len;
+			}
+			item=av_malloc(sizeof(struct list_item)+size_file);
+			if(!item)
+				return AVERROR(ENOMEM);
+			memcpy(item,&tmpitem,sizeof(tmpitem));
+			item->file=NULL;
+			if(tmpitem.file)
+			{
+				item->file=&item[1];
+				if(need_prefix){
+					if(tmpitem.file[0]=='/'){/*has '/',not need the dir */
+						strcpy(item->file,prefix);
+						strcpy(item->file+prefix_len,tmpitem.file);
+					}else{/*no '/', some I save the full path frefix*/
+						strcpy(item->file,prefixex);
+						strcpy(item->file+prefixex_len,tmpitem.file);
+					}
+				}
+				else{
+					strcpy(item->file,tmpitem.file);
+				}
+			}
+			list_add_item(mgt,item);
+			if(item->flags &ENDLIST_FLAG)
+			{
+				mgt->have_list_end=1;
+				break;
+			}
+			else
+			{
+				memset(&tmpitem,0,sizeof(tmpitem));
+				getnum++;
+			}
+		}else{
+			if(tmpitem.flags&ALLOW_CACHE_FLAG)
+				mgt->flags|=ALLOW_CACHE_FLAG;
+		}
+		
+	}
+	mgt->file_size=-1;
+	mgt->full_time=start_time;
+	av_log(NULL, AV_LOG_INFO, "m3u_format_parser end num =%d,fulltime=%d\n",getnum,start_time);
+	return getnum;
+}
+
+static int match_ext(const char *filename, const char *extensions)//get file type, .vob,.mp4,.ts...
+{
+    const char *ext, *p;
+    char ext1[32], *q;
+
+    if(!filename)
+        return 0;
+
+    ext = strrchr(filename, '.');
+    if (ext) {
+        ext++;
+        p = extensions;
+        for(;;) {
+            q = ext1;
+            while (*p != '\0' && *p != ',' && q-ext1<sizeof(ext1)-1)
+                *q++ = *p++;
+            *q = '\0';
+            if (!strcasecmp(ext1, ext))
+                return 1;
+            if (*p == '\0')
+                break;
+            p++;
+        }
+    }
+    return 0;
+}
+
+static int m3u_probe(ByteIOContext *s,const char *file)
+{
+	if(s)
+	{
+		char line[1024];
+		if(m3u_format_get_line(s,line,1024)>0)
+		{
+
+			if(memcmp(line,EXTM3U,strlen(EXTM3U))==0)
+			{
+				av_log(NULL, AV_LOG_INFO, "get m3u flags!!\n");
+				return 100;
+			}
+		}	
+	}
+	else
+	{
+		if((match_ext(file, "m3u"))||(match_ext(file, "m3u8"))) 
+		{
+			return 50;
+		}
+	}
+	return 0;
+}
+ 
+ struct list_demux m3u_demux = {
+	"m3u",
+    m3u_probe,
+	m3u_format_parser,
+};
+
+
+
diff --git a/amffmpeg/libavformat/matroskadec.c b/amffmpeg/libavformat/matroskadec.c
old mode 100644
new mode 100755
index 6e951ba..64e48ef
--- a/amffmpeg/libavformat/matroskadec.c
+++ b/amffmpeg/libavformat/matroskadec.c
@@ -255,8 +255,13 @@ typedef struct {
     /* What to skip before effectively reading a packet. */
     int skip_to_keyframe;
     uint64_t skip_to_timecode;
+
+    /* Record the position of media */
+    uint64_t media_offset;
 } MatroskaDemuxContext;
 
+#define MAX_OFFSET 0xffffffffffffffff
+
 typedef struct {
     uint64_t duration;
     int64_t  reference;
@@ -768,6 +773,18 @@ static int ebml_parse_id(MatroskaDemuxContext *matroska, EbmlSyntax *syntax,
         return 0;  // we reached the end of an unknown size cluster
     if (!syntax[i].id && id != EBML_ID_VOID && id != EBML_ID_CRC32)
         av_log(matroska->ctx, AV_LOG_INFO, "Unknown entry 0x%X\n", id);
+
+    if ((matroska->media_offset == MAX_OFFSET)
+        && ((MATROSKA_ID_CLUSTER == id) 
+        || (MATROSKA_ID_ATTACHMENTS == id) 
+        || (MATROSKA_ID_CHAPTERS == id))) {
+        matroska->media_offset = url_ftell(matroska->ctx->pb) - 4;
+    }
+
+    if ((MATROSKA_ID_TRACKS == id) && (url_ftell(matroska->ctx->pb) > matroska->media_offset)) {
+        return 0;
+    }
+    
     return ebml_parse_elem(matroska, &syntax[i], data);
 }
 
@@ -1235,7 +1252,8 @@ static int matroska_read_header(AVFormatContext *s, AVFormatParameters *ap)
     int i, j, k, res;
 
     matroska->ctx = s;
-
+    matroska->media_offset = MAX_OFFSET;
+    
     /* First read the EBML header. */
     if (ebml_parse(matroska, ebml_syntax, &ebml)
         || ebml.version > EBML_VERSION       || ebml.max_size > sizeof(uint64_t)
@@ -1869,10 +1887,12 @@ static int matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data,
                     pkt->flags = is_keyframe;
                 pkt->stream_index = st->index;
 
+                #if 0
                 if (track->ms_compat)
                     pkt->dts = timecode;
                 else
-                    pkt->pts = timecode;
+                #endif
+                pkt->pts = timecode;
                 pkt->pos = pos;
                 if (st->codec->codec_id == CODEC_ID_TEXT)
                     pkt->convergence_duration = duration;
diff --git a/amffmpeg/libavformat/mov.c b/amffmpeg/libavformat/mov.c
old mode 100644
new mode 100755
index 773760c..c8a1ee6
--- a/amffmpeg/libavformat/mov.c
+++ b/amffmpeg/libavformat/mov.c
@@ -1425,7 +1425,8 @@ static int mov_read_stsz(MOVContext *c, AVIOContext *pb, MOVAtom atom)
     if (avio_read(pb, buf, num_bytes) < num_bytes) {
         av_freep(&sc->sample_sizes);
         av_free(buf);
-        return -1;
+        //return -1;
+        return 0;//*don't retrun -1,if only read end*/
     }
 
     init_get_bits(&gb, buf, 8*num_bytes);
@@ -1592,7 +1593,8 @@ static void mov_build_index(MOVContext *mov, AVStream *st)
                     distance = 0;
                 sample_size = sc->sample_size > 0 ? sc->sample_size : sc->sample_sizes[current_sample];
                 if(sc->pseudo_stream_id == -1 ||
-                   sc->stsc_data[stsc_index].id - 1 == sc->pseudo_stream_id) {
+                   sc->stsc_data[stsc_index].id - 1 == sc->pseudo_stream_id ||
+                   st->codec->codec_type == CODEC_TYPE_VIDEO) {
                     AVIndexEntry *e = &st->index_entries[st->nb_index_entries++];
                     e->pos = current_offset;
                     e->timestamp = current_dts;
@@ -1705,8 +1707,15 @@ static void mov_build_index(MOVContext *mov, AVStream *st)
 
 static int mov_open_dref(AVIOContext **pb, const char *src, MOVDref *ref)
 {
-    /* try relative path, we do not try the absolute because it can leak information about our
-       system to an attacker */
+	/* try relative path, we do not try the absolute because it can leak information about our
+		system to an attacker */
+	#if 0
+    /* try absolute path */
+    if (!url_fopen(pb, ref->path, URL_RDONLY))
+        return 0;
+
+    /* try relative path */
+	#endif
     if (ref->nlvl_to > 0 && ref->nlvl_from > 0) {
         char filename[1024];
         const char *src_path;
@@ -2244,12 +2253,14 @@ static const MOVParseTableEntry mov_default_parse_table[] = {
 { MKTAG('i','l','s','t'), mov_read_ilst },
 { MKTAG('j','p','2','h'), mov_read_extradata },
 { MKTAG('m','d','a','t'), mov_read_mdat },
+{ MKTAG('a','v','i','d'), mov_read_mdat },	/*for 3dv*/
 { MKTAG('m','d','h','d'), mov_read_mdhd },
 { MKTAG('m','d','i','a'), mov_read_default },
 { MKTAG('m','e','t','a'), mov_read_meta },
 { MKTAG('m','i','n','f'), mov_read_default },
 { MKTAG('m','o','o','f'), mov_read_moof },
 { MKTAG('m','o','o','v'), mov_read_moov },
+{ MKTAG('3','d','v','f'), mov_read_moov },	/*for 3dv*/
 { MKTAG('m','v','e','x'), mov_read_default },
 { MKTAG('m','v','h','d'), mov_read_mvhd },
 { MKTAG('S','M','I',' '), mov_read_smi }, /* Sorenson extension ??? */
@@ -2306,6 +2317,7 @@ static int mov_probe(AVProbeData *p)
         case MKTAG('p','n','o','t'): /* detect movs with preview pics like ew.mov and april.mov */
         case MKTAG('u','d','t','a'): /* Packet Video PVAuthor adds this and a lot of more junk */
         case MKTAG('f','t','y','p'):
+		case MKTAG('p','i','n','f'): /* for 3dv */
             return AVPROBE_SCORE_MAX;
         /* those are more common words, so rate then a bit less */
         case MKTAG('e','d','i','w'): /* xdcam files have reverted first tags */
diff --git a/amffmpeg/libavformat/mpeg.c b/amffmpeg/libavformat/mpeg.c
old mode 100644
new mode 100755
index 1bc4480..9f9a079
--- a/amffmpeg/libavformat/mpeg.c
+++ b/amffmpeg/libavformat/mpeg.c
@@ -252,7 +252,7 @@ static int mpegps_read_pes_header(AVFormatContext *s,
         last_sync = avio_tell(s->pb);
     //printf("startcode=%x pos=0x%"PRIx64"\n", startcode, avio_tell(s->pb));
     if (startcode < 0){
-        if(url_feof(s->pb))
+        if(url_feof(s->pb) || (s->valid_offset > 0 && last_sync > s->valid_offset))
             return AVERROR_EOF;
         //FIXME we should remember header_state
         return AVERROR(EAGAIN);
@@ -484,6 +484,31 @@ static int mpegps_read_packet(AVFormatContext *s,
     } else if (startcode >= 0x1c0 && startcode <= 0x1df) {
         type = AVMEDIA_TYPE_AUDIO;
         codec_id = m->sofdec > 0 ? CODEC_ID_ADPCM_ADX : CODEC_ID_MP2;
+		if(codec_id == CODEC_ID_MP2)
+		{	
+			unsigned char buf[32];
+			int i;
+			unsigned long newhead;	
+			
+			avio_read(s->pb, buf, 32);
+        	avio_seek(s->pb, -32, SEEK_CUR);
+			
+			for(i = 0; i < 32; i ++)
+			{
+				newhead = buf[0]<<24|buf[1]<<16|buf[2]<<8|buf[3];
+				// head_check:
+			    if((newhead & 0xffe00000) == 0xffe00000)
+		    	{
+		    		int layer;
+		    		layer = 4-((newhead>>17)&3);
+    				if(layer==4)
+					{
+						codec_id = CODEC_ID_AAC;
+						break;
+					}
+			    }
+			}			
+		}        
     } else if (startcode >= 0x80 && startcode <= 0x87) {
         type = AVMEDIA_TYPE_AUDIO;
         codec_id = CODEC_ID_AC3;
@@ -529,6 +554,26 @@ static int mpegps_read_packet(AVFormatContext *s,
         goto redo;
     }
     /* no stream found: add a new stream */
+	if(startcode >= 0x20 && startcode <= 0x3f){
+		//add all subtitle streams which less then current subtitle stream
+		int i = 0, j = 0;
+		for(i=0; i<(startcode-0x20+1); i++){
+			for(j=0; j<s->nb_streams; j++){
+				if((i+0x20) == s->streams[j]->id)
+					break;
+			}
+			if(j == s->nb_streams){
+				st = av_new_stream(s, (i+0x20));
+			    if (!st)
+			        goto skip;
+			    st->codec->codec_type = type;
+			    st->codec->codec_id = codec_id;
+			    if (codec_id != CODEC_ID_PCM_S16BE)
+			        st->need_parsing = AVSTREAM_PARSE_FULL;
+			}
+		}
+	}
+	else{
     st = av_new_stream(s, startcode);
     if (!st)
         goto skip;
@@ -537,6 +582,7 @@ static int mpegps_read_packet(AVFormatContext *s,
     st->request_probe     = request_probe;
     if (codec_id != CODEC_ID_PCM_S16BE)
         st->need_parsing = AVSTREAM_PARSE_FULL;
+	}
  found:
     if(st->discard >= AVDISCARD_ALL)
         goto skip;
diff --git a/amffmpeg/libavformat/mpegts.c b/amffmpeg/libavformat/mpegts.c
old mode 100644
new mode 100755
index 74c9ac9..a4eb1ed
--- a/amffmpeg/libavformat/mpegts.c
+++ b/amffmpeg/libavformat/mpegts.c
@@ -930,6 +930,11 @@ int ff_parse_mpeg2_descriptor(AVFormatContext *fc, AVStream *st, int stream_type
         stream_type == STREAM_TYPE_PRIVATE_DATA)
         mpegts_find_stream_type(st, desc_tag, DESC_types);
 
+	if ((st->codec->codec_id == CODEC_ID_H264) && (av_match_ext(fc->filename, "mvc"))) {
+		av_log(NULL, AV_LOG_ERROR, "override codec_id to MVC\n");
+		st->codec->codec_id = CODEC_ID_H264MVC;
+	}
+
     switch(desc_tag) {
     case 0x1F: /* FMC descriptor */
         get16(pp, desc_end);
@@ -1353,7 +1358,12 @@ static int mpegts_resync(AVFormatContext *s)
 
     for(i = 0;i < MAX_RESYNC_SIZE; i++) {
         c = avio_r8(pb);
-        if (url_feof(pb))
+        c = url_fgetc(pb);
+		if(pb->pos > s->valid_offset && s->valid_offset > 0){
+			av_log(s, AV_LOG_ERROR, "exceed valid offset\n");
+			return AVERROR_EOF;
+		}
+        if (c < 0)
             return -1;
         if (c == 0x47) {
             avio_seek(pb, -1, SEEK_CUR);
@@ -1370,6 +1380,7 @@ static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size)
 {
     AVIOContext *pb = s->pb;
     int skip, len;
+	int ret;
 
     for(;;) {
         len = avio_read(pb, buf, TS_PACKET_SIZE);
@@ -1379,8 +1390,13 @@ static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size)
         if (buf[0] != 0x47) {
             /* find a new packet start */
             avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);
-            if (mpegts_resync(s) < 0)
-                return AVERROR(EAGAIN);
+			ret = mpegts_resync(s) ;
+            if (ret < 0){
+				if(ret == AVERROR_EOF)
+					return ret;
+				else
+					return AVERROR(EAGAIN);
+            }
             else
                 continue;
         } else {
@@ -1508,6 +1524,7 @@ static int mpegts_read_header(AVFormatContext *s,
     }
     ts->stream = s;
     ts->auto_guess = 0;
+    s->orig_packet_size = ts->raw_packet_size;
 
     if (s->iformat == &ff_mpegts_demuxer) {
         /* normal demux */
diff --git a/amffmpeg/libavformat/nutdec.c b/amffmpeg/libavformat/nutdec.c
index 7aecf73..7286963 100644
--- a/amffmpeg/libavformat/nutdec.c
+++ b/amffmpeg/libavformat/nutdec.c
@@ -850,6 +850,7 @@ av_log(s, AV_LOG_DEBUG, "read_timestamp(X,%d,%"PRId64",%"PRId64")\n", stream_ind
     else if(stream_index == -2) return back_ptr;
 
 assert(0);
+	return -1;
 }
 
 static int read_seek(AVFormatContext *s, int stream_index, int64_t pts, int flags){
diff --git a/amffmpeg/libavformat/rtpdec_h264.c b/amffmpeg/libavformat/rtpdec_h264.c
old mode 100644
new mode 100755
index 730ed14..c7c3d9f
--- a/amffmpeg/libavformat/rtpdec_h264.c
+++ b/amffmpeg/libavformat/rtpdec_h264.c
@@ -113,7 +113,7 @@ static int sdp_parse_fmtp_config_h264(AVStream * stream,
             h264_data->level_idc = level_idc;
         }
     } else  if (!strcmp(attr, "sprop-parameter-sets")) {
-        uint8_t start_sequence[]= { 0, 0, 1 };
+        uint8_t start_sequence[]= {0, 0, 0, 1 };
         codec->extradata_size= 0;
         codec->extradata= NULL;
 
@@ -159,6 +159,8 @@ static int sdp_parse_fmtp_config_h264(AVStream * stream,
                 }
             }
         }
+		memcpy(codec->extradata+codec->extradata_size, start_sequence, sizeof(start_sequence));
+		codec->extradata_size+=sizeof(start_sequence);
         av_log(codec, AV_LOG_DEBUG, "Extradata set to %p (size: %d)!", codec->extradata, codec->extradata_size);
     }
     return 0;
@@ -176,7 +178,7 @@ static int h264_handle_packet(AVFormatContext *ctx,
     uint8_t nal = buf[0];
     uint8_t type = (nal & 0x1f);
     int result= 0;
-    uint8_t start_sequence[]= {0, 0, 1};
+    uint8_t start_sequence[]= {0, 0, 0, 1 };
 
 #ifdef DEBUG
     assert(data);
diff --git a/amffmpeg/libavformat/tcp.c b/amffmpeg/libavformat/tcp.c
old mode 100644
new mode 100755
index eb982d5..a6b6708
--- a/amffmpeg/libavformat/tcp.c
+++ b/amffmpeg/libavformat/tcp.c
@@ -45,7 +45,7 @@ static int tcp_open(URLContext *h, const char *uri, int flags)
     char buf[256];
     int ret;
     socklen_t optlen;
-    int timeout = 50;
+    int timeout = 500;
     char hostname[1024],proto[1024],path[1024];
     char portstr[10];
 
@@ -121,6 +121,9 @@ static int tcp_open(URLContext *h, const char *uri, int flags)
                 break;
         }
         if (ret <= 0) {
+			 av_log(h, AV_LOG_ERROR,
+                   "TCP connection to %s:%d timeout failed!\n",
+                   hostname, port);
             ret = AVERROR(ETIMEDOUT);
             goto fail;
         }
diff --git a/amffmpeg/libavformat/udp.c b/amffmpeg/libavformat/udp.c
old mode 100644
new mode 100755
index 7c18fb7..29b4da8
--- a/amffmpeg/libavformat/udp.c
+++ b/amffmpeg/libavformat/udp.c
@@ -511,7 +511,7 @@ static int udp_open(URLContext *h, const char *uri, int flags)
 
     s->udp_fd = udp_fd;
 
-#if HAVE_PTHREADS
+#if 0 && HAVE_PTHREADS
     if (!is_output && s->circular_buffer_size) {
         /* start the task going */
         s->fifo = av_fifo_alloc(s->circular_buffer_size);
diff --git a/amffmpeg/libavformat/url.h b/amffmpeg/libavformat/url.h
old mode 100644
new mode 100755
index 5ef6a21..241de47
--- a/amffmpeg/libavformat/url.h
+++ b/amffmpeg/libavformat/url.h
@@ -48,7 +48,7 @@ typedef struct URLProtocol {
     const char *name;
     int     (*url_open)( URLContext *h, const char *url, int flags);
     int     (*url_read)( URLContext *h, unsigned char *buf, int size);
-    int     (*url_write)(URLContext *h, const unsigned char *buf, int size);
+    int     (*url_write)(URLContext *h, unsigned char *buf, int size);
     int64_t (*url_seek)( URLContext *h, int64_t pos, int whence);
     int     (*url_close)(URLContext *h);
     struct URLProtocol *next;
@@ -103,6 +103,18 @@ int ffurl_open(URLContext **h, const char *url, int flags);
  * indicates that it is not possible to read more from the accessed
  * resource (except if the value of the size argument is also zero).
  */
+int ffurl_open_h(URLContext **puc, const char *filename, int flags,const char *headers);
+/**
+ * Read up to size bytes from the resource accessed by h, and store
+ * the read bytes in buf.
+ *
+ * @return The number of bytes actually read, or a negative value
+ * corresponding to an AVERROR code in case of error. A value of zero
+ * indicates that it is not possible to read more from the accessed
+ * resource (except if the value of the size argument is also zero).
+ */
+ 
+
 int ffurl_read(URLContext *h, unsigned char *buf, int size);
 
 /**
@@ -168,9 +180,12 @@ int ffurl_get_file_handle(URLContext *h);
  * @param size the size of the URLProtocol struct referenced
  */
 int ffurl_register_protocol(URLProtocol *protocol, int size);
+int av_register_protocol(URLProtocol *protocol);
+
 
 /* udp.c */
 int ff_udp_set_remote_url(URLContext *h, const char *uri);
 int ff_udp_get_local_port(URLContext *h);
 
+
 #endif /* AVFORMAT_URL_H */
diff --git a/amffmpeg/libavformat/utils.c b/amffmpeg/libavformat/utils.c
old mode 100644
new mode 100755
index cd90480..654a063
--- a/amffmpeg/libavformat/utils.c
+++ b/amffmpeg/libavformat/utils.c
@@ -39,6 +39,8 @@
 #include <time.h>
 #include <strings.h>
 #include <stdarg.h>
+#include "file_list.h"
+
 #if CONFIG_NETWORK
 #include "network.h"
 #endif
@@ -578,10 +580,31 @@ int av_open_input_file(AVFormatContext **ic_ptr, const char *filename,
     av_dict_free(&opts);
     return err;
 }
+
+int av_open_input_file_header(AVFormatContext **ic_ptr, const char *filename,
+                       AVInputFormat *fmt,
+                       int buf_size,
+                       AVFormatParameters *ap,
+                       const char *headers
+                       )
+{
+    int err;
+    AVDictionary *opts = convert_format_parameters(ap);
+
+    if (!ap || !ap->prealloced_context)
+        *ic_ptr = NULL;
+
+    err = avformat_open_input_header(ic_ptr, filename, fmt, &opts,headers);
+
+    av_dict_free(&opts);
+    return err;
+}
+
+
 #endif
 
 /* open input file and probe the format if necessary */
-static int init_input(AVFormatContext *s, const char *filename)
+static int init_input(AVFormatContext *s, const char *filename,const char * headers)
 {
     int ret;
     AVProbeData pd = {filename, NULL, 0};
@@ -594,19 +617,35 @@ static int init_input(AVFormatContext *s, const char *filename)
             return AVERROR(EINVAL);
         return 0;
     }
-
     if ( (s->iformat && s->iformat->flags & AVFMT_NOFILE) ||
         (!s->iformat && (s->iformat = av_probe_input_format(&pd, 0))))
         return 0;
-
     if ((ret = avio_open(&s->pb, filename, AVIO_FLAG_READ)) < 0)
        return ret;
+	if(url_is_file_list(s->pb,filename)){
+			char *listfile;
+			int err;
+			listfile=av_malloc(strlen(filename)+10);
+			if(!listfile)
+				return AVERROR(ENOMEM);
+			strcpy(listfile,"list:");
+			strcpy(listfile+5,filename);
+			url_fclose(s->pb);
+			s->pb=NULL;
+			if ((err=avio_open_h(&s->pb,listfile, AVIO_FLAG_READ, headers)) < 0) {
+				av_log(NULL, AV_LOG_ERROR, "init_input:%s failed,line=%d err=0x%x\n",listfile,__LINE__,err);
+				av_free(listfile);
+	            return AVERROR(EIO);;
+        	}
+			s->pb->filename=listfile;
+	}
     if (s->iformat)
         return 0;
     return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, 0);
 }
 
-int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options)
+
+int avformat_open_input_header(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options,const char *headers)
 {
     AVFormatContext *s = *ps;
     int ret = 0;
@@ -624,7 +663,7 @@ int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputForma
     if ((ret = av_opt_set_dict(s, &tmp)) < 0)
         goto fail;
 
-    if ((ret = init_input(s, filename)) < 0)
+    if ((ret = init_input(s, filename,headers)) < 0)
         goto fail;
 
     /* check filename in case an image number is expected */
@@ -681,6 +720,11 @@ fail:
     return ret;
 }
 
+int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options)
+{
+    return avformat_open_input_header(ps,filename,fmt,options,NULL);
+}
+
 /*******************************************************/
 
 static AVPacket *add_to_pktbuf(AVPacketList **packet_buffer, AVPacket *pkt,
@@ -1944,6 +1988,326 @@ static void av_estimate_timings_from_bit_rate(AVFormatContext *ic)
 
 #define DURATION_MAX_READ_SIZE 250000
 #define DURATION_MAX_RETRY 3
+#define CHECK_FULL_ZERO_SIZE DURATION_MAX_READ_SIZE		
+static int64_t seek_last_valid_pkt(AVFormatContext *ic)
+{	
+	int64_t filesize,offset;
+	int64_t start_offset,end_offset;
+	int ret;
+	unsigned char *buf1;
+	unsigned char *buf2;
+	
+	buf1 = av_malloc(CHECK_FULL_ZERO_SIZE);	
+	if(!buf1)
+		return -2;
+	buf2 = av_malloc(CHECK_FULL_ZERO_SIZE);
+	if(!buf2)
+	{
+		av_free(buf1);
+		return -3;
+	}
+	memset(buf1,0,CHECK_FULL_ZERO_SIZE);
+	memset(buf2,0,CHECK_FULL_ZERO_SIZE);	
+	filesize = ic->file_size;	
+	start_offset = 0;
+	end_offset = filesize;
+	for(;;)
+	{
+	   	//av_log(NULL, AV_LOG_INFO, "[%s:%d]start=0x%llx end=0x%llx end-start=0x%llx\n",__FUNCTION__,__LINE__,start_offset,end_offset,end_offset - start_offset);
+		if(start_offset >= end_offset)
+			break;
+		if((end_offset - start_offset)<(CHECK_FULL_ZERO_SIZE << 1))
+		{
+			av_log(NULL, AV_LOG_INFO, "[%s:%d]last block!offset=0x%llx\n",__FUNCTION__,__LINE__,start_offset);
+			av_free(buf1);
+			av_free(buf2);
+			return start_offset;	
+		}
+		
+		offset = (start_offset + end_offset) >> 1;		
+	   	//av_log(NULL, AV_LOG_INFO, "[%s:%d]offset=0x%llx\n",__FUNCTION__,__LINE__,offset);
+		avio_seek(ic->pb, offset, SEEK_SET);
+		do{
+            ret = avio_read(ic->pb, buf1,CHECK_FULL_ZERO_SIZE);
+        }while(ret == AVERROR(EAGAIN));
+        if (ret < 0)
+        {
+        	av_log(NULL, AV_LOG_INFO, "[%s:%d]av_read_packet failed ret=%d\n",__FUNCTION__,__LINE__,ret);
+        	break;
+        }		
+		
+		if(memcmp(buf1,buf2,CHECK_FULL_ZERO_SIZE)==0)	//cmp,buf1=buf2=0
+		{
+        	//av_log(NULL, AV_LOG_INFO, "[%s:%d]first block buf1=0\n",__FUNCTION__,__LINE__);
+			end_offset = offset;			//head -full zero
+			continue;
+		}
+		else	//buf1<>0
+		{		
+        	//av_log(NULL, AV_LOG_INFO, "[%s:%d]first block buf1<>0\n",__FUNCTION__,__LINE__);
+			memset(buf1,0,CHECK_FULL_ZERO_SIZE);
+			avio_seek(ic->pb, offset + CHECK_FULL_ZERO_SIZE, SEEK_SET);
+			do{
+	            ret = avio_read(ic->pb, buf1,CHECK_FULL_ZERO_SIZE);
+	        }while(ret == AVERROR(EAGAIN));
+	        if (ret < 0)
+	        {
+	        	av_log(NULL, AV_LOG_INFO, "[%s:%d]av_read_packet failed ret=%d\n",__FUNCTION__,__LINE__,ret);
+				if(ret == AVERROR_EOF)
+				{
+					av_free(buf1);
+					av_free(buf2);
+					return filesize;
+				}
+				break;
+	        }
+			if(memcmp(buf1,buf2,CHECK_FULL_ZERO_SIZE) == 0)
+			{
+	        	av_log(NULL, AV_LOG_INFO, "[%s:%d]find valid packet!offset=0x%llx\n",__FUNCTION__,__LINE__,offset);
+				av_free(buf1);
+				av_free(buf2);
+				return offset;	
+			}
+			else
+			{
+	        	//av_log(NULL, AV_LOG_INFO, "[%s:%d]second block buf1<>0\n",__FUNCTION__,__LINE__);
+				start_offset = offset;
+				continue;
+			}
+		}		
+	}	
+	av_free(buf1);
+	av_free(buf2);
+	return -1;
+}
+static int64_t check_last_blk_valid(AVFormatContext *ic)
+{
+	unsigned char *buf1;
+	unsigned char *buf2;
+	int check_size;
+	int read_size;
+	int64_t filesize,offset;	
+	int64_t start_offset,end_offset;	
+	int64_t ret = -1;
+	
+	buf1 = av_mallocz(CHECK_FULL_ZERO_SIZE);	
+	if(!buf1)
+		return AVERROR(ENOMEM);
+	buf2 = av_mallocz(CHECK_FULL_ZERO_SIZE);	
+	if(!buf2)
+	{
+		av_free(buf1);
+		return AVERROR(ENOMEM);
+	}
+	filesize = ic->file_size;	
+	if(filesize < CHECK_FULL_ZERO_SIZE)
+		check_size = filesize >> 3;
+	else
+		check_size = CHECK_FULL_ZERO_SIZE;
+	
+	offset = filesize - check_size;
+    if (offset < 0)
+        offset = 0;
+    avio_seek(ic->pb, offset, SEEK_SET);
+    read_size = 0;
+	read_size = avio_read(ic->pb, buf1, check_size);
+	if(read_size <= 0)
+	{
+		av_log(ic, AV_LOG_ERROR, "[%s]get buffer failed, ret=%d\n",__FUNCTION__,read_size);
+		ret = 2;
+		goto end;
+	}
+	else if(memcmp(buf1,buf2,check_size)==0)	//cmp,buf1=buf2=0
+	{		
+		av_log(ic, AV_LOG_ERROR, "[%s]last block is full ZERO\n",__FUNCTION__);
+		ret = 0;
+		goto end;
+	
+	}
+	else
+	{
+		av_log(ic, AV_LOG_ERROR, "[%s]last block is valid data!\n",__FUNCTION__);
+		ret = filesize;		
+	}	
+end:
+	av_free(buf1);
+	av_free(buf2);
+	av_log(ic, AV_LOG_INFO, "[%s]last valid block is [0x%llx] file_size=0x%llx\n",__FUNCTION__,ret, filesize);
+	return ret;
+	
+}
+
+static int64_t find_last_chapter_end(AVFormatContext *ic, int64_t old_offset, int64_t start_time)
+{
+	AVPacket pkt1, *pkt = &pkt1;
+	int64_t offset;
+	int64_t pts = AV_NOPTS_VALUE;
+	int read_size, i, ret, retry = 0;
+
+	offset = old_offset;
+	
+	do{
+	    offset -= DURATION_MAX_READ_SIZE;
+	    if (offset < 0){
+	        offset = 0;
+			break;
+	    }
+       	//av_log(NULL, AV_LOG_INFO, "[%s:%d]offset=0x%llx\n",__FUNCTION__,__LINE__,offset);
+	    avio_seek(ic->pb, offset, SEEK_SET);
+	    read_size = 0;
+	    for(;;) {
+	        if (read_size >= DURATION_MAX_READ_SIZE<<(FFMAX(retry-1,0)))
+	            break;
+
+	        do{
+	            ret = av_read_packet(ic, pkt);
+	        }while(ret == AVERROR(EAGAIN));
+	        if (ret != 0)
+	        {
+	        	av_log(NULL, AV_LOG_INFO, "[%s:%d]av_read_packet failed, ret=%d\n",__FUNCTION__,__LINE__,ret);
+	        	break;
+	        }
+			//av_log(NULL, AV_LOG_INFO, "[%s:%d] read a packet, pkt->pts=0x%llx\n",__FUNCTION__, __LINE__,pkt->pts);
+	        read_size += pkt->size;
+	        if(pkt->pts != AV_NOPTS_VALUE){
+				av_log(NULL, AV_LOG_INFO, "start_time=0x%llx pts=0x%llx\n",start_time, pts);
+
+				if(pkt->pts > start_time && (pkt->pts > pts || pts == AV_NOPTS_VALUE)){
+					pts = pkt->pts;
+					//av_log(NULL, AV_LOG_INFO, "pts============0x%llx\n",pts);
+				}else if(pkt->pts < start_time){
+					break;
+				}
+			}
+	        av_free_packet(pkt);
+	    }		
+    }while(pts == AV_NOPTS_VALUE && old_offset > (DURATION_MAX_READ_SIZE<<retry));          
+		
+	avio_seek(ic->pb, old_offset, SEEK_SET);
+	//av_log(NULL, AV_LOG_INFO, "[%s]return pts=0x%llx\n",__FUNCTION__, pts);
+	return pts;
+}
+
+/* only usable for vob */
+static void av_estimate_timeings_chapters(AVFormatContext * ic, int64_t old_offset)
+{
+	AVPacket pkt1, *pkt = &pkt1;
+    AVStream *st;
+    int read_size, i, ret;
+    int64_t end_time, start_time[MAX_STREAMS];
+    int64_t valid_offset, offset, last_offset, duration;
+	int64_t last_pts[MAX_STREAMS], pts_discontinue[MAX_STREAMS];	
+    int retry=0;   
+#define DISCONTINUE_PTS_VALUE  (0xffffffff)
+
+    ic->cur_st = NULL;
+
+    /* flush packet queue */
+    flush_packet_queue(ic);
+
+    for(i=0;i<ic->nb_streams;i++) {
+		last_pts[i] = AV_NOPTS_VALUE;
+		pts_discontinue[i] = AV_NOPTS_VALUE;
+        st = ic->streams[i];
+        if(st->start_time != AV_NOPTS_VALUE){
+            start_time[i]= st->start_time;
+        }else if(st->first_dts != AV_NOPTS_VALUE){
+            start_time[i]= st->first_dts;
+        }else
+            av_log(st->codec, AV_LOG_WARNING, "start time is not set in av_estimate_timings_from_pts\n");
+
+        if (st->parser) {
+            av_parser_close(st->parser);
+            st->parser= NULL;
+            av_free_packet(&st->cur_pkt);
+        }
+    }
+
+    /* estimate the end time (duration) */
+    /* XXX: may need to support wrapping */
+    valid_offset = ic->valid_offset;
+    end_time = AV_NOPTS_VALUE;
+    do{
+	    offset = valid_offset - (DURATION_MAX_READ_SIZE<<retry);
+	    if (offset < 0)
+	        offset = 0;
+
+	    avio_seek(ic->pb, offset, SEEK_SET);
+	    read_size = 0;
+	    for(;;) {
+	        if (read_size >= DURATION_MAX_READ_SIZE<<(FFMAX(retry-1,0)))
+	            break;
+
+	        do{
+	            ret = av_read_packet(ic, pkt);
+	        }while(ret == AVERROR(EAGAIN));
+	        if (ret != 0)
+	        {
+	        	av_log(NULL, AV_LOG_INFO, "[%s:%d]av_read_packet failed, ret=%d\n",__FUNCTION__,__LINE__,ret);
+	        	break;
+	        }
+			//av_log(NULL, AV_LOG_INFO, "[%s:%d] read a packet, pkt->pts=0x%llx\n",__FUNCTION__, __LINE__,pkt->pts);
+	        read_size += pkt->size;
+	        st = ic->streams[pkt->stream_index];
+	        if (pkt->pts != AV_NOPTS_VALUE){ 				
+				if(last_pts[pkt->stream_index] != AV_NOPTS_VALUE && 
+					last_pts[pkt->stream_index] < DISCONTINUE_PTS_VALUE &&
+					pkt->pts < last_pts[pkt->stream_index]){
+					pts_discontinue[pkt->stream_index] = last_pts[pkt->stream_index];	
+					av_log(NULL, AV_LOG_INFO, "pts=0x%llx discontinue_pts=0x%llx\n",pkt->pts, last_pts[pkt->stream_index]);
+				}				
+					
+				if(pkt->pts != last_pts[pkt->stream_index]){
+					last_pts[pkt->stream_index] = pkt->pts;
+				}
+				
+	            if(start_time[pkt->stream_index] != AV_NOPTS_VALUE) {  
+					if(pkt->pts < start_time[pkt->stream_index] && 
+						pkt->pts < DISCONTINUE_PTS_VALUE &&
+						pts_discontinue[pkt->stream_index] == AV_NOPTS_VALUE){
+						last_offset = url_ftell(ic->pb);
+						pts_discontinue[pkt->stream_index] = find_last_chapter_end(ic, last_offset, start_time[pkt->stream_index]);						
+					}
+		            end_time = pkt->pts;
+		            duration = end_time - start_time[pkt->stream_index];
+					//av_log(NULL, AV_LOG_INFO, "end=0x%llx start=0x%llx dur=0x%llx\n",end_time, start_time[pkt->stream_index], duration);
+
+					if(pts_discontinue[pkt->stream_index] != AV_NOPTS_VALUE){
+						duration += pts_discontinue[pkt->stream_index];
+						//av_log(NULL, AV_LOG_INFO, "discontinue_pts=0x%llx duration=0x%llx\n",pts_discontinue[pkt->stream_index], duration);
+					}
+		            if (duration < 0){
+		                duration += 1LL<<st->pts_wrap_bits;
+						av_log(NULL, AV_LOG_INFO, "duration=0x%llx\n",duration);
+		            }
+		            if (duration > 0) {
+		                if (st->duration == AV_NOPTS_VALUE ||
+		                    st->duration < duration)
+		                    st->duration = duration;
+							//av_log(NULL, AV_LOG_INFO, "st->dur=0x%llx\n",duration);
+		            }
+	        	}
+	        }
+	        av_free_packet(pkt);
+	    }
+    }while(end_time==AV_NOPTS_VALUE
+           && valid_offset > (DURATION_MAX_READ_SIZE<<retry)
+           && ++retry <= DURATION_MAX_RETRY);
+
+    for (i=0;i<ic->nb_streams;i++)
+    {
+        st = ic->streams[i];
+        duration = st->duration;
+    }
+	fill_all_stream_timings(ic);
+
+    avio_seek(ic->pb, old_offset, SEEK_SET);
+    for(i=0; i<ic->nb_streams; i++){
+        st= ic->streams[i];
+        st->cur_dts= st->first_dts;
+        st->last_IP_pts = AV_NOPTS_VALUE;
+    }	
+}
 
 /* only usable for MPEG-PS streams */
 static void av_estimate_timings_from_pts(AVFormatContext *ic, int64_t old_offset)
@@ -2675,6 +3039,7 @@ void av_close_input_file(AVFormatContext *s)
     av_close_input_stream(s);
     if (pb)
         avio_close(pb);
+	
 }
 
 AVStream *av_new_stream(AVFormatContext *s, int id)
diff --git a/amffmpeg/libavutil/Android.mk b/amffmpeg/libavutil/Android.mk
new file mode 100755
index 0000000..9e3ecc9
--- /dev/null
+++ b/amffmpeg/libavutil/Android.mk
@@ -0,0 +1,29 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+include $(LOCAL_PATH)/../common.mk
+LOCAL_SRC_FILES := $(FFFILES)
+LOCAL_C_INCLUDES :=		\
+	$(LOCAL_PATH)		\
+	$(LOCAL_PATH)/..
+LOCAL_CFLAGS += $(FFCFLAGS)
+LOCAL_MODULE := $(FFNAME)
+# Reset CC as it's overwritten by common.mk
+include $(BUILD_STATIC_LIBRARY)
+
+
+include $(CLEAR_VARS)
+include $(LOCAL_PATH)/../common.mk
+LOCAL_SRC_FILES := $(FFFILES)
+LOCAL_C_INCLUDES :=		\
+	$(LOCAL_PATH)		\
+	$(LOCAL_PATH)/..	\
+	external/zlib
+LOCAL_CFLAGS += $(FFCFLAGS)
+LOCAL_MODULE := $(FFNAME)
+LOCAL_SHARED_LIBRARIES += libutils libmedia libz libbinder libdl libcutils libc 
+LOCAL_PRELINK_MODULE := false
+LOCAL_MODULE_TAGS := optional
+include $(BUILD_SHARED_LIBRARY)
+
+CC := $(HOST_CC)
+
diff --git a/amffmpeg/libavutil/Makefile b/amffmpeg/libavutil/Makefile
index 0d8f01d..2284b22 100644
--- a/amffmpeg/libavutil/Makefile
+++ b/amffmpeg/libavutil/Makefile
@@ -1,4 +1,4 @@
-include $(SUBDIR)../config.mak
+###include $(SUBDIR)../config.mak
 
 NAME = avutil
 
@@ -84,6 +84,6 @@ DIRS = arm bfin sh4 x86
 
 ARCH_HEADERS = bswap.h intmath.h intreadwrite.h timer.h
 
-include $(SUBDIR)../subdir.mak
+####include $(SUBDIR)../subdir.mak
 
 $(SUBDIR)lzo-test$(EXESUF): ELIBS = -llzo2
diff --git a/amffmpeg/libavutil/avconfig.h b/amffmpeg/libavutil/avconfig.h
new file mode 100644
index 0000000..36f72aa
--- /dev/null
+++ b/amffmpeg/libavutil/avconfig.h
@@ -0,0 +1,6 @@
+/* Generated by ffconf */
+#ifndef AVUTIL_AVCONFIG_H
+#define AVUTIL_AVCONFIG_H
+#define AV_HAVE_BIGENDIAN 0
+#define AV_HAVE_FAST_UNALIGNED 0
+#endif /* AVUTIL_AVCONFIG_H */
diff --git a/amffmpeg/libavutil/avutil.h b/amffmpeg/libavutil/avutil.h
index 4d6ef66..abafffd 100644
--- a/amffmpeg/libavutil/avutil.h
+++ b/amffmpeg/libavutil/avutil.h
@@ -92,6 +92,15 @@ enum AVMediaType {
     AVMEDIA_TYPE_NB
 };
 
+#define CODEC_TYPE_UNKNOWN  AVMEDIA_TYPE_UNKNOWN
+#define CODEC_TYPE_VIDEO  AVMEDIA_TYPE_VIDEO
+#define CODEC_TYPE_AUDIO  AVMEDIA_TYPE_AUDIO
+#define CODEC_TYPE_SUBTITLE  AVMEDIA_TYPE_SUBTITLE
+#define CODEC_TYPE_DATA  AVMEDIA_TYPE_DATA
+
+
+
+
 #define FF_LAMBDA_SHIFT 7
 #define FF_LAMBDA_SCALE (1<<FF_LAMBDA_SHIFT)
 #define FF_QP2LAMBDA 118 ///< factor to convert from H.263 QP to lambda
diff --git a/amffmpeg/libavutil/common.h b/amffmpeg/libavutil/common.h
index 1cd2de2..0563284 100644
--- a/amffmpeg/libavutil/common.h
+++ b/amffmpeg/libavutil/common.h
@@ -167,7 +167,7 @@ static av_always_inline av_const int16_t av_clip_int16_c(int a)
  */
 static av_always_inline av_const int32_t av_clipl_int32_c(int64_t a)
 {
-    if ((a+0x80000000u) & ~UINT64_C(0xFFFFFFFF)) return (a>>63) ^ 0x7FFFFFFF;
+    if ((a+0x80000000u) & ~(0xFFFFFFFF)) return (a>>63) ^ 0x7FFFFFFF;
     else                                         return a;
 }
 
diff --git a/amffmpeg/libavutil/libavutil-uninstalled.pc b/amffmpeg/libavutil/libavutil-uninstalled.pc
new file mode 100644
index 0000000..7c019c9
--- /dev/null
+++ b/amffmpeg/libavutil/libavutil-uninstalled.pc
@@ -0,0 +1,12 @@
+prefix=
+exec_prefix=
+libdir=${pcfiledir}
+includedir=/nishome/zhouzhi/android/android_rootfs_ref/packages/amlogic/LibPlayer/amffmpeg-0.8
+
+Name: libavutil
+Description: FFmpeg utility library
+Version: 51.9.1
+Requires: 
+Conflicts:
+Libs: ${libdir}/libavutil.a -lm
+Cflags: -I${includedir}
diff --git a/amffmpeg/libavutil/libavutil.pc b/amffmpeg/libavutil/libavutil.pc
new file mode 100644
index 0000000..d7a0f13
--- /dev/null
+++ b/amffmpeg/libavutil/libavutil.pc
@@ -0,0 +1,14 @@
+prefix=/usr/local
+exec_prefix=${prefix}
+libdir=${prefix}/lib
+includedir=${prefix}/include
+
+Name: libavutil
+Description: FFmpeg utility library
+Version: 51.9.1
+Requires: 
+Requires.private: 
+Conflicts:
+Libs: -L${libdir} -lavutil -lm
+Libs.private: 
+Cflags: -I${includedir}
diff --git a/amffmpeg/libavutil/log.c b/amffmpeg/libavutil/log.c
old mode 100644
new mode 100755
index fd5e2cb..e7907c4
--- a/amffmpeg/libavutil/log.c
+++ b/amffmpeg/libavutil/log.c
@@ -39,6 +39,16 @@ static int16_t background, attr_orig;
 static HANDLE con;
 #define set_color(x)  SetConsoleTextAttribute(con, background | color[x])
 #define reset_color() SetConsoleTextAttribute(con, attr_orig)
+#elif defined(ANDROID)
+#include <android/log.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <string.h>
+#define  LOG_TAG    "amffmpeg"
+#define  LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
+#define  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
+#define set_color(x) 
+#define reset_color()
 #else
 static const uint8_t color[]={0x41,0x41,0x11,0x03,9,9,9};
 #define set_color(x)  fprintf(stderr, "\033[%d;3%dm", color[x]>>4, color[x]&15)
@@ -69,7 +79,11 @@ static void colored_fputs(int level, const char *str){
     if(use_color){
         set_color(level);
     }
+#ifdef ANDROID
+	LOGI("%s", str);
+#else	
     fputs(str, stderr);
+#endif
     if(use_color){
         reset_color();
     }
diff --git a/amffmpeg/libswscale/libswscale-uninstalled.pc b/amffmpeg/libswscale/libswscale-uninstalled.pc
new file mode 100644
index 0000000..0b73688
--- /dev/null
+++ b/amffmpeg/libswscale/libswscale-uninstalled.pc
@@ -0,0 +1,12 @@
+prefix=
+exec_prefix=
+libdir=${pcfiledir}
+includedir=/nishome/zhouzhi/android/android_rootfs_ref/packages/amlogic/LibPlayer/amffmpeg-0.8
+
+Name: libswscale
+Description: FFmpeg image rescaling library
+Version: 2.0.0
+Requires: libavutil = 51.9.1
+Conflicts:
+Libs: ${libdir}/libswscale.a -lm
+Cflags: -I${includedir}
diff --git a/amffmpeg/libswscale/libswscale.pc b/amffmpeg/libswscale/libswscale.pc
new file mode 100644
index 0000000..daf3c59
--- /dev/null
+++ b/amffmpeg/libswscale/libswscale.pc
@@ -0,0 +1,14 @@
+prefix=/usr/local
+exec_prefix=${prefix}
+libdir=${prefix}/lib
+includedir=${prefix}/include
+
+Name: libswscale
+Description: FFmpeg image rescaling library
+Version: 2.0.0
+Requires: libavutil = 51.9.1
+Requires.private: 
+Conflicts:
+Libs: -L${libdir} -lswscale -lm
+Libs.private: 
+Cflags: -I${includedir}
diff --git a/amffmpeg/version.h b/amffmpeg/version.h
new file mode 100644
index 0000000..b6764d0
--- /dev/null
+++ b/amffmpeg/version.h
@@ -0,0 +1 @@
+#define FFMPEG_VERSION "0.8"
